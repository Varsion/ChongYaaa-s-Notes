<?xml version="1.0" encoding="UTF-8" ?>
<!-- This is a WordPress eXtended RSS file generated by WordPress as an export of your site. -->
<!-- It contains information about your site's posts, pages, comments, categories, and other content. -->
<!-- You may use this file to transfer that content from one site to another. -->
<!-- This file is not intended to serve as a complete backup of your site. -->

<!-- To import this information into a WordPress site follow these steps: -->
<!-- 1. Log in to that site as an administrator. -->
<!-- 2. Go to Tools: Import in the WordPress admin panel. -->
<!-- 3. Install the "WordPress" importer from the list. -->
<!-- 4. Activate & Run Importer. -->
<!-- 5. Upload this file using the form provided on that page. -->
<!-- 6. You will first be asked to map the authors in this export file to users -->
<!--    on the site. For each author, you may choose to map to an -->
<!--    existing user on the site or to create a new user. -->
<!-- 7. WordPress will then import each of the posts, pages, comments, categories, etc. -->
<!--    contained in this file into your site. -->

	<!-- generator="WordPress/5.4.4" created="2021-01-23 07:42" -->
<rss version="2.0"
	xmlns:excerpt="http://wordpress.org/export/1.2/excerpt/"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:wp="http://wordpress.org/export/1.2/"
>

<channel>
	<title>充鸭的手札</title>
	<link>https://blog.varsion.cn</link>
	<description>My mood</description>
	<pubDate>Sat, 23 Jan 2021 07:42:41 +0000</pubDate>
	<language>zh-CN</language>
	<wp:wxr_version>1.2</wp:wxr_version>
	<wp:base_site_url>https://blog.varsion.cn</wp:base_site_url>
	<wp:base_blog_url>https://blog.varsion.cn</wp:base_blog_url>

		<wp:author><wp:author_id>1</wp:author_id><wp:author_login><![CDATA[Varsion]]></wp:author_login><wp:author_email><![CDATA[JianhuaL12@outlook.com]]></wp:author_email><wp:author_display_name><![CDATA[Varsion]]></wp:author_display_name><wp:author_first_name><![CDATA[]]></wp:author_first_name><wp:author_last_name><![CDATA[]]></wp:author_last_name></wp:author>

				
	<generator>https://wordpress.org/?v=5.4.4</generator>

<image>
	<url>https://blog.varsion.cn/wp-content/uploads/2020/07/cropped-icon-32x32.jpg</url>
	<title>充鸭的手札</title>
	<link>https://blog.varsion.cn</link>
	<width>32</width>
	<height>32</height>
</image> 

		<item>
		<title>Hello!</title>
		<link>https://blog.varsion.cn/?p=1</link>
		<pubDate>Thu, 23 Jul 2020 02:09:10 +0000</pubDate>
		<dc:creator><![CDATA[Varsion]]></dc:creator>
		<guid isPermaLink="false">http://blog.varsion.cn/?p=1</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:group -->
<div class="wp-block-group"><div class="wp-block-group__inner-container"><!-- wp:paragraph -->
<p>这里是充鸭，</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>主攻方向为Ruby、Ruby On Rails及Ruby相关内容</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>对PHP、Javascript等主流Web开发也有一定的涉猎</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>我会不定期的在这里更新自己的笔记</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>感兴趣的话可以点击收藏我的主页</p>
<!-- /wp:paragraph -->

<!-- wp:social-links -->
<ul class="wp-block-social-links"><!-- wp:social-link {"url":"https://github.com/Varsion","service":"github"} /--></ul>
<!-- /wp:social-links --></div></div>
<!-- /wp:group -->

<!-- wp:image {"align":"center","id":255,"sizeSlug":"large"} -->
<div class="wp-block-image"><figure class="aligncenter size-large"><img src="http://img.varsion.cn/blog-img/2020/07/1595458712409.jpg" alt="" class="wp-image-255"/></figure></div>
<!-- /wp:image -->]]></content:encoded>
		<excerpt:encoded><![CDATA[这里是充鸭]]></excerpt:encoded>
		<wp:post_id>1</wp:post_id>
		<wp:post_date><![CDATA[2020-07-23 02:09:10]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2020-07-23 02:09:10]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[closed]]></wp:comment_status>
		<wp:ping_status><![CDATA[closed]]></wp:ping_status>
		<wp:post_name><![CDATA[hello]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>1</wp:is_sticky>
										<category domain="category" nicename="%e5%85%85%e9%b8%ad%e7%9a%84%e4%bb%8b%e7%bb%8d"><![CDATA[Me]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_wp_page_template]]></wp:meta_key>
		<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[rank_math_focus_keyword]]></wp:meta_key>
		<wp:meta_value><![CDATA[充鸭]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[rank_math_internal_links_processed]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[rank_math_primary_category]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[rank_math_seo_score]]></wp:meta_key>
		<wp:meta_value><![CDATA[55]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[no_intro]]></wp:meta_key>
		<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_no_intro]]></wp:meta_key>
		<wp:meta_value><![CDATA[nanospace_no_intro]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[no_intro_media]]></wp:meta_key>
		<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_no_intro_media]]></wp:meta_key>
		<wp:meta_value><![CDATA[nanospace_no_intro_media]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[intro_image]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_intro_image]]></wp:meta_key>
		<wp:meta_value><![CDATA[nanospace_intro_image]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[show_intro_widgets]]></wp:meta_key>
		<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_show_intro_widgets]]></wp:meta_key>
		<wp:meta_value><![CDATA[nanospace_show_intro_widgets]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[content_layout]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_content_layout]]></wp:meta_key>
		<wp:meta_value><![CDATA[nanospace_content_layout]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_primary_category]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_content_score]]></wp:meta_key>
		<wp:meta_value><![CDATA[90]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_wp_old_slug]]></wp:meta_key>
		<wp:meta_value><![CDATA[hello-world]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_focuskw]]></wp:meta_key>
		<wp:meta_value><![CDATA[充鸭的手札]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_metadesc]]></wp:meta_key>
		<wp:meta_value><![CDATA[这里是充鸭]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_linkdex]]></wp:meta_key>
		<wp:meta_value><![CDATA[30]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_thumbnail_id]]></wp:meta_key>
		<wp:meta_value><![CDATA[1555]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>Ruby对象元素属性</title>
		<link>https://blog.varsion.cn/?p=20</link>
		<pubDate>Thu, 23 Jul 2020 03:25:49 +0000</pubDate>
		<dc:creator><![CDATA[Varsion]]></dc:creator>
		<guid isPermaLink="false">http://blog.varsion.cn/?p=20</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p> Ruby中是没有属性(property/attribut)这样的东西。在Ruby中从对象外部不能直接访问实例变量或对实例变量赋值，需要通过该方法来访问对象的内部。假设有下面的例子： </p>
<!-- /wp:paragraph -->

<!-- wp:codemirror-blocks/code-block {"fileName":"1.rb","mode":"ruby","mime":"text/x-ruby"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre>class HelloWorld
  def initialize(myname = &quot;Ruby&quot;)
    @name = myname
  end
end
bob = HelloWorld.new(&quot;ruby&quot;)
bob.name = &quot;Bob&quot;
puts bob.name</pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:image {"id":21,"sizeSlug":"large"} -->
<figure class="wp-block-image size-large"><img src="http://img.varsion.cn/blog-img/2020/07/image-20200720164044888.png" alt="" class="wp-image-21"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p> 在Ruby中，如果是括号内的参数，括号是可以直接省略的。所以，对于<code>bob.name</code>，由于Ruby中是没有属性的，其实我们调用的是<code>bob.name()</code>中<code>.name()</code>方法。对于<code>bob.name = "Bob"</code>实际是执行<code>bob.name = ("Bob")</code>方法，上面两个方法都没有定义所以会报错。另外比如一个简单的<code>1 + 1</code>并不是一个简单的数学运算，而是<code>1.+(2)</code>，是执行了数字1的<code>+</code>方法，其中参数是2。那么在Ruby中，如何定义对实例变量的访问和变更呢？ </p>
<!-- /wp:paragraph -->

<!-- wp:codemirror-blocks/code-block {"fileName":"2.rb","mode":"ruby","mime":"text/x-ruby"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre>class HelloWorld
  def initialize(myname = &quot;Ruby&quot;)
    @name = myname
  end

  def name
    return @name
  end

  def name= (value)
    @name = value
  end

end
bob = HelloWorld.new(&quot;Jhon&quot;)
bob.name = &quot;Bob&quot;
puts bob.name</pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:paragraph -->
<p>上面的 <code>def name</code>方法就相当于我们所知道的getter方法，<code>def name=</code>就是我们所知道的setter方法。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>但是如果实例变量太多，如果都这么定义岂不是很麻烦，所以Ruby为我们提供了简便定义的方法<code>attr_reader,attr_writer,attr_accessor</code>只要指定了变量名的符号，Ruby就会为我们定义响应的存储器。</p>
<!-- /wp:paragraph -->

<!-- wp:table -->
<figure class="wp-block-table"><table class=""><thead><tr><th class="has-text-align-center" data-align="center">定义</th><th class="has-text-align-center" data-align="center">含义</th></tr></thead><tbody><tr><td class="has-text-align-center" data-align="center">attr_reader  :name</td><td class="has-text-align-center" data-align="center">只读(定义name方法)</td></tr><tr><td class="has-text-align-center" data-align="center">attr_writeer :name</td><td class="has-text-align-center" data-align="center">只写(定义name=方法)</td></tr><tr><td class="has-text-align-center" data-align="center">attr_accessor:name</td><td class="has-text-align-center" data-align="center">读写(定义以上连个方法)</td></tr></tbody></table></figure>
<!-- /wp:table -->

<!-- wp:codemirror-blocks/code-block {"fileName":"3.rb","mode":"ruby","mime":"text/x-ruby"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre>class HelloWorld
  def initialize(myname = &quot;Ruby&quot;)
    @name = myname
  end

  # def name
  #     return @name
  # end

  # def name= (value)
  #     @name = value
  # end
  attr_accessor :name
end
bob = HelloWorld.new(&quot;Jhon&quot;)
bob.name = &quot;Bob&quot;
puts bob.name</pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:separator {"className":"is-style-wide"} -->
<hr class="wp-block-separator is-style-wide"/>
<!-- /wp:separator -->

<!-- wp:block {"ref":178} /-->]]></content:encoded>
		<excerpt:encoded><![CDATA[ Ruby中是没有属性(property/attribut)这样的东西。在Ruby中从对象外部不能直接访问实例变量或对实例变量赋值，需要通过该方法来访问对象的内部。]]></excerpt:encoded>
		<wp:post_id>20</wp:post_id>
		<wp:post_date><![CDATA[2020-07-23 11:25:49]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2020-07-23 03:25:49]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[ruby%e5%af%b9%e8%b1%a1%e5%85%83%e7%b4%a0%e5%b1%9e%e6%80%a7]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="object"><![CDATA[Object]]></category>
		<category domain="category" nicename="ruby"><![CDATA[Ruby]]></category>
		<category domain="post_tag" nicename="ruby"><![CDATA[Ruby]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_is_githuber_markdown_enabled]]></wp:meta_key>
		<wp:meta_value><![CDATA[no]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[rank_math_focus_keyword]]></wp:meta_key>
		<wp:meta_value><![CDATA[Ruby]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[rank_math_internal_links_processed]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[rank_math_primary_category]]></wp:meta_key>
		<wp:meta_value><![CDATA[3]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[rank_math_seo_score]]></wp:meta_key>
		<wp:meta_value><![CDATA[62]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[rank_math_description]]></wp:meta_key>
		<wp:meta_value><![CDATA[ Ruby中是没有属性(property/attribut)这样的东西。在Ruby中从对象外部不能直接访问实例变量或对实例变量赋值，需要通过该方法来访问对象的内部。]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[no_intro]]></wp:meta_key>
		<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_no_intro]]></wp:meta_key>
		<wp:meta_value><![CDATA[nanospace_no_intro]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[no_intro_media]]></wp:meta_key>
		<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_no_intro_media]]></wp:meta_key>
		<wp:meta_value><![CDATA[nanospace_no_intro_media]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[intro_image]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_intro_image]]></wp:meta_key>
		<wp:meta_value><![CDATA[nanospace_intro_image]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[show_intro_widgets]]></wp:meta_key>
		<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_show_intro_widgets]]></wp:meta_key>
		<wp:meta_value><![CDATA[nanospace_show_intro_widgets]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[content_layout]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_content_layout]]></wp:meta_key>
		<wp:meta_value><![CDATA[nanospace_content_layout]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>Ruby对象原生行为</title>
		<link>https://blog.varsion.cn/?p=42</link>
		<pubDate>Thu, 23 Jul 2020 04:31:16 +0000</pubDate>
		<dc:creator><![CDATA[Varsion]]></dc:creator>
		<guid isPermaLink="false">http://blog.varsion.cn/?p=42</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:quote -->
<blockquote class="wp-block-quote"><p>只要创建对象存在，他就能相应一组消息，每个对象在被创建时都语句确切的能力</p><cite>在<code>irb</code>解释器中 <code>p Object.new.methods.sort</code> 可以查看其原始方法</cite></blockquote>
<!-- /wp:quote -->

<!-- wp:image {"id":49,"sizeSlug":"large"} -->
<figure class="wp-block-image size-large"><img src="http://img.varsion.cn/blog-img/2020/07/79@XODLAV@7W0346WNKZ2.png" alt="" class="wp-image-49"/></figure>
<!-- /wp:image -->

<!-- wp:heading {"level":3} -->
<h3> <strong><code>object_id</code>表示唯一对象</strong> </h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p> Ruby中每一个对象都有一个和他唯一关联的ID编号，可以通过请求<code>object_id</code>获得该对象的ID 。</p>
<!-- /wp:paragraph -->

<!-- wp:codemirror-blocks/code-block {"fileName":"class.rb","mode":"ruby","mime":"text/x-ruby"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre>class Tist
  def initialize(id)
    @id = id
  end

  def getID
    return @id
  end

end</pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:codemirror-blocks/code-block {"fileName":"object_id.rb","mode":"ruby","mime":"text/x-ruby"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre>load &quot;class.rb&quot;
ts1 = Tist.new(&quot;1&quot;)
ts2 = Tist.new(&quot;2&quot;)

puts ts1.object_id
puts ts2.object_id</pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:image {"align":"center","id":43,"sizeSlug":"large"} -->
<div class="wp-block-image"><figure class="aligncenter size-large"><img src="http://img.varsion.cn/blog-img/2020/07/1.png" alt="" class="wp-image-43"/></figure></div>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>上述尝试可以看出，同为一个类的对象<code>object_id</code>并不相等</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>在尝试确认两个对象是否相等时，可以采取判断<code>objectt_id</code>的方法</p>
<!-- /wp:paragraph -->

<!-- wp:codemirror-blocks/code-block {"fileName":"object_id.rb","mode":"ruby","mime":"text/x-ruby"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre>load &quot;class.rb&quot;
ts1 = Tist.new(&quot;1&quot;)
ts2 = Tist.new(&quot;2&quot;)

ts = ts1
puts ts1.object_id
puts ts.object_id</pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:image {"align":"center","id":45,"sizeSlug":"large"} -->
<div class="wp-block-image"><figure class="aligncenter size-large"><img src="http://img.varsion.cn/blog-img/2020/07/image-20200723075513344.png" alt="" class="wp-image-45"/></figure></div>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>ID编号和对象的相等性</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>         Ruby中给对象指定一个ID编号能够使对象有唯一的身份标识 </p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p></p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>  <strong><code>respond_to?</code>方法查询对象的能力</strong> </h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Ruby对象响应消息，在程序运行期间的不同时间点，依赖于对象和为对象定义的各种方法。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>用户可以提前判断（在要求对象执行任务前）对想是否知道如何处理发送给他的消息，<code>respond_to?</code>对于所有对象都适用，通常和<code>if</code>语句联合使用</p>
<!-- /wp:paragraph -->

<!-- wp:codemirror-blocks/code-block {"fileName":"respond_to.rb","mode":"ruby","mime":"text/x-ruby"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre>obj = Object.new
	if obj.respond_to?(&quot;talk&quot;)
		obj.talk
	else
		puts &quot;error&quot;
end</pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:paragraph -->
<p> <code>respond_to?</code>使自省（<em>introspection</em>）或者反射（<em>reflection</em>）的一个例子 </p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3> <strong><code>send</code>方法发送信息给对象</strong> </h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p><code>send</code>方法类似于<code>.</code>方法调用对象函数</p>
<!-- /wp:paragraph -->

<!-- wp:codemirror-blocks/code-block {"fileName":"send.rb","mode":"ruby","mime":"text/x-ruby"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre>obj = Object.new
	if obj.respond_to?(&quot;talk&quot;)
		obj.send(&quot;talk&quot;)
	else
		puts &quot;error&quot;
end</pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:quote -->
<blockquote class="wp-block-quote"><p><strong>使用<code>__send__</code>或者<code>public_send</code>代替send</strong></p></blockquote>
<!-- /wp:quote -->

<!-- wp:list -->
<ul><li><code>__send__</code>是为了避免<code>send</code>方法和对象内建方法冲突</li><li><code>send</code>和<code>__send__</code>可以调用对象的私有方法，<code>public_send</code>方法却不能</li></ul>
<!-- /wp:list -->

<!-- wp:separator {"className":"is-style-wide"} -->
<hr class="wp-block-separator is-style-wide"/>
<!-- /wp:separator -->

<!-- wp:block {"ref":178} /-->]]></content:encoded>
		<excerpt:encoded><![CDATA[只要创建对象存在，他就能相应一组消息，每个对象在被创建时都语句确切的能力]]></excerpt:encoded>
		<wp:post_id>42</wp:post_id>
		<wp:post_date><![CDATA[2020-07-23 12:31:16]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2020-07-23 04:31:16]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[ruby%e5%af%b9%e8%b1%a1%e5%8e%9f%e7%94%9f%e8%a1%8c%e4%b8%ba]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="object"><![CDATA[Object]]></category>
		<category domain="category" nicename="ruby"><![CDATA[Ruby]]></category>
		<category domain="post_tag" nicename="ruby"><![CDATA[Ruby]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[rank_math_focus_keyword]]></wp:meta_key>
		<wp:meta_value><![CDATA[Ruby]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[rank_math_internal_links_processed]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[rank_math_primary_category]]></wp:meta_key>
		<wp:meta_value><![CDATA[3]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[rank_math_seo_score]]></wp:meta_key>
		<wp:meta_value><![CDATA[63]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[no_intro]]></wp:meta_key>
		<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_no_intro]]></wp:meta_key>
		<wp:meta_value><![CDATA[nanospace_no_intro]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[no_intro_media]]></wp:meta_key>
		<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_no_intro_media]]></wp:meta_key>
		<wp:meta_value><![CDATA[nanospace_no_intro_media]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[intro_image]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_intro_image]]></wp:meta_key>
		<wp:meta_value><![CDATA[nanospace_intro_image]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[show_intro_widgets]]></wp:meta_key>
		<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_show_intro_widgets]]></wp:meta_key>
		<wp:meta_value><![CDATA[nanospace_show_intro_widgets]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[content_layout]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_content_layout]]></wp:meta_key>
		<wp:meta_value><![CDATA[nanospace_content_layout]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>基于MQTT实现Arduino远程通信</title>
		<link>https://blog.varsion.cn/?p=84</link>
		<pubDate>Fri, 24 Jul 2020 07:30:40 +0000</pubDate>
		<dc:creator><![CDATA[Varsion]]></dc:creator>
		<guid isPermaLink="false">http://blog.varsion.cn/?p=84</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:quote {"className":"is-style-default"} -->
<blockquote class="wp-block-quote is-style-default"><p>原载于CSDN  2019-04-19&nbsp; </p><p> <a href="https://blog.csdn.net/qq_44350275/article/details/89406527">https://blog.csdn.net/qq_44350275/article/details/89406527</a> </p><cite>现搬运到自己的Blog<br>这里放上我的CSDN链接<br> <a href="https://me.csdn.net/qq_44350275?ref=miniprofile">https://me.csdn.net/qq_44350275?ref=miniprofile</a> </cite></blockquote>
<!-- /wp:quote -->

<!-- wp:paragraph -->
<p>我在做竞赛项目的时候，在板子和板子远程交互上做的东西<br>百度上找到的东西也都是七零八碎的，<br>同时也希望我的博客能给大家一点微薄的帮助</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>准备工作</h2>
<!-- /wp:heading -->

<!-- wp:list {"ordered":true} -->
<ol><li>Arduino ide的准备安装。</li><li>ESP8266模块+UNO 或者 NodeMCU和WIFIduino（初学者推荐后两个选择）</li><li>搭建自己的MQTT服务器</li><li>准备两个库 PubSubclient 和 esp8266wifi</li></ol>
<!-- /wp:list -->

<!-- wp:heading -->
<h2>MQTT服务器的介绍</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>MQTT（Message Queuing Telemetry Transport，消息队列遥测传输协议），是一种基于发布/订阅（publish/subscribe）模式的"轻量级"通讯协议，该协议构建于TCP/IP协议上，由IBM在1999年发布。MQTT最大优点在于，可以以极少的代码和有限的带宽，为连接远程设备提供实时可靠的消息服务。作为一种低开销、低带宽占用的即时通讯协议，使其在物联网、小型设备、移动应用等方面有较广泛的应用。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>MQTT是一个基于客户端-服务器的消息发布/订阅传输协议。MQTT协议是轻量、简单、开放和易于实现的，这些特点使它适用范围非常广泛。在很多情况下，包括受限的环境中，如：机器与机器（M2M）通信和物联网（IoT）。其在，通过卫星链路通信传感器、偶尔拨号的医疗设备、智能家居、及一些小型化设备中已广泛使用。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>而对于Arduino来说——只需要简单的发布消息和接收消息——是再好不过的选择，而且有现成的库文件，也不需要我们再去做很多其他工作。</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>MQTT服务器的搭建</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>我在Windows上搭建MQTT服务器的时候 一直遇到一个.dll文件缺失 所以我就转到Ubuntu上搭建服务器了。<br>个人推荐用EMQ这个软件来搭（管理台界面好看而且有中文）<br>自己电脑上搭服务器的缺点是，必须在同局域网下——即你的板子你的手机和你的电脑链接的是同一个WIFI——才能链接这个服务器，主要原因是你的电脑不具有公网IP没有办法在公网下访问，如果只是自己学东西建议是在自己的电脑上搭。<br>如果是要出产品 建议去租阿里的服务器（我是白嫖了朋友一个）</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>两个库文件</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>PubSubclient 这个库文件应该是对MQTT支持比较完美的库文件<br>请到该github链接上下载或者官网<br>github下载链接:&nbsp;<a href="https://github.com/knolleary/pubsubclient">link</a>.<br>官网下载链接:&nbsp;<a href="https://www.arduinolibraries.info/libraries/pub-sub-client">link</a>.<br>这个库文件的详细说明请见该库文件的API文档<br>API文档:&nbsp;<a href="https://pubsubclient.knolleary.net/api.html">link</a>.</p>
<!-- /wp:paragraph -->

<!-- wp:image -->
<figure class="wp-block-image"><img src="https://img-blog.csdnimg.cn/20190419200225754.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MzUwMjc1,size_16,color_FFFFFF,t_70" alt="如图选中的示例"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>而我们真正用到的 只是其中的一个示例：<br>ESP8266WIFI<br>该库可在我的github上找到：<br>下载链接:&nbsp;<a class="rank-math-link" href="https://github.com/Varsion/ESP8266WiFi">link</a>.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>接下来我会详细的解释这个例子，这个例子实现了最简单的发布信息和接受信息：</p>
<!-- /wp:paragraph -->

<!-- wp:codemirror-blocks/code-block {"fileName":"file.ino","mode":"clike","mime":"text/x-csrc"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre>/*
基本的ESP8266 MQTT示例

 该草图演示了pubsub库的组合功能
 与ESP8266板/库。
 它连接到MQTT服务器，然后：
   - 每两秒向“outTopic”主题发布“hello world”
   - 订阅“inTopic”主题，打印出任何消息
    它接收。 NB  - 它假设收到的有效载荷是非二进制的字符串
   - 如果主题“inTopic”的第一个字符为1，则打开ESP Led，
    否则关掉它
 如果使用阻止丢失连接，它将重新连接到服务器
 重新连接功能。有关如何使用，请参阅'mqtt_reconnect_nonblocking'示例
 在不阻塞主循环的情况下实现相同的结果。

 要安装ESP8266板，（使用Arduino 1.6.4+）：
   - 在“文件 - &gt;首选项 - &gt;其他板卡管理器URL”下添加以下第三方板卡管理器：
      http://arduino.esp8266.com/stable/package_esp8266com_index.json
   - 打开“工具 - &gt;板 - &gt;板管理器”，然后单击ESP8266的安装“
   - 在“工具 - &gt;板”中选择您的ESP8266
这个是我用翻译把顶部注释翻译了
*/

#include &lt;ESP8266WiFi.h&gt;
#include &lt;PubSubClient.h&gt;

const char* ssid = &quot;........&quot;;//你要让板子链接的WiFi的名字
const char* password = &quot;........&quot;;//该WiFi的密码
const char* mqtt_server = &quot;broker.mqtt-dashboard.com&quot;;//你的服务器地址

WiFiClient espClient;
PubSubClient client(espClient);
long lastMsg = 0;
char msg[50];
int value = 0;

void setup_wifi() {

  delay(10);
   Serial.println();
  Serial.print(&quot;Connecting to &quot;);
  Serial.println(ssid);

  WiFi.begin(ssid, password);

  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(&quot;.&quot;);
  }

  randomSeed(micros());

  Serial.println(&quot;&quot;);
  Serial.println(&quot;WiFi connected&quot;);
  Serial.println(&quot;IP address: &quot;);
  Serial.println(WiFi.localIP());
}//链接WiFi

void callback(char* topic, byte* payload, unsigned int length) {
  Serial.print(&quot;Message arrived [&quot;);
  Serial.print(topic);
  Serial.print(&quot;] &quot;);
  for (int i = 0; i &lt; length; i++) {
    Serial.print((char)payload[i]);
  }//串口打印出收到的信息
  Serial.println();

  // 如果收到1作为第一个字符，则打开LED
  if ((char)payload[0] == '1') {
    digitalWrite(BUILTIN_LED, LOW);   // 这里他说接受的‘1’就打开灯 但是我在用的时候 接收到0才会打开  这一行的‘LOW’和下面的‘HIGH’应该换下位置，下面也说了 ESP-01是这样的
    // but actually the LED is on; this is because
    // it is active low on the ESP-01)
  } else {
    digitalWrite(BUILTIN_LED, HIGH);  // Turn the LED off by making the voltage HIGH
  }

}

void reconnect() {
  // Loop until we're reconnected
  while (!client.connected()) {
    Serial.print(&quot;Attempting MQTT connection...&quot;);
    // Create a random client ID
    String clientId = &quot;ESP8266Client-&quot;;//该板子的链接名称
    clientId += String(random(0xffff), HEX);//产生一个随机数字 以免多块板子重名
    //尝试连接
    if (client.connect(clientId.c_str())) {
      Serial.println(&quot;connected&quot;);
      // 连接后，发布公告......
      client.publish(&quot;outTopic&quot;, &quot;hello world&quot;);//链接成功后 会发布这个主题和语句
      // ......并订阅
      client.subscribe(&quot;inTopic&quot;);//这个是你让板子订阅的主题（接受该主题的消息）
    } else {
      Serial.print(&quot;failed, rc=&quot;);
      Serial.print(client.state());
      Serial.println(&quot; try again in 5 seconds&quot;);
      // 如果链接失败 等待五分钟重新链接
      delay(5000);
    }
  }
}

void setup() {
  pinMode(BUILTIN_LED, OUTPUT);     // 将BUILTIN_LED引脚初始化为输出
  Serial.begin(115200);
  setup_wifi();
  client.setServer(mqtt_server, 1883);//MQTT默认端口是1883
  client.setCallback(callback);
}

void loop() {

  if (!client.connected()) {
    reconnect();
  }
  client.loop();

  long now = millis();
  if (now - lastMsg &gt; 2000) {
    lastMsg = now;
    ++value;
    snprintf (msg, 50, &quot;hello world #%ld&quot;, value);
    Serial.print(&quot;Publish message: &quot;);
    Serial.println(msg);//串口打印，串口调试器可以看到的
    client.publish(&quot;outTopic&quot;, msg);//接收该主题消息
  }
}
</pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:heading -->
<h2>手机调试软件——MyMQTT</h2>
<!-- /wp:heading -->

<!-- wp:image -->
<figure class="wp-block-image"><img src="https://img-blog.csdnimg.cn/20190419204641993.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MzUwMjc1,size_16,color_FFFFFF,t_70" alt="链接设置"/></figure>
<!-- /wp:image -->

<!-- wp:image -->
<figure class="wp-block-image"><img src="https://img-blog.csdnimg.cn/20190419204651168.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MzUwMjc1,size_16,color_FFFFFF,t_70" alt="功能用法"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>该软件已经上架Google，没有条件翻墙的朋友 我把该软件上传了百度网盘 可以在该链接下下载<br>链接:&nbsp;<a href="https://pan.baidu.com/s/1KPXMB7nSl9yBXLF7gqVL1A" class="rank-math-link">link</a>.<br>提取码：jdd8</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>下面贴上的是我自己将发布和订阅分开的代码（待完善）</h3>
<!-- /wp:heading -->

<!-- wp:heading {"level":6} -->
<h6>发布消息</h6>
<!-- /wp:heading -->

<!-- wp:codemirror-blocks/code-block {"fileName":"file.ino","mode":"clike","mime":"text/x-csrc"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre>/*
基本的ESP8266 MQTT示例

 该草图演示了pubsub库的组合功能
 与ESP8266板/库。
仅仅发布信息，以光敏电阻为例子
*/

#include &lt;ESP8266WiFi.h&gt;
#include &lt;PubSubClient.h&gt;

const char* ssid = &quot;***&quot;;//wifi名称
const char* password = &quot;***&quot;;//wifi密码
const char* mqtt_server = &quot;***&quot;;//服务器地址
const char* out_topic_name=&quot;***&quot;;//所发布主题的名称
const char* bolid_name=&quot;***&quot;;//该板的编号-名称
/**/

WiFiClient espClient;
PubSubClient client(espClient);
long lastMsg = 0;
char msg[50];
int value = 0;

void setup_wifi() 
{
  delay(10);
  Serial.println();
  Serial.print(&quot;Connecting to &quot;);
  Serial.println(ssid);

  WiFi.begin(ssid, password);

  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(&quot;.....&quot;);
  }//链接wifi

  randomSeed(micros());
  Serial.println(&quot;&quot;);
  Serial.println(&quot;WiFi connected&quot;);
  Serial.println(&quot;IP address: &quot;);
  Serial.println(WiFi.localIP());
}

void reconnect()
{
  while (!client.connected()) {
    Serial.print(&quot;Attempting MQTT connection...&quot;);
    String clientId = bolid_name;
    if (client.connect(clientId.c_str())) {
      Serial.println(&quot;connected&quot;);
      // 连接后，发布公告 Success
      client.publish(&quot;out_topic_name&quot;, &quot;Success!&quot;);
      } else {
      Serial.print(&quot;failed, rc=&quot;);
      Serial.print(client.state());
      Serial.println(&quot; try again in 5 seconds&quot;);
      delay(5000);
    }
  }
}//一直循环直到连接上服务器之后

void setup() {
  Serial.begin(115200);//设置波特率
  setup_wifi();
  client.setServer(mqtt_server, 1883);
}

void loop() {
 int sensorValue = analogRead(A0);//光敏读数
  if (!client.connected()) {
    reconnect();
  }
  client.loop();

    snprintf (msg, 50, &quot;%ld&quot;,sensorValue );
    Serial.print(&quot;Publish message: &quot;);
    Serial.println(msg);//同时串口输出
    client.publish(&quot;out_topic_name&quot;, msg);
    delay(10000);
  
}
</pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:heading {"level":6} -->
<h6>订阅消息</h6>
<!-- /wp:heading -->

<!-- wp:codemirror-blocks/code-block {"fileName":"file.","mode":"clike","mime":"text/x-csrc"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre>//接受信息 来控制灯泡的亮灭
#include &lt;ESP8266WiFi.h&gt;
#include &lt;PubSubClient.h&gt;

const char* ssid = &quot;***&quot;;
const char* password = &quot;***&quot;;
const char* mqtt_server = &quot;***&quot;;
const char* in_Topic_name=&quot;***&quot;;//所接收主题的名称
const char* bolid_name=&quot;***&quot;;//该板的名称-编号

WiFiClient espClient;
PubSubClient client(espClient);
char msg[50];
int light = 255;

void setup_wifi() 
{ delay(10);
  Serial.println();
  Serial.print(&quot;Connecting to &quot;);
  Serial.println(ssid);
  WiFi.begin(ssid, password);
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(&quot;....&quot;);
  }

  randomSeed(micros());

  Serial.println(&quot;&quot;);
  Serial.println(&quot;WiFi connected&quot;);
  Serial.println(&quot;IP address: &quot;);
  Serial.println(WiFi.localIP());
}//链接wifi

void callback(char* topic, byte* payload, unsigned int length) 
{ int l=0;
  int p=1;
  Serial.print(&quot;Message arrived [&quot;);
  Serial.print(topic);
  Serial.print(&quot;]： &quot;);
  for (int i = length-1; i &gt;=0; i--) {
    l+=(int)((char)payload[i]-'0')*p;
    Serial.print(l);//增加串口显示
     p*=10;
  }
  Serial.println();
  light=l;

}//传入信息改变light的值 1-亮 0-不亮

void reconnect() {
  // Loop until we're reconnected
  while (!client.connected()) {
    Serial.print(&quot;Attempting MQTT connection...&quot;);
    String clientId = &quot;bolid_name&quot;;//该板子名称
    // Attempt to connect
    if (client.connect(clientId.c_str())) {
      Serial.println(&quot;connected&quot;);
     
      client.subscribe(&quot;in_Topic_name&quot;);//订阅主题
    } else {
      Serial.print(&quot;failed, rc=&quot;);
      Serial.print(client.state());
      Serial.println(&quot; try again in 5 seconds&quot;);
      // 等待五秒钟直到链接上
      delay(5000);
    }
  }
}

void setup() 
{ pinMode(D2, OUTPUT); //控制d2的灯泡 
  Serial.begin(115200);
  setup_wifi();
  client.setServer(mqtt_server, 1883);
  client.setCallback(callback);
}

void loop() 
{  if (!client.connected()) {
    reconnect();
  }//如果链接没有建立 那么重新连接
  client.loop();
  delay(500);
  analogWrite(D2,light);
}
</pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:paragraph -->
<p>更多PubSubclien库的用法 详见上文的官方API文档，</p>
<!-- /wp:paragraph -->

<!-- wp:separator {"className":"is-style-wide"} -->
<hr class="wp-block-separator is-style-wide"/>
<!-- /wp:separator -->

<!-- wp:block {"ref":178} /-->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>84</wp:post_id>
		<wp:post_date><![CDATA[2020-07-24 15:30:40]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2020-07-24 07:30:40]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e5%9f%ba%e4%ba%8emqtt%e5%ae%9e%e7%8e%b0arduino%e8%bf%9c%e7%a8%8b%e9%80%9a%e4%bf%a1]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="arduino"><![CDATA[Arduino]]></category>
		<category domain="post_tag" nicename="mqtt"><![CDATA[MQTT]]></category>
		<category domain="category" nicename="%e7%89%a9%e8%81%94%e7%bd%91"><![CDATA[物联网]]></category>
		<category domain="post_tag" nicename="%e7%89%a9%e8%81%94%e7%bd%91"><![CDATA[物联网]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_oembed_89707c271c140165401b9a148ba3fb41]]></wp:meta_key>
		<wp:meta_value><![CDATA[{{unknown}}]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[rank_math_seo_score]]></wp:meta_key>
		<wp:meta_value><![CDATA[74]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[rank_math_primary_category]]></wp:meta_key>
		<wp:meta_value><![CDATA[6]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[no_intro]]></wp:meta_key>
		<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_no_intro]]></wp:meta_key>
		<wp:meta_value><![CDATA[nanospace_no_intro]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[no_intro_media]]></wp:meta_key>
		<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_no_intro_media]]></wp:meta_key>
		<wp:meta_value><![CDATA[nanospace_no_intro_media]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[intro_image]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_intro_image]]></wp:meta_key>
		<wp:meta_value><![CDATA[nanospace_intro_image]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[show_intro_widgets]]></wp:meta_key>
		<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_show_intro_widgets]]></wp:meta_key>
		<wp:meta_value><![CDATA[nanospace_show_intro_widgets]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[content_layout]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_content_layout]]></wp:meta_key>
		<wp:meta_value><![CDATA[nanospace_content_layout]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[rank_math_internal_links_processed]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[rank_math_description]]></wp:meta_key>
		<wp:meta_value><![CDATA[基于MQTT实现Arduino远程通讯
我在做竞赛项目的时候，在板子和板子远程交互上做的东西
百度上找到的东西也都是七零八碎的，
同时也希望我的博客能给大家一点微薄的帮助
]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[rank_math_facebook_enable_image_overlay]]></wp:meta_key>
		<wp:meta_value><![CDATA[on]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[rank_math_rich_snippet]]></wp:meta_key>
		<wp:meta_value><![CDATA[article]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[rank_math_focus_keyword]]></wp:meta_key>
		<wp:meta_value><![CDATA[MQTT,arduino]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[rank_math_pillar_content]]></wp:meta_key>
		<wp:meta_value><![CDATA[off]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_oembed_b316ab8fb4ad659235a2a1fc94d976ce]]></wp:meta_key>
		<wp:meta_value><![CDATA[{{unknown}}]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_oembed_8fdf59e973bfe4426062076ba2b17151]]></wp:meta_key>
		<wp:meta_value><![CDATA[{{unknown}}]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_oembed_bb1f329451ba304edd1d3da4971b8cb3]]></wp:meta_key>
		<wp:meta_value><![CDATA[{{unknown}}]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_oembed_6a4820be8703d20bc15d4189605f82d6]]></wp:meta_key>
		<wp:meta_value><![CDATA[{{unknown}}]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_oembed_b58ed26f1ed78477a7443a66a272e993]]></wp:meta_key>
		<wp:meta_value><![CDATA[{{unknown}}]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_oembed_1fc5a33a22785329f66416b0b93b76e4]]></wp:meta_key>
		<wp:meta_value><![CDATA[{{unknown}}]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_oembed_d00e215329613c9ecdfc942d97c16c08]]></wp:meta_key>
		<wp:meta_value><![CDATA[{{unknown}}]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>SQLite基础—Day1</title>
		<link>https://blog.varsion.cn/?p=133</link>
		<pubDate>Sat, 25 Jul 2020 03:28:00 +0000</pubDate>
		<dc:creator><![CDATA[Varsion]]></dc:creator>
		<guid isPermaLink="false">http://blog.varsion.cn/?p=133</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:quote -->
<blockquote class="wp-block-quote"><p> SQLite 是一个软件库，实现了自给自足的、无服务器的、零配置的、事务性的 SQL 数据库引擎。SQLite 是在世界上最广泛部署的 SQL 数据库引擎。 </p></blockquote>
<!-- /wp:quote -->

<!-- wp:group -->
<div class="wp-block-group"><div class="wp-block-group__inner-container"><!-- wp:paragraph -->
<p>这里将记录我的SQLite的学习过程</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>SQLite的大多数操作都类似于MySQL或者说基本是一样的</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>熟悉使用MySQL的朋友应该很容易就会上手</p>
<!-- /wp:paragraph --></div></div>
<!-- /wp:group -->

<!-- wp:heading -->
<h2>数据类型</h2>
<!-- /wp:heading -->

<!-- wp:heading {"level":4} -->
<h4>数据类型</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>SQLite 数据类型是一个用来指定任何对象的数据类型的属性。SQLite 中的每一列，每个变量和表达式都有相关的数据类型。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>您可以在创建表的同时使用这些数据类型。SQLite 使用一个更普遍的动态类型系统。在 SQLite 中，值的数据类型与值本身是相关的，而不是与它的容器相关。</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":6} -->
<h6>存储类</h6>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>每个存储在 SQLite 数据库中的值都具有以下存储类之一：</p>
<!-- /wp:paragraph -->

<!-- wp:table -->
<figure class="wp-block-table"><table><thead><tr><th>存储类</th><th>描述</th></tr></thead><tbody><tr><td>NULL</td><td>值是一个 NULL 值。</td></tr><tr><td>INTEGER</td><td>值是一个带符号的整数，根据值的大小存储在 1、2、3、4、6 或 8 字节中。</td></tr><tr><td>REAL</td><td>值是一个浮点值，存储为 8 字节的 IEEE 浮点数字。</td></tr><tr><td>TEXT</td><td>值是一个文本字符串，使用数据库编码（UTF-8、UTF-16BE 或 UTF-16LE）存储。</td></tr><tr><td>BLOB</td><td>值是一个 blob 数据，完全根据它的输入存储。</td></tr></tbody></table></figure>
<!-- /wp:table -->

<!-- wp:paragraph -->
<p>SQLite 的存储类稍微比数据类型更普遍。INTEGER 存储类，例如，包含 6 种不同的不同长度的整数数据类型。</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":5} -->
<h5>SQLite 亲和(Affinity)类型</h5>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>SQLite支持列的亲和类型概念。任何列仍然可以存储任何类型的数据，当数据插入时，该字段的数据将会优先采用亲缘类型作为该值的存储方式。SQLite目前的版本支持以下五种亲缘类型：</p>
<!-- /wp:paragraph -->

<!-- wp:table -->
<figure class="wp-block-table"><table><thead><tr><th>亲和类型</th><th>描述</th></tr></thead><tbody><tr><td>TEXT</td><td>数值型数据在被插入之前，需要先被转换为文本格式，之后再插入到目标字段中。</td></tr><tr><td>NUMERIC</td><td>当文本数据被插入到亲缘性为NUMERIC的字段中时，如果转换操作不会导致数据信息丢失以及完全可逆，那么SQLite就会将该文本数据转换为INTEGER或REAL类型的数据，如果转换失败，SQLite仍会以TEXT方式存储该数据。对于NULL或BLOB类型的新数据，SQLite将不做任何转换，直接以NULL或BLOB的方式存储该数据。需要额外说明的是，对于浮点格式的常量文本，如"30000.0"，如果该值可以转换为INTEGER同时又不会丢失数值信息，那么SQLite就会将其转换为INTEGER的存储方式。</td></tr><tr><td>INTEGER</td><td>对于亲缘类型为INTEGER的字段，其规则等同于NUMERIC，唯一差别是在执行CAST表达式时。</td></tr><tr><td>REAL</td><td>其规则基本等同于NUMERIC，唯一的差别是不会将"30000.0"这样的文本数据转换为INTEGER存储方式。</td></tr><tr><td>NONE</td><td>不做任何的转换，直接以该数据所属的数据类型进行存储。</td></tr></tbody></table></figure>
<!-- /wp:table -->

<!-- wp:heading {"level":5} -->
<h5>SQLite 亲和类型(Affinity)及类型名称</h5>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>下表列出了当创建 SQLite3 表时可使用的各种数据类型名称，同时也显示了相应的亲和类型：</p>
<!-- /wp:paragraph -->

<!-- wp:image {"id":132,"sizeSlug":"large"} -->
<figure class="wp-block-image size-large"><img src="http://img.varsion.cn/blog-img/2020/07/image-20191223104340340-535x1024.png" alt="" class="wp-image-132"/></figure>
<!-- /wp:image -->

<!-- wp:heading {"level":5} -->
<h5>Boolean 数据类型</h5>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>SQLite 没有单独的 Boolean 存储类。相反，布尔值被存储为整数 0（false）和 1（true）。</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":5} -->
<h5>Date 与 Time 数据类型</h5>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>SQLite 没有一个单独的用于存储日期和/或时间的存储类，但 SQLite 能够把日期和时间存储为 TEXT、REAL 或 INTEGER 值。</p>
<!-- /wp:paragraph -->

<!-- wp:table -->
<figure class="wp-block-table"><table><thead><tr><th>存储类</th><th>日期格式</th></tr></thead><tbody><tr><td>TEXT</td><td>格式为 "YYYY-MM-DD HH:MM:SS.SSS" 的日期。</td></tr><tr><td>REAL</td><td>从公元前 4714 年 11 月 24 日格林尼治时间的正午开始算起的天数。</td></tr><tr><td>INTEGER</td><td>从 1970-01-01 00:00:00 UTC 算起的秒数。</td></tr></tbody></table></figure>
<!-- /wp:table -->

<!-- wp:paragraph -->
<p>您可以以任何上述格式来存储日期和时间，并且可以使用内置的日期和时间函数来自由转换不同格式。</p>
<!-- /wp:paragraph -->

<!-- wp:separator {"className":"is-style-wide"} -->
<hr class="wp-block-separator is-style-wide"/>
<!-- /wp:separator -->

<!-- wp:heading -->
<h2>创建数据库</h2>
<!-- /wp:heading -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">sqlite3 DatabaseName.db</pre>
<!-- /wp:preformatted -->

<!-- wp:image {"id":96,"sizeSlug":"large"} -->
<figure class="wp-block-image size-large"><img src="http://img.varsion.cn/blog-img/2020/07/image-20191223104932956.png" alt="" class="wp-image-96"/></figure>
<!-- /wp:image -->

<!-- wp:heading {"level":3} -->
<h3>.dump命令</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p> 转换整个 <code>testDB.db</code> 数据库的内容到 SQLite 的语句中，并将其转储到 ASCII 文本文件 <code>testDB.sql</code> 中。数据库名称和<code>.sql</code>文件名称可以不同,但是为了方便,应该保持相同 </p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">DatabaseName.db .dump &gt; DatabaseName.sql
//将该db文件输出为.sql文件 (在cmd命令中)</pre>
<!-- /wp:preformatted -->

<!-- wp:image {"align":"center","id":97,"sizeSlug":"large"} -->
<div class="wp-block-image"><figure class="aligncenter size-large"><img src="http://img.varsion.cn/blog-img/2020/07/image-20191223105612674.png" alt="" class="wp-image-97"/></figure></div>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p> 也可以通过该方式,从生成的<code>.sql</code>文件中恢复 </p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">$sqlite3 testDB.db < testDB.sql</pre>
<!-- /wp:preformatted -->

<!-- wp:separator {"className":"is-style-wide"} -->
<hr class="wp-block-separator is-style-wide"/>
<!-- /wp:separator -->

<!-- wp:heading -->
<h2>附加/分离数据库</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>假设这样一种情况，当在同一时间有多个数据库可用，您想使用其中的任何一个。SQLite 的 <code>ATTACH DATABASE</code> 语句是用来选择一个特定的数据库，使用该命令后，所有的 SQLite 语句将在附加的数据库下执行。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>SQLite 允许你用<code>attach</code>命令将多个数据库“附加”到当前连接上。当你附加了一个数据库时，它的所有内容在当前数据库文件的全局范围内都是可存取的。attach 的语法如下：</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>将一个数据库附加到当前数据库,并命名</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>将'DatabaseName'附加到当前数据库并用给他一个逻辑名'name'</p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted"># 规范
Attach Database 'fileName' as 'Name';
# 例子
Attach Database 'DatabaseName.db' as 'Name';</pre>
<!-- /wp:preformatted -->

<!-- wp:image {"id":98,"sizeSlug":"large"} -->
<figure class="wp-block-image size-large"><img src="http://img.varsion.cn/blog-img/2020/07/image-20191223113111570.png" alt="" class="wp-image-98"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p> 现在,<code>monitroDB</code>数据库里有表<code>control</code>有部分数据,可以以该方式在<code>testDB</code>里查询<code>monitorDB</code>中的数据: </p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted"> select * from monitor.control;</pre>
<!-- /wp:preformatted -->

<!-- wp:image {"align":"center","id":99,"sizeSlug":"large"} -->
<div class="wp-block-image"><figure class="aligncenter size-large"><img src="http://img.varsion.cn/blog-img/2020/07/image-20191223131602049.png" alt="" class="wp-image-99"/></figure></div>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>如果要查询主数据库中的表，需要指定逻辑名 main，因为当有数据库附加的时候，主数据库会自动赋名为 main</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>如果同一个数据库文件已经被附加上多个别名，<code>DETACH</code> 命令将只断开给定名称的连接，而其余的仍然有效。您无法分离 <strong>main</strong>或者<strong>temp</strong>数据库:</p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">Detach Database 'Alias-Name';</pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<p> 如果数据库是在内存中或者是临时数据库，则该数据库将被摧毁，且内容将会丢失。 </p>
<!-- /wp:paragraph -->

<!-- wp:image {"id":100,"sizeSlug":"large"} -->
<figure class="wp-block-image size-large"><img src="http://img.varsion.cn/blog-img/2020/07/image-20191223134149719.png" alt="" class="wp-image-100"/></figure>
<!-- /wp:image -->

<!-- wp:separator {"className":"is-style-wide"} -->
<hr class="wp-block-separator is-style-wide"/>
<!-- /wp:separator -->

<!-- wp:block {"ref":178} /-->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>133</wp:post_id>
		<wp:post_date><![CDATA[2020-07-25 11:28:00]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2020-07-25 03:28:00]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[sqlite%e5%9f%ba%e7%a1%80-day1]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="database"><![CDATA[Database]]></category>
		<category domain="post_tag" nicename="sql"><![CDATA[SQL]]></category>
		<category domain="post_tag" nicename="sqlite"><![CDATA[SQLite]]></category>
		<category domain="category" nicename="sqlite"><![CDATA[Sqlite]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[rank_math_primary_category]]></wp:meta_key>
		<wp:meta_value><![CDATA[16]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[rank_math_seo_score]]></wp:meta_key>
		<wp:meta_value><![CDATA[71]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[rank_math_focus_keyword]]></wp:meta_key>
		<wp:meta_value><![CDATA[SQLite,SQL,Database]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[rank_math_pillar_content]]></wp:meta_key>
		<wp:meta_value><![CDATA[on]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[rank_math_rich_snippet]]></wp:meta_key>
		<wp:meta_value><![CDATA[article]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[no_intro]]></wp:meta_key>
		<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_no_intro]]></wp:meta_key>
		<wp:meta_value><![CDATA[nanospace_no_intro]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[no_intro_media]]></wp:meta_key>
		<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_no_intro_media]]></wp:meta_key>
		<wp:meta_value><![CDATA[nanospace_no_intro_media]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[intro_image]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_intro_image]]></wp:meta_key>
		<wp:meta_value><![CDATA[nanospace_intro_image]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[show_intro_widgets]]></wp:meta_key>
		<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_show_intro_widgets]]></wp:meta_key>
		<wp:meta_value><![CDATA[nanospace_show_intro_widgets]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[content_layout]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_content_layout]]></wp:meta_key>
		<wp:meta_value><![CDATA[nanospace_content_layout]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[rank_math_internal_links_processed]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>SQLite基础—Day2</title>
		<link>https://blog.varsion.cn/?p=142</link>
		<pubDate>Sun, 26 Jul 2020 03:20:00 +0000</pubDate>
		<dc:creator><![CDATA[Varsion]]></dc:creator>
		<guid isPermaLink="false">http://blog.varsion.cn/?p=142</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:quote -->
<blockquote class="wp-block-quote"><p> SQLite 是一个软件库，实现了自给自足的、无服务器的、零配置的、事务性的 SQL 数据库引擎。SQLite 是在世界上最广泛部署的 SQL 数据库引擎。 </p><cite>本篇是该系列教程的第二篇，新来的朋友可以在我的博客搜索第一篇，从头开始看</cite></blockquote>
<!-- /wp:quote -->

<!-- wp:paragraph -->
<p>上篇介绍了Sqlite的基本知识，今天要写的部分是：表的操作、运算符以及表达式</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>数据表</h2>
<!-- /wp:heading -->

<!-- wp:heading {"level":3} -->
<h3>创建数据表</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>创建语句格式：</p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">Create Table table_name(
    column1 datatype primary key,
    column2 datatype not null,
    column3 datatype not null
);</pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<p>我们来创建如下的简单数据表：</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p> <code>CREATE TABLE</code> 是告诉数据库系统创建一个新表的关键字。<code>CREATE TABLE</code> 语句后跟着表的唯一的名称或标识。您也可以选择指定带有 <code>table_name</code> 的 <code>database_name</code>。 </p>
<!-- /wp:paragraph -->

<!-- wp:table -->
<figure class="wp-block-table"><table><thead><tr><th class="has-text-align-center" data-align="center">ID🔑</th><th class="has-text-align-center" data-align="center">Name</th><th class="has-text-align-center" data-align="center">Age</th></tr></thead><tbody><tr><td class="has-text-align-center" data-align="center">int</td><td class="has-text-align-center" data-align="center">text</td><td class="has-text-align-center" data-align="center">int</td></tr></tbody></table></figure>
<!-- /wp:table -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">Create Table info(
     id int primary key,
     name text not null,
     age int not null
 );</pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<p> 可以用<code>.tables</code>查看当前数据库的所有表 </p>
<!-- /wp:paragraph -->

<!-- wp:image {"align":"center","id":146,"sizeSlug":"large"} -->
<div class="wp-block-image"><figure class="aligncenter size-large"><img src="http://img.varsion.cn/blog-img/2020/07/image-20191223160439789-1.png" alt="" class="wp-image-146"/></figure></div>
<!-- /wp:image -->

<!-- wp:heading {"level":3} -->
<h3>Schema信息</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p> <code>.schema</code>可以查看某个表的完整信息: </p>
<!-- /wp:paragraph -->

<!-- wp:image {"align":"center","id":147,"sizeSlug":"large"} -->
<div class="wp-block-image"><figure class="aligncenter size-large"><img src="http://img.varsion.cn/blog-img/2020/07/image-20191223160611909-1.png" alt="" class="wp-image-147"/></figure></div>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p> 因为所有的<strong>点命令</strong>只在 SQLite 提示符中可用，所以当您进行带有 SQLite 的编程时，您要使用下面的带有 <strong><code>sqlite_master</code></strong> 表的 <code>SELECT</code> 语句来列出所有在数据库中创建的表： </p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">select tbl_name from sqlite_master where type = 'table';</pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<p> 假设在 testDB.db 中已经存在唯一的 info 表，则将产生以下结果： </p>
<!-- /wp:paragraph -->

<!-- wp:image {"align":"center","id":151,"sizeSlug":"large"} -->
<div class="wp-block-image"><figure class="aligncenter size-large"><img src="http://img.varsion.cn/blog-img/2020/07/image-20191223170607817-1.png" alt="" class="wp-image-151"/></figure></div>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>您可以列出关于表的完整信息，如下所示：</p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">select sql from sqlite_master where type = 'table' and tbl_name = 'info';</pre>
<!-- /wp:preformatted -->

<!-- wp:image {"align":"center","id":152,"sizeSlug":"large"} -->
<div class="wp-block-image"><figure class="aligncenter size-large"><img src="http://img.varsion.cn/blog-img/2020/07/image-20191223171249482-1.png" alt="image-20191223171249482" class="wp-image-152"/></figure></div>
<!-- /wp:image -->

<!-- wp:heading {"level":3} -->
<h3>删除表</h3>
<!-- /wp:heading -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">Drop table table_name;</pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<p>也可以</p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">Drop table databaseName.tableName;</pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<p>删除指定数据库的表</p>
<!-- /wp:paragraph -->

<!-- wp:image {"align":"center","id":153,"sizeSlug":"large"} -->
<div class="wp-block-image"><figure class="aligncenter size-large"><img src="http://img.varsion.cn/blog-img/2020/07/image-20191223162306749-1.png" alt="image-20191223162306749" class="wp-image-153"/></figure></div>
<!-- /wp:image -->

<!-- wp:paragraph {"align":"center"} -->
<p class="has-text-align-center"><strong>同时，无法删除关联数据库的表</strong></p>
<!-- /wp:paragraph -->

<!-- wp:separator {"className":"is-style-wide"} -->
<hr class="wp-block-separator is-style-wide"/>
<!-- /wp:separator -->

<!-- wp:heading -->
<h2>运算符</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p> 运算符是一个保留字或字符，主要用于 SQLite 语句的 WHERE 子句中执行操作，如比较和算术运算。 </p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>算数运算符</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p> sqlite一共有这些算数运算符 <code>＋,－,*,/,％</code></p>
<!-- /wp:paragraph -->

<!-- wp:image {"align":"center","id":156,"sizeSlug":"large"} -->
<div class="wp-block-image"><figure class="aligncenter size-large"><img src="http://img.varsion.cn/blog-img/2020/07/image-20191223181829939-1.png" alt="" class="wp-image-156"/></figure></div>
<!-- /wp:image -->

<!-- wp:heading {"level":3} -->
<h3> 比较运算符</h3>
<!-- /wp:heading -->

<!-- wp:table -->
<figure class="wp-block-table"><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>==</td><td>检查两个操作数的值是否相等，如果相等则条件为真。</td><td>(a == b) 不为真。</td></tr><tr><td>=</td><td>检查两个操作数的值是否相等，如果相等则条件为真。</td><td>(a = b) 不为真。</td></tr><tr><td>!=</td><td>检查两个操作数的值是否相等，如果不相等则条件为真。</td><td>(a != b) 为真。</td></tr><tr><td>&lt;&gt;</td><td>检查两个操作数的值是否相等，如果不相等则条件为真。</td><td>(a &lt;&gt; b) 为真。</td></tr><tr><td>&gt;</td><td>检查左操作数的值是否大于右操作数的值，如果是则条件为真。</td><td>(a &gt; b) 不为真。</td></tr><tr><td>&lt;</td><td>检查左操作数的值是否小于右操作数的值，如果是则条件为真。</td><td>(a &lt; b) 为真。</td></tr><tr><td>&gt;=</td><td>检查左操作数的值是否大于等于右操作数的值，如果是则条件为真。</td><td>(a &gt;= b) 不为真。</td></tr><tr><td>&lt;=</td><td>检查左操作数的值是否小于等于右操作数的值，如果是则条件为真。</td><td>(a &lt;= b) 为真。</td></tr><tr><td>!&lt;</td><td>检查左操作数的值是否不小于右操作数的值，如果是则条件为真。</td><td>(a !&lt; b) 为假。</td></tr><tr><td>!&gt;</td><td>检查左操作数的值是否不大于右操作数的值，如果是则条件为真。</td><td>(a !&gt; b) 为真。</td></tr></tbody></table></figure>
<!-- /wp:table -->

<!-- wp:paragraph -->
<p>假设当前表中有如下记录</p>
<!-- /wp:paragraph -->

<!-- wp:image {"align":"center","id":157,"sizeSlug":"large"} -->
<div class="wp-block-image"><figure class="aligncenter size-large"><img src="http://img.varsion.cn/blog-img/2020/07/13MFLZH75GSQLTIEJ.png" alt="" class="wp-image-157"/></figure></div>
<!-- /wp:image -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">select * from info where name = '充鸭';
//从info表中检索name 为 充鸭 的记录
 select * from info where name = '易哒';
//从info表中检索name 为  易哒 的记录 </pre>
<!-- /wp:preformatted -->

<!-- wp:image {"align":"center","id":162,"sizeSlug":"large"} -->
<div class="wp-block-image"><figure class="aligncenter size-large"><img src="http://img.varsion.cn/blog-img/2020/07/image-1.png" alt="" class="wp-image-162"/></figure></div>
<!-- /wp:image -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">select * from info where id &gt; 0;
//查询id大于0的</pre>
<!-- /wp:preformatted -->

<!-- wp:image {"align":"center","id":163,"sizeSlug":"large"} -->
<div class="wp-block-image"><figure class="aligncenter size-large"><img src="http://img.varsion.cn/blog-img/2020/07/image-2.png" alt="" class="wp-image-163"/></figure></div>
<!-- /wp:image -->

<!-- wp:separator {"className":"is-style-wide"} -->
<hr class="wp-block-separator is-style-wide"/>
<!-- /wp:separator -->

<!-- wp:heading -->
<h2>表达式</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p> 表达式是一个或多个值、运算符和计算值的SQL函数的组合。 </p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>布尔表达式</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>SQLite 的布尔表达式在匹配单个值的基础上获取数据。语法如下：</p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">select column1,column2<br>from tableName<br>where [condition];</pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<p>布尔表达式就是 <code>where</code>语句的判断条件，布尔表达式的值就是<code>ture , false</code></p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>数值表达式</h3>
<!-- /wp:heading -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">select numExpression 
as 
name 
[from tableName where condition]</pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<p>numExpression:是数学表达式 或 公式</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>name：作为name输出</p>
<!-- /wp:paragraph -->

<!-- wp:image {"align":"center","id":164,"sizeSlug":"large"} -->
<div class="wp-block-image"><figure class="aligncenter size-large"><img src="http://img.varsion.cn/blog-img/2020/07/image-3.png" alt="" class="wp-image-164"/></figure></div>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>常用内置函数：</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>avg()、sum()、count()，常用于数据计算</p>
<!-- /wp:paragraph -->

<!-- wp:image {"align":"center","id":165,"sizeSlug":"large"} -->
<div class="wp-block-image"><figure class="aligncenter size-large"><img src="http://img.varsion.cn/blog-img/2020/07/image-4.png" alt="" class="wp-image-165"/></figure></div>
<!-- /wp:image -->

<!-- wp:separator {"className":"is-style-wide"} -->
<hr class="wp-block-separator is-style-wide"/>
<!-- /wp:separator -->

<!-- wp:block {"ref":178} /-->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>142</wp:post_id>
		<wp:post_date><![CDATA[2020-07-26 11:20:00]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2020-07-26 03:20:00]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[sqlite%e5%9f%ba%e7%a1%80-day2]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="database"><![CDATA[Database]]></category>
		<category domain="post_tag" nicename="sql"><![CDATA[SQL]]></category>
		<category domain="post_tag" nicename="sqlite"><![CDATA[SQLite]]></category>
		<category domain="category" nicename="sqlite"><![CDATA[Sqlite]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[rank_math_primary_category]]></wp:meta_key>
		<wp:meta_value><![CDATA[16]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[rank_math_seo_score]]></wp:meta_key>
		<wp:meta_value><![CDATA[71]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[no_intro]]></wp:meta_key>
		<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_no_intro]]></wp:meta_key>
		<wp:meta_value><![CDATA[nanospace_no_intro]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[no_intro_media]]></wp:meta_key>
		<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_no_intro_media]]></wp:meta_key>
		<wp:meta_value><![CDATA[nanospace_no_intro_media]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[intro_image]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_intro_image]]></wp:meta_key>
		<wp:meta_value><![CDATA[nanospace_intro_image]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[show_intro_widgets]]></wp:meta_key>
		<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_show_intro_widgets]]></wp:meta_key>
		<wp:meta_value><![CDATA[nanospace_show_intro_widgets]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[content_layout]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_content_layout]]></wp:meta_key>
		<wp:meta_value><![CDATA[nanospace_content_layout]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[rank_math_internal_links_processed]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[rank_math_focus_keyword]]></wp:meta_key>
		<wp:meta_value><![CDATA[SQlite,Database,Mysql]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[rank_math_rich_snippet]]></wp:meta_key>
		<wp:meta_value><![CDATA[article]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>SQLite基础—Day3</title>
		<link>https://blog.varsion.cn/?p=172</link>
		<pubDate>Mon, 27 Jul 2020 02:30:08 +0000</pubDate>
		<dc:creator><![CDATA[Varsion]]></dc:creator>
		<guid isPermaLink="false">http://blog.varsion.cn/?p=172</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:quote -->
<blockquote class="wp-block-quote"><p> SQLite 是一个软件库，实现了自给自足的、无服务器的、零配置的、事务性的 SQL 数据库引擎。SQLite 是在世界上最广泛部署的 SQL 数据库引擎。 </p><cite> 本篇是该系列教程的第三篇也是最后一篇，新来的朋友可以在我的博客搜索第一篇，从头开始看 </cite></blockquote>
<!-- /wp:quote -->

<!-- wp:paragraph -->
<p> 上篇介绍了Sqlite的 表的操作、运算符以及表达式。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Sqlite的增、删、改、查的部分 都和MySQL完全相同。这边就不做赘述了。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>这边来为大家讲一下Sqlite的优缺点：</p>
<!-- /wp:paragraph -->

<!-- wp:separator -->
<hr class="wp-block-separator"/>
<!-- /wp:separator -->

<!-- wp:heading -->
<h2>SQLite的优缺点</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>SQLite是非凡的数据库，他可以进程在使用它的应用中。作为一个自包含、基于文件的数据库，SQLite提供了出色的工具集，可以处理所有类型的数据，没有什么限制，而且比起服务器运行的进程型服务器使用起来轻松许多。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>一个应用使用SQLite时，它的功能直接被集成在其中，应用会直接访问包含数据的文件(即SQLite数据库),而不是通过一些端口(port, socket)来交互。感谢这种底层技术，这使SQLite变得非常快速和高效，并且十分强大。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>SQLite支持的数据类型</p>
<!-- /wp:paragraph -->

<!-- wp:table -->
<figure class="wp-block-table"><table><tbody><tr><td>NULL</td><td class="has-text-align-center" data-align="center"> NULL值 </td></tr><tr><td> INTEGER</td><td class="has-text-align-center" data-align="center"> 有符号整数，按照设置用1、2、3、4、6或8字节存储 </td></tr><tr><td> REAL </td><td class="has-text-align-center" data-align="center"> 浮点数，使用8字节IEEE浮点数方式存储 </td></tr><tr><td> TEXT </td><td class="has-text-align-center" data-align="center"> 文本字符串，使用数据库编码存储(UTF-8, UTF-16BE 或 UTF-16LE) </td></tr><tr><td> BLOB </td><td class="has-text-align-center" data-align="center"> 二进制大对象，怎么输入就怎么存储 </td></tr></tbody></table></figure>
<!-- /wp:table -->

<!-- wp:heading {"level":3} -->
<h3>SQLite 的优点</h3>
<!-- /wp:heading -->

<!-- wp:paragraph {"align":"center"} -->
<p class="has-text-align-center"><strong>基于文件</strong></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>整个数据库都包含在磁盘上的一个文件中，因此它有很好的迁移性。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph {"align":"center"} -->
<p class="has-text-align-center"><strong>标准化</strong></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>尽管它看起来像个“简化版”的数据库，SQLite 确实支持 SQL。它略去了一些功能(RIGHT OUTER JOIN 和 FOR EACH STATEMENT)，但是，又同时增加了一些其他功能。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph {"align":"center"} -->
<p class="has-text-align-center"><strong>对于开发和测试</strong></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>在绝大多数应用的开发阶段中，大部分人都非常需要解决方案能有并发的灵活性。SQLite 含有丰富功能基础，所能提供的超乎开发所需，并且简洁到只需一个文件和一个 C 链接库。</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>SQLite的缺点</h3>
<!-- /wp:heading -->

<!-- wp:paragraph {"align":"center"} -->
<p class="has-text-align-center"><strong>没有用户管理</strong></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>高级数据库都能支持用户系统，例如，能管理数据库连接对数据库和表的访问权限。但由于 SQLite 产生的目的和本身性质(没有多用户并发的高层设计)，它没有这个功能。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph {"align":"center"} -->
<p class="has-text-align-center"><strong>缺乏额外优化性能的灵活性</strong></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>仍然是从设计之初，SQLite 就不支持使用各种技巧来进行额外的性能优化。这个库容易配置，容易使用。既然它并不复杂，理论上就无法让它比现在更快，其实现在它已经很快了。</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>何时使用 SQLite ?</h3>
<!-- /wp:heading -->

<!-- wp:paragraph {"align":"center"} -->
<p class="has-text-align-center"><strong>嵌入式应用</strong></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>所有需要迁移性，不需要扩展的应用，例如，单用户的本地应用，移动应用和游戏。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph {"align":"center"} -->
<p class="has-text-align-center"><strong>代替磁盘访问</strong></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>在很多情况下，需要频繁直接读/写磁盘文件的应用，都很适合转为使用 SQLite ，可以得益于 SQLite 使用 SQL 带来的功能性和简洁性。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph {"align":"center"} -->
<p class="has-text-align-center"><strong>测试</strong></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>它能秒杀大部分专门针对应用业务逻辑(也就是应用的主要目的：能完成功能)的测试。</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>何时不用 SQLite ?</h3>
<!-- /wp:heading -->

<!-- wp:paragraph {"align":"center"} -->
<p class="has-text-align-center"><strong>多用户应用</strong></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>如果你在开发的应用需要被多用户访问，而且这些用户都用同一个数据库，那么相比 SQLite 最好还是选择一个功能完整的关系型数据库(例如 MySQL)。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph {"align":"center"} -->
<p class="has-text-align-center"><strong>需要大面积写入数据的应用</strong></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>SQLite 的缺陷之一是它的写入操作。这个数据库同一时间只允许一个写操作，因此吞吐量有限。</p>
<!-- /wp:paragraph -->

<!-- wp:separator {"className":"is-style-wide"} -->
<hr class="wp-block-separator is-style-wide"/>
<!-- /wp:separator -->

<!-- wp:block {"ref":178} /-->]]></content:encoded>
		<excerpt:encoded><![CDATA[这次来为大家讲一下Sqlite的优缺点，何时应该使用SQlite何时不使用Sqlite。]]></excerpt:encoded>
		<wp:post_id>172</wp:post_id>
		<wp:post_date><![CDATA[2020-07-27 10:30:08]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2020-07-27 02:30:08]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[sqlite]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="database"><![CDATA[Database]]></category>
		<category domain="post_tag" nicename="sql"><![CDATA[SQL]]></category>
		<category domain="post_tag" nicename="sqlite"><![CDATA[SQLite]]></category>
		<category domain="category" nicename="sqlite"><![CDATA[Sqlite]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[rank_math_seo_score]]></wp:meta_key>
		<wp:meta_value><![CDATA[65]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[no_intro]]></wp:meta_key>
		<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_no_intro]]></wp:meta_key>
		<wp:meta_value><![CDATA[nanospace_no_intro]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[no_intro_media]]></wp:meta_key>
		<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_no_intro_media]]></wp:meta_key>
		<wp:meta_value><![CDATA[nanospace_no_intro_media]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[intro_image]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_intro_image]]></wp:meta_key>
		<wp:meta_value><![CDATA[nanospace_intro_image]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[show_intro_widgets]]></wp:meta_key>
		<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_show_intro_widgets]]></wp:meta_key>
		<wp:meta_value><![CDATA[nanospace_show_intro_widgets]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[content_layout]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_content_layout]]></wp:meta_key>
		<wp:meta_value><![CDATA[nanospace_content_layout]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[rank_math_internal_links_processed]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[rank_math_focus_keyword]]></wp:meta_key>
		<wp:meta_value><![CDATA[sqlite,Database]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[rank_math_description]]></wp:meta_key>
		<wp:meta_value><![CDATA[这次来为大家讲一下Sqlite的优缺点，何时应该使用SQlite何时不使用Sqlite。
一个应用使用SQLite时，它的功能直接被集成在其中，应用会直接访问包含数据的文件(即SQLite数据库),而不是通过一些端口(port, socket)来交互。感谢这种底层技术，这使SQLite变得非常快速和高效，并且十分强大。]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[rank_math_primary_category]]></wp:meta_key>
		<wp:meta_value><![CDATA[16]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>复杂度分析</title>
		<link>https://blog.varsion.cn/?p=186</link>
		<pubDate>Tue, 28 Jul 2020 03:23:12 +0000</pubDate>
		<dc:creator><![CDATA[Varsion]]></dc:creator>
		<guid isPermaLink="false">http://blog.varsion.cn/?p=186</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:block {"ref":187} /-->

<!-- wp:heading {"align":"center","level":3} -->
<h3 class="has-text-align-center">大O复杂度表示法</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>所有代码的执行时间 T(n) 与每行代码的执行次数</p>
<!-- /wp:paragraph -->

<!-- wp:codemirror-blocks/code-block {"mode":"ruby","mime":"text/x-ruby"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre>def cal (n)
  sum = 0
  for i in 1..nu
    sum += i
  end
  return sum
end</pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:paragraph -->
<p>粗略估计该方法的时间复杂度：</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>将每行代码的执行时间都设为 <code>1u</code> ，第2行代码需要 <code>1u</code> ，第3，4代码（for循环）运行了N次，这段代码的总执行时间就是<code>(2n+1)*u</code>。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>我们可以得出，<strong>所有代码的执行时间<code>T(n)</code>与每行代码的执行次数成正比</strong>。</p>
<!-- /wp:paragraph -->

<!-- wp:codemirror-blocks/code-block {"mode":"ruby","mime":"text/x-ruby"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre>def cal(n)
  sum = 0
for i in 0..n
  	j = 1
    for j in 0..n
        sum = sum + i*j
    end
end
    return sum
end</pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:paragraph -->
<p>再看一下该函数</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>同样假设每行代码的执行时间都为 <code>1u</code> ,第2行需要<code>1u</code> ，第3，4行执行N次也就是 <code>2n*u</code>,第5，6行执行了 <code>N²</code>次，所以整段代码执行的总时间为：<code>(2n²+2n+1)*u</code></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>通过这两段代码可以推出一个重要结论：</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><strong>所有代码的执行时间 T(n) 与每行代码的执行次数 n 成正比</strong></p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true">T(n) = O(f(n))</div>
<!-- /wp:katex/display-block -->

<!-- wp:list -->
<ul><li><code>T(n)</code>表示代码执行的时间；</li><li><code>n</code> 表示数据规模的大小；</li><li><code>f(n)</code> 表示每行代码执行的次数总和。</li><li>因为这是一个公式，所以用 <code>f(n)</code> 来表示。公式中的 <code>O</code>，表示代码的执行时间 <code>T(n) </code>与 <code>f(n)</code> 表达式成正比。</li></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是表示<strong>代码执行时间随数据规模增长的变化趋势</strong>，所以，也叫作渐进时间复杂度（asymptotic time complexity），简称<strong>时间复杂度</strong>。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>当N的数量级很大的时候，公式中的常数、系数和低阶表达式都是可以忽略的，只需要考虑最大量级即可，随意刚刚的两个表达式也可以写为<code>T(n) = O(n), T(n) = O(n²)</code>。</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"align":"center","level":3} -->
<h3 class="has-text-align-center">时间复杂度分析</h3>
<!-- /wp:heading -->

<!-- wp:heading {"level":4} -->
<h4>只关注循环执行次数最多的一段代码</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>我们通常会忽略掉公式中的常量、低阶、系数，只需要记录一个最大阶的量级就可以了。所以，我们<strong>在分析一个算法、一段代码的时间复杂度的时候，也只关注循环执行次数最多的那一段代码就可以了</strong>。这段核心代码执行次数的 n 的量级，就是整段要分析代码的时间复杂度。</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4>加法法则：总复杂度等于量级最大的那段代码的复杂度</h4>
<!-- /wp:heading -->

<!-- wp:codemirror-blocks/code-block {"mode":"ruby","mime":"text/x-ruby"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre>def cal(int n) 
   # yield 1
   sum_1 = 0
   p = 1
   for p in 0..100
     sum_1 = sum_1 + p
   end
  
 # yield 2
   sum_2 = 0
    q = 1
   for q in 0..n
     sum_2 = sum_2 + q
   end
  
 # yield 3
   sum_3 = 0
   i = 1
   j = 1
   for i in i..n
     j = 1;
     for j in j..n
        sum_3 = sum_3 +  i * j
       end
     end
 
   return sum_1 + sum_2 + sum_3;
  end</pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:paragraph -->
<p>该函数分为三部分，分别是求sum_1、sum_2、sum_3，分析每一部分的复杂度再去最大的量级作为整个函数的复杂度。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>在上面提到过，当N达到无限大的时候，一段代码的复杂度，是按照最大量级来取的，就是说只需要关注这个段代码中最复杂的部分，也就是 <code>yield 3</code></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><code>yield 3</code>的复杂度为<code>O(n²)</code></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>所以得出结论</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph {"align":"center","fontSize":"normal"} -->
<p class="has-text-align-center has-normal-font-size"><strong>总的时间复杂度就等于量级最大的那段代码的时间复杂度</strong></p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4>乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>简单来讲乘法法则就是<strong>嵌套循环</strong>，拿之前的一个例子来讲：</p>
<!-- /wp:paragraph -->

<!-- wp:codemirror-blocks/code-block {"mode":"ruby","mime":"text/x-ruby"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre>def cal(n)
  sum = 0
  
for i in 0..n
  	j = 1
    for j in 0..n
        sum = sum + i*j
    end
end
  
    return sum
end</pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:paragraph -->
<p>外层循环的复杂度是 n，内层循环的复杂度也是n，所以该函数的复杂度为 <code>n*n</code>即<code>n²</code>。</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4>几种常见时间复杂度的实例分析</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>常见的复杂度量级如下,按数量级递增：</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul><li><span class="has-inline-color has-vivid-cyan-blue-color">常数级 <code>O(1)</code></span></li><li><span class="has-inline-color has-vivid-cyan-blue-color">对数级<code>O(logn)</code></span></li><li><span class="has-inline-color has-vivid-cyan-blue-color">线性级<code>O(n)</code></span></li><li><span class="has-inline-color has-vivid-cyan-blue-color">线性对数级<code>O(nlogn)</code></span></li><li><span class="has-inline-color has-vivid-cyan-blue-color">平方级<code>O(n²)</code> 立方级 <code>O(n³)</code>...</span></li><li><span class="has-inline-color has-vivid-cyan-blue-color">指数级<code>O(2∧n)</code></span></li><li><span class="has-inline-color has-vivid-cyan-blue-color">阶乘级<code>O(n!)</code></span></li></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>对于刚罗列的复杂度量级，我们可以粗略地分为两类，多项式量级和非多项式量级。其中，非多项式量级只有两个：<code>O(2n)</code> 和 <code>O(n!)</code>。</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4><code>O(1)</code></h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>O(1) 只是常量级时间复杂度的一种表示方法，并不是指只执行了一行代码。比如这段代码，即便有 3 行，它的时间复杂度也是 O(1），而不是 O(3)</p>
<!-- /wp:paragraph -->

<!-- wp:codemirror-blocks/code-block {"mode":"ruby","mime":"text/x-ruby"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre>i = 1
j = 2
sum = i + j</pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:paragraph -->
<p>只要代码的执行时间不随 n 的增大而增长，这样代码的时间复杂度我们都记作 O(1)。或者说，一般情况下，<span class="has-inline-color has-vivid-red-color">只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)</span>。</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4><code>O(logn)、O(nlogn)</code></h4>
<!-- /wp:heading -->

<!-- wp:codemirror-blocks/code-block {"mode":"ruby","mime":"text/x-ruby"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre>i = 1
while i &lt; n do
  i = i*2
end</pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:paragraph -->
<p>第三行代码是执行最多次的，我们只需要计算该代码执行了多少次，就可以看出整段代码的复杂度：</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true">2^k = n</div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>所以我们只需要知道k的值 就可以知道整块代码的复杂度：</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true">k = log₂n</div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>即复杂度为<code>O(log₂n)</code></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>同样的在采用大 O 标记复杂度的时候，可以忽略系数，即 O(Cf(n)) = O(f(n))</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p> 当N趋于无限大时，对数的大小可以忽略底数，在对数阶时间复杂度的表示方法里，我们忽略对数的“底”，统一表示为 O(logn)。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>如果一段代码的时间复杂度是 O(logn)，我们循环执行 n 遍，时间复杂度就是 O(nlogn) 了。而且，O(nlogn) 也是一种非常常见的算法时间复杂度。比如，归并排序、快速排序的时间复杂度都是 O(nlogn)。</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4><code>O(m+n)、O(m*n)</code></h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>代码的复杂度由两个数据的规模来决定</p>
<!-- /wp:paragraph -->

<!-- wp:codemirror-blocks/code-block {"mode":"ruby","mime":"text/x-ruby"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre>   sum_1 = 0
   p = 1
   for p in 0..100
     sum_1 = sum_1 + p
   end

   sum_2 = 0
   q = 1
   for q in 0..m
     sum_2 = sum_2 + q
   end</pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:paragraph -->
<p>m 和 n 是表示两个数据规模。我们无法事先评估 m 和 n 谁的量级大，所以我们在表示复杂度的时候，就不能简单地利用加法法则，省略掉其中一个。所以，上面代码的时间复杂度就是 O(m+n)</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"align":"center","level":3} -->
<h3 class="has-text-align-center">空间复杂度分析</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>时间复杂度的全称是<strong>渐进时间复杂度</strong>，表示算法的执行时间与数据规模之间的增长关系。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>类比一下，</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>空间复杂度全称就是<strong>渐进空间复杂度</strong>（asymptotic space complexity），表示算法的<strong>存储空间与数据规模之间的增长关系</strong>。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>常见的空间复杂度就是 O(1)、O(n)、O(n2 )，即程序运行和数据空间之间的关系</p>
<!-- /wp:paragraph -->

<!-- wp:codemirror-blocks/code-block {"mode":"ruby","mime":"text/x-ruby"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre>info = Array.new(n)</pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:paragraph -->
<p>该代码的空间复杂度就是<code>n</code></p>
<!-- /wp:paragraph -->

<!-- wp:separator {"className":"is-style-wide"} -->
<hr class="wp-block-separator is-style-wide"/>
<!-- /wp:separator -->

<!-- wp:block {"ref":178} /-->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>186</wp:post_id>
		<wp:post_date><![CDATA[2020-07-28 11:23:12]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2020-07-28 03:23:12]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%8e%e7%ae%97%e6%b3%95-%e5%a4%8d%e6%9d%82%e5%ba%a6%e5%88%86%e6%9e%90]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="ruby"><![CDATA[Ruby]]></category>
		<category domain="post_tag" nicename="%e5%a4%8d%e6%9d%82%e5%ba%a6%e5%88%86%e6%9e%90"><![CDATA[复杂度分析]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
		<category domain="category" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%8e%e7%ae%97%e6%b3%95"><![CDATA[数据结构与算法]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[rank_math_seo_score]]></wp:meta_key>
		<wp:meta_value><![CDATA[12]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[rank_math_primary_category]]></wp:meta_key>
		<wp:meta_value><![CDATA[18]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[no_intro]]></wp:meta_key>
		<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_no_intro]]></wp:meta_key>
		<wp:meta_value><![CDATA[nanospace_no_intro]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[no_intro_media]]></wp:meta_key>
		<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_no_intro_media]]></wp:meta_key>
		<wp:meta_value><![CDATA[nanospace_no_intro_media]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[intro_image]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_intro_image]]></wp:meta_key>
		<wp:meta_value><![CDATA[nanospace_intro_image]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[show_intro_widgets]]></wp:meta_key>
		<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_show_intro_widgets]]></wp:meta_key>
		<wp:meta_value><![CDATA[nanospace_show_intro_widgets]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[content_layout]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_content_layout]]></wp:meta_key>
		<wp:meta_value><![CDATA[nanospace_content_layout]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[rank_math_internal_links_processed]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[rank_math_focus_keyword]]></wp:meta_key>
		<wp:meta_value><![CDATA[数据结构,算法,复杂度分析,Ruby]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[rank_math_pillar_content]]></wp:meta_key>
		<wp:meta_value><![CDATA[off]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[rank_math_description]]></wp:meta_key>
		<wp:meta_value><![CDATA[

同样假设每行代码的执行时间都为 
1u
 ,第2行需要
1u
 ，第3，4行执行N次也就是 
2n*u
,第5，6行执行了 
N²
次，所以整段代码执行的总时间为：
(2n²+2n+1)*u
通过这两段代码可以推出一个重要结论：
所有代码的执行时间 T(n) 与每行代码的执行次数 n 成正比


]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>最好、最坏、平均、均摊时间复杂度</title>
		<link>https://blog.varsion.cn/?p=219</link>
		<pubDate>Wed, 29 Jul 2020 04:02:37 +0000</pubDate>
		<dc:creator><![CDATA[Varsion]]></dc:creator>
		<guid isPermaLink="false">https://blog.varsion.cn/?p=219</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:block {"ref":187} /-->

<!-- wp:list -->
<ul><li>最好情况时间复杂度（best case time complexity）</li><li>最坏情况时间复杂度（worst case time complexity）</li><li>平均情况时间复杂度（average case time complexity）</li><li>均摊时间复杂度（amortized time complexity）</li></ul>
<!-- /wp:list -->

<!-- wp:heading {"level":3} -->
<h3>最好、最坏情况时间复杂度</h3>
<!-- /wp:heading -->

<!-- wp:codemirror-blocks/code-block {"mode":"ruby","mime":"text/x-ruby"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre>def find (Ar,x)
    len = Ar.length
    i = 0
    pos = -1
    for i in 0..len
        if Ar.at[i] == x
            pos = i
            break
        end
    end
    return pos
end</pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:paragraph -->
<p>该段代码的功能是，在一个无序数组<code>Ar</code>中查找变量<code>x</code>出现的位置，如果没有找到就返回<code>-1</code>，<code>len</code>表示该数组的长度，根据复杂度分析来看，该段代码的复杂度为<code>O(len)</code></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>但是我们在数组中查找数据，并不需要每次都把该数组遍历一遍，因为可能中途找到该元素而提前结束循环。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>因为要查找的元素可能在数组任意位置，如果数组第一个元素就是要查找的x，那就不需要再遍历之后的<code>len-1</code>个元素了，这时的复杂度是<code>O(1)</code>。但如果数组中不存在该元素，或者该元素在最后一个位置，那么此时的复杂度即为<code>O(len)</code>。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>所以，代码在不用情况下的不同时间复杂度，这里引入了三个概念：<strong>最好情况时间复杂度、最坏情况时间复杂度、平均情况时间复杂度。</strong></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>顾名思义，最好情况时间复杂度就是，在最理想的情况下，执行这段代码的时间复杂度。<strong>在最理想的情况下，对应的时间复杂度就是最好情况时间复杂度。</strong></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>同理，最坏情况时间复杂度就是，在最糟糕的情况下，执行这段代码的时间复杂度。就像刚举的那个例子，如果数组中没有要查找的变量 x，我们需要把整个数组都遍历一遍才行，<strong>所以这种最糟糕情况下对应的时间复杂度就是最坏情况时间复杂度。</strong></p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>平均情况时间复杂度</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>这里仍然使用刚刚的例子：</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>要查找的变量 x 在数组中的位置，有 <code>len+1</code> 种情况：在数组的 <code>0~len-1</code> 位置中和不在数组中。我们把每种情况下，查找需要遍历的元素个数累加起来，然后再除以<code> n+1</code>，就可以得到需要遍历的元素个数的平均值：</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true">(1+2+3+4+...+len+len)/len+1 = len(len+3)/2(len+1)</div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>同样使用大O标记法，省略掉系数、低阶变量、常量简化之后，复杂度为<code>O(n)</code></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>这个结论虽然是正确的，但是计算过程稍微有点儿问题。我们刚讲的这 n+1 种情况，应该考虑到概率问题。应该根据概率乘法法则来重新计算：</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>计算结果根据大O标记法简化之后，复杂度仍为<code>O(n)</code>。</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>均摊时间复杂度</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>均摊时间复杂度，听起来跟平均时间复杂度有点儿像。对于初学者来说，这两个概念确实非常容易弄混。大部分情况下，并不需要区分最好、最坏、平均三种复杂度。平均复杂度只在某些特殊情况下才会用到，而均摊时间复杂度应用的场景比它更加特殊、更加有限。</p>
<!-- /wp:paragraph -->

<!-- wp:codemirror-blocks/code-block {"mode":"ruby","mime":"text/x-ruby"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre>Ar = Array.new(n)
count = 0

def insert(val)
    if count == Ar.length
        sum = 0
        for i in 0...Ar.length
            sum = sum + Ar.at(i)
        end
      	Ar.clear
        Ar[0] = sum
        count = 1
    end
    Ar[count] = val
    ++count
end</pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:paragraph -->
<p>这段代码实现了一个往数组中插入数据的功能。当数组满了之后，也就是代码中的 <code>count == Ar.length</code> 时，我们用 for 循环遍历数组求和，并清空数组，将求和之后的 sum 值放到数组的第一个位置，然后再将新的数据插入。但如果数组一开始就有空闲空间，则直接将数据插入数组。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>最理想的情况下，数组中有空闲空间，只需要将数据插入到数组下标为 count 的位置就可以了，所以最好情况时间复杂度为 O(1)。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>最坏的情况下，数组中没有空闲空间了，需要先做一次数组的遍历求和，然后再将数据插入，所以最坏情况时间复杂度为 O(n)。那平均时间复杂度是多少呢？答案是 O(1)。我们还是可以通过前面讲的概率论的方法来分析。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>假设数组的长度是 n，根据数据插入的位置的不同，我们可以分为 n 种情况，每种情况的时间复杂度是 <code>O(1)</code>。除此之外，还有一种“额外”的情况，就是在数组没有空闲空间时插入一个数据，这个时候的时间复杂度是 <code>O(n)</code>。而且，这 <code>n+1</code> 种情况发生的概率一样，都是 <code>1/(n+1)</code>。所以，根据加权平均的计算方法，求得的平均时间复杂度就是:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true">1*1/(1+n)+...+n*1/(n+1) = O(1)</div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>来对比一下这个 insert() 的例子和前面那个 find() 的例子，这两者有很大差别。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>首先，find() 函数在极端情况下，复杂度才为 O(1)。但 insert() 在大部分情况下，时间复杂度都为 O(1)。只有个别情况下，复杂度才比较高，为 O(n)。这是 insert()第一个区别于 find() 的地方。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>再来看第二个不同的地方。对于 insert() 函数来说，O(1) 时间复杂度的插入和 O(n) 时间复杂度的插入，出现的频率是非常有规律的，而且有一定的前后时序关系，一般都是一个 O(n) 插入之后，紧跟着 n-1 个 O(1) 的插入操作，循环往复。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>所以，针对这样一种特殊场景的复杂度分析，并不需要像之前讲平均复杂度分析方法那样，找出所有的输入情况及相应的发生概率，然后再计算加权平均值。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>针对这种特殊的场景，引入了一种更加简单的分析方法：<strong>摊还分析法</strong>，通过摊还分析得到的时间复杂度我们起了一个名字，叫<strong>均摊时间复杂度</strong>。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>对一个数据结构进行一组连续操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高，而且这些操作之间存在前后连贯的时序关系，这个时候，我们就可以将这一组操作放在一块儿分析，看是否能将较高时间复杂度那次操作的耗时，平摊到其他那些时间复杂度比较低的操作上。而且，在能够应用均摊时间复杂度分析的场合，一般均摊时间复杂度就等于最好情况时间复杂度。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph {"align":"center"} -->
<p class="has-text-align-center"><strong>均摊时间复杂度就是一种特殊的平均时间复杂度</strong></p>
<!-- /wp:paragraph -->

<!-- wp:separator {"className":"is-style-wide"} -->
<hr class="wp-block-separator is-style-wide"/>
<!-- /wp:separator -->

<!-- wp:block {"ref":178} /-->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>219</wp:post_id>
		<wp:post_date><![CDATA[2020-07-29 12:02:37]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2020-07-29 04:02:37]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%8e%e7%ae%97%e6%b3%95-%e6%9c%80%e5%a5%bd%e3%80%81%e6%9c%80%e5%9d%8f%e3%80%81%e5%b9%b3%e5%9d%87%e3%80%81%e5%9d%87%e6%91%8a%e6%97%b6%e9%97%b4%e5%a4%8d]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="ruby"><![CDATA[Ruby]]></category>
		<category domain="post_tag" nicename="%e5%a4%8d%e6%9d%82%e5%ba%a6%e5%88%86%e6%9e%90"><![CDATA[复杂度分析]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
		<category domain="category" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%8e%e7%ae%97%e6%b3%95"><![CDATA[数据结构与算法]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[rank_math_seo_score]]></wp:meta_key>
		<wp:meta_value><![CDATA[58]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[no_intro]]></wp:meta_key>
		<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_no_intro]]></wp:meta_key>
		<wp:meta_value><![CDATA[nanospace_no_intro]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[no_intro_media]]></wp:meta_key>
		<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_no_intro_media]]></wp:meta_key>
		<wp:meta_value><![CDATA[nanospace_no_intro_media]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[intro_image]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_intro_image]]></wp:meta_key>
		<wp:meta_value><![CDATA[nanospace_intro_image]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[show_intro_widgets]]></wp:meta_key>
		<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_show_intro_widgets]]></wp:meta_key>
		<wp:meta_value><![CDATA[nanospace_show_intro_widgets]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[content_layout]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_content_layout]]></wp:meta_key>
		<wp:meta_value><![CDATA[nanospace_content_layout]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[rank_math_internal_links_processed]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[rank_math_primary_category]]></wp:meta_key>
		<wp:meta_value><![CDATA[18]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[rank_math_focus_keyword]]></wp:meta_key>
		<wp:meta_value><![CDATA[数据结构,算法,复杂度分析]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[rank_math_description]]></wp:meta_key>
		<wp:meta_value><![CDATA[最好情况时间复杂度（best case time complexity）
最坏情况时间复杂度（worst case time complexity）
平均情况时间复杂度（average case time complexity）
均摊时间复杂度（amortized time complexity）]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>数组问题</title>
		<link>https://blog.varsion.cn/?p=237</link>
		<pubDate>Thu, 30 Jul 2020 13:58:14 +0000</pubDate>
		<dc:creator><![CDATA[Varsion]]></dc:creator>
		<guid isPermaLink="false">https://blog.varsion.cn/?p=237</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:block {"ref":187} /-->

<!-- wp:heading {"level":3} -->
<h3>随机访问</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p><strong>数组</strong>（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph {"fontSize":"medium"} -->
<p class="has-medium-font-size"><strong>线性表：</strong></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>线性表就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>除了数组，链表、队列、栈等也是线性表结构。</p>
<!-- /wp:paragraph -->

<!-- wp:image {"align":"center","id":246,"width":614,"height":346,"sizeSlug":"large"} -->
<div class="wp-block-image"><figure class="aligncenter size-large is-resized"><img src="http://img.varsion.cn/blog-img/2020/07/image-5.png" alt="" class="wp-image-246" width="614" height="346"/></figure></div>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>和线性表相反的改建是非线性表：二叉树、堆、图等。之所以叫非线性，是因为，在非线性表中，数据之间并不是简单的前后关系。</p>
<!-- /wp:paragraph -->

<!-- wp:image {"align":"center","id":247,"sizeSlug":"large"} -->
<div class="wp-block-image"><figure class="aligncenter size-large"><img src="http://img.varsion.cn/blog-img/2020/07/image-6.png" alt="" class="wp-image-247"/></figure></div>
<!-- /wp:image -->

<!-- wp:paragraph {"fontSize":"medium"} -->
<p class="has-medium-font-size"><strong>连续的内存空间和相同类型的数据：</strong></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>正因为'线性表’和'连续的内存空间和相同类型的数据',使得数组具有了<strong>随机访问</strong>的特性。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>这两个限制也让数组的很多操作变得非常低效，比如要想在数组中删除、插入一个数据，为了保证连续性，就需要做大量的数据搬移工作。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>“链表适合插入、删除，时间复杂度 <code>O(1)</code>；数组适合查找，查找时间复杂度为 <code>O(1)</code>”。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>实际上，这种表述是不准确的。数组是适合查找操作，但是查找的时间复杂度并不为 ·、<code>O(1)</code>。即便是排好序的数组，你用二分查找，时间复杂度也是 <code>O(logn)</code>。所以，正确的表述应该是，数组支持随机访问，根据下标随机访问的时间复杂度为 <code>O(1)</code>。</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>低效的'插入'、'删除'</h3>
<!-- /wp:heading -->

<!-- wp:paragraph {"fontSize":"medium"} -->
<p class="has-medium-font-size"><strong> 插入操作</strong>：</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>假设数组的长度为 n，现在，如果需要将一个数据插入到数组中的第 k 个位置。为了把第 k 个位置腾出来，给新来的数据，我们需要将第 k～n 这部分的元素都顺序地往后挪一位。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>果在数组的末尾插入元素，那就不需要移动数据了，这时的时间复杂度为 O(1)。但如果在数组的开头插入元素，那所有的数据都需要依次往后移动一位，所以最坏时间复杂度是 O(n)。 因为我们在每个位置插入元素的概率是一样的，所以平均情况时间复杂度为 (1+2+…n)/n=O(n)。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>如果数组中的数据是有序的，在某个位置插入一个新的元素时，就搬移 k 之后的数据。但是，如果数组中存储的数据并没有任何规律，数组只是被当作一个<strong>存储数据的无序集合</strong>。在这种情况下，如果要将某个数据插入到第 k 个位置，为了<strong>避免大规模的数据搬移</strong>，还有一个简单的办法就是，直接将第 k 位的数据搬移到数组元素的最后，把新的元素直接放入第 k 个位置。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph {"fontSize":"medium"} -->
<p class="has-medium-font-size"><strong>删除操作</strong>：</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>如果要删除第 k 个位置的数据，为了内存的连续性，也需要搬移数据，不然中间就会出现空洞，内存就不连续了。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>和插入类似，如果删除数组末尾的数据，则最好情况时间复杂度为 O(1)；如果删除开头的数据，则最坏情况时间复杂度为 O(n)；平均情况时间复杂度也为 O(n)。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>实际上，在某些特殊场景下，并不一定非得追求数组中数据的连续性。如果将多次删除操作集中在一起执行，删除效率会提高的很多</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>可以先记录下已经删除的数据。每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除。当数组没有更多空间存储数据时，我们再触发执行一次真正的删除操作，这样就大大减少了删除操作导致的数据搬移。</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>警惕数组越界</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>简而言之，数组越界会给项目带来莫名其妙的逻辑错误，很难去调试，debug难度是很大的。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>当然，并非所有语言都像C一样，把数组越界检查的工作丢给程序员来做。</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>容器</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>对于业务开发，直接使用容器就足够了，省时省力。毕竟损耗一丢丢性能，完全不会影响到系统整体的性能。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>但如果做一些非常底层的开发，比如开发网络框架，性能的优化需要做到极致，这个时候数组就会优于容器，成为首选</p>
<!-- /wp:paragraph -->

<!-- wp:separator {"className":"is-style-wide"} -->
<hr class="wp-block-separator is-style-wide"/>
<!-- /wp:separator -->

<!-- wp:block {"ref":178} /-->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>237</wp:post_id>
		<wp:post_date><![CDATA[2020-07-30 21:58:14]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2020-07-30 13:58:14]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%8e%e7%ae%97%e6%b3%95-%e6%95%b0%e7%bb%84%e9%97%ae%e9%a2%98]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="array"><![CDATA[Array]]></category>
		<category domain="post_tag" nicename="ruby"><![CDATA[Ruby]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
		<category domain="category" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%8e%e7%ae%97%e6%b3%95"><![CDATA[数据结构与算法]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e7%bb%84"><![CDATA[数组]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[rank_math_primary_category]]></wp:meta_key>
		<wp:meta_value><![CDATA[18]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[no_intro]]></wp:meta_key>
		<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_no_intro]]></wp:meta_key>
		<wp:meta_value><![CDATA[nanospace_no_intro]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[no_intro_media]]></wp:meta_key>
		<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_no_intro_media]]></wp:meta_key>
		<wp:meta_value><![CDATA[nanospace_no_intro_media]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[intro_image]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_intro_image]]></wp:meta_key>
		<wp:meta_value><![CDATA[nanospace_intro_image]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[show_intro_widgets]]></wp:meta_key>
		<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_show_intro_widgets]]></wp:meta_key>
		<wp:meta_value><![CDATA[nanospace_show_intro_widgets]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[content_layout]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_content_layout]]></wp:meta_key>
		<wp:meta_value><![CDATA[nanospace_content_layout]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[rank_math_internal_links_processed]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[rank_math_seo_score]]></wp:meta_key>
		<wp:meta_value><![CDATA[66]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[rank_math_focus_keyword]]></wp:meta_key>
		<wp:meta_value><![CDATA[数组,数据结构,算法,Array]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[rank_math_description]]></wp:meta_key>
		<wp:meta_value><![CDATA[数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>链表</title>
		<link>https://blog.varsion.cn/?p=262</link>
		<pubDate>Fri, 31 Jul 2020 09:13:21 +0000</pubDate>
		<dc:creator><![CDATA[Varsion]]></dc:creator>
		<guid isPermaLink="false">https://blog.varsion.cn/?p=262</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:block {"ref":187} /-->

<!-- wp:heading {"level":3} -->
<h3>链表结构</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>链表其实跟数组差不多，都是一群元素的集合。链表中的各个元素，称之为'节点'。一个节点也没有的链表，就是一个空链表。在非空的链表里，每个节点又分为两部分：第一部分是这个节点的容器，用来储存信息；另一部分是该节点指针，指向其他节点，以便我们将单个的节点串联起来。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>数组需要一块连续的内存空间来存储，对内存的要求比较高。如果申请一个 100MB 大小的数组，当内存中没有连续的、足够大的存储空间时，即便内存的剩余总可用空间大于 100MB，仍然会申请失败。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>而链表恰恰相反，它并不需要一块连续的内存空间，它通过“指针”将一组<strong>零散的内存块</strong>串联起来使用，所以如果申请的是 100MB 大小的链表，根本不会有问题。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph {"fontSize":"medium"} -->
<p class="has-medium-font-size"><strong>单链表</strong></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>链表通过指针将一组零散的内存块串联在一起。其中，把内存块称为链表的“<strong>结点</strong>”。为了将所有的结点串起来，每个链表的结点除了存储数据之外，还需要记录链上的下一个结点的地址。如图所示，我们把这个记录下个结点地址的指针叫作<strong>后继指针 next</strong>。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>其中有两个结点是比较特殊的，它们分别是第一个结点和最后一个结点。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>习惯性地把第一个结点叫作头结点，把最后一个结点叫作尾结点。其中，头结点用来记录链表的基地址。有了它，我们就可以遍历得到整条链表。而尾结点特殊的地方是：指针不是指向下一个结点，而是指向一个空地址 NULL，表示这是链表上最后一个结点。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>与数组一样，链表也支持数据的查找、插入和删除操作。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>在链表中插入或者删除一个数据，我们并不需要为了保持内存的连续性而搬移结点，因为链表的存储空间本身就不是连续的。所以，在链表中插入和删除一个数据是非常快速的。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>针对链表的插入和删除操作，我们只需要考虑相邻结点的指针改变，所以对应的时间复杂度是 O(1)。</p>
<!-- /wp:paragraph -->

<!-- wp:image {"align":"center","id":278,"sizeSlug":"large"} -->
<div class="wp-block-image"><figure class="aligncenter size-large"><img src="http://img.varsion.cn/blog-img/2020/07/image-7.png" alt="" class="wp-image-278"/><figcaption>链表的操作</figcaption></figure></div>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>有利就有弊。如果链表要想随机访问第 k 个元素，就没有数组那么高效了。因为链表中的数据并非连续存储的，所以无法像数组那样，根据首地址和下标，通过寻址公式就能直接计算出对应的内存地址，而是需要根据指针一个结点一个结点地依次遍历，直到找到相应的结点。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>所以，链表随机访问的性能没有数组好，需要 <code>O(n)</code> 的时间复杂度。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph {"fontSize":"medium"} -->
<p class="has-medium-font-size"><strong>循环链表</strong></p>
<!-- /wp:paragraph -->

<!-- wp:image {"align":"center","id":280,"sizeSlug":"large"} -->
<div class="wp-block-image"><figure class="aligncenter size-large"><img src="http://img.varsion.cn/blog-img/2020/07/image-8.png" alt="" class="wp-image-280"/><figcaption>循环链表</figcaption></figure></div>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>循环链表是一种特殊的单链表，唯一的区别在于，单链表的尾结点指向空，而循环链表的尾结点指向头结点。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>循环链表的优点是从链尾到链头比较方便。当要处理的数据具有环型结构特点时，就特别适合采用循环链表。（比如'约瑟夫环')</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph {"fontSize":"medium"} -->
<p class="has-medium-font-size"><strong>双向链表</strong></p>
<!-- /wp:paragraph -->

<!-- wp:image {"align":"center","id":283,"sizeSlug":"large"} -->
<div class="wp-block-image"><figure class="aligncenter size-large"><img src="http://img.varsion.cn/blog-img/2020/07/image-9.png" alt="" class="wp-image-283"/><figcaption>双向链表</figcaption></figure></div>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>双向链表，它支持两个方向，每个结点不止有一个后继指针 next 指向后面的结点，还有一个前驱指针 prev 指向前面的结点。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>双向链表需要额外的两个空间来存储后继结点和前驱结点的地址。所以，如果存储同样多的数据，双向链表要比单链表占用更多的内存空间。虽然两个指针比较浪费存储空间，但可以支持双向遍历，这样也带来了双向链表操作的灵活性。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>从结构上来看，双向链表可以支持 O(1) 时间复杂度的情况下找到前驱结点，正是这样的特点，也使双向链表在某些情况下的插入、删除等操作都要比单链表简单、高效。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph {"fontSize":"medium"} -->
<p class="has-medium-font-size"><strong>单链表和双向链表之间的比较</strong></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><strong>删除操作</strong></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>实际的软件开发中，从链表中删除一个数据无外乎这两种情况：</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul><li>删除结点中“值等于某个给定值”的结点</li><li>删除给定指针指向的结点</li></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>尽管单纯的删除操作时间复杂度是 O(1)，但遍历查找的时间是主要的耗时点，对应的时间复杂度为 O(n)。根据时间复杂度分析中的加法法则，删除值等于给定值的结点对应的链表操作的总时间复杂度为 O(n)。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>第二种情况，已经找到了要删除的结点，但是删除某个结点 q 需要知道其前驱结点，而单链表并不支持直接获取前驱结点，所以，为了找到前驱结点，我们还是要从头结点开始遍历链表，直到 p-&gt;next=q，说明 p 是 q 的前驱结点。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>对于双向链表来说，这种情况就比较有优势了。因为双向链表中的结点已经保存了前驱结点的指针，不需要像单链表那样遍历。所以，针对第二种情况，单链表删除操作需要 O(n) 的时间复杂度，而双向链表只需要在 O(1) 的时间复杂度内就搞定了！</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>如果希望在链表的某个指定结点前面插入一个结点，双向链表比单链表有很大的优势。双向链表可以在 O(1) 时间复杂度搞定，而单向链表需要 O(n) 的时间复杂度。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph {"fontSize":"medium"} -->
<p class="has-medium-font-size"><strong>'空间换时间' 和 '时间换空间'</strong></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>对于执行较慢的程序，可以通过消耗更多的内存（空间换时间）来进行优化；而消耗过多内存的程序，可以通过消耗更多的时间（时间换空间）来降低内存的消耗。</p>
<!-- /wp:paragraph -->

<!-- wp:image {"align":"center","id":288,"width":509,"height":247,"sizeSlug":"large"} -->
<div class="wp-block-image"><figure class="aligncenter size-large is-resized"><img src="http://img.varsion.cn/blog-img/2020/07/image-10.png" alt="" class="wp-image-288" width="509" height="247"/></figure></div>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>数组和链表的对比，并不能局限于时间复杂度。而且，在实际的软件开发中，不能仅仅利用复杂度分析就决定使用哪个数据结构来存储数据。数组简单易用，在实现上使用的是连续的内存空间，可以借助 CPU 的缓存机制，预读数组中的数据，所以访问效率更高。而链表在内存中并不是连续存储，所以对 CPU 缓存不友好，没办法有效预读。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>如果你的代码对内存的使用非常苛刻，那数组就更适合你。因为链表中的每个结点都需要消耗额外的存储空间去存储一份指向下一个结点的指针，所以内存消耗会翻倍。而且，对链表进行频繁的插入、删除操作，还会导致频繁的内存申请和释放，容易造成内存碎片</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph {"fontSize":"medium"} -->
<p class="has-medium-font-size"><strong>基于链表实现 LRU 缓存淘汰算法</strong></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>缓存的大小有限，当缓存被用满时，哪些数据应该被清理出去，哪些数据应该被保留？这就需要缓存淘汰策略来决定。常见的策略有三种：</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul><li>先进先出策略 FIFO（First In，First Out）</li><li>最少使用策略 LFU（Least Frequently Used）</li><li>最近最少使用策略 LRU（Least Recently Used）</li></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>我们维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。当有一个新的数据被访问时，我们从链表头开始顺序遍历链表。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>1. 如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>2. 如果此数据没有在缓存链表中，又可以分为两种情况：</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul><li>如果此时缓存未满，则将此结点直接插入到链表的头部；</li><li>如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部。</li></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p></p>
<!-- /wp:paragraph -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>262</wp:post_id>
		<wp:post_date><![CDATA[2020-07-31 17:13:21]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2020-07-31 09:13:21]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%8e%e7%ae%97%e6%b3%95-%e9%93%be%e8%a1%a8]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="ruby"><![CDATA[Ruby]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
		<category domain="category" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%8e%e7%ae%97%e6%b3%95"><![CDATA[数据结构与算法]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<category domain="post_tag" nicename="%e9%93%be%e8%a1%a8"><![CDATA[链表]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[rank_math_primary_category]]></wp:meta_key>
		<wp:meta_value><![CDATA[18]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[no_intro]]></wp:meta_key>
		<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_no_intro]]></wp:meta_key>
		<wp:meta_value><![CDATA[nanospace_no_intro]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[no_intro_media]]></wp:meta_key>
		<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_no_intro_media]]></wp:meta_key>
		<wp:meta_value><![CDATA[nanospace_no_intro_media]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[intro_image]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_intro_image]]></wp:meta_key>
		<wp:meta_value><![CDATA[nanospace_intro_image]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[show_intro_widgets]]></wp:meta_key>
		<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_show_intro_widgets]]></wp:meta_key>
		<wp:meta_value><![CDATA[nanospace_show_intro_widgets]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[content_layout]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_content_layout]]></wp:meta_key>
		<wp:meta_value><![CDATA[nanospace_content_layout]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[rank_math_internal_links_processed]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[rank_math_seo_score]]></wp:meta_key>
		<wp:meta_value><![CDATA[70]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_primary_category]]></wp:meta_key>
		<wp:meta_value><![CDATA[18]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_content_score]]></wp:meta_key>
		<wp:meta_value><![CDATA[90]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_focuskw]]></wp:meta_key>
		<wp:meta_value><![CDATA[链表]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_linkdex]]></wp:meta_key>
		<wp:meta_value><![CDATA[39]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_metadesc]]></wp:meta_key>
		<wp:meta_value><![CDATA[链表其实跟数组差不多，都是一群元素的集合。链表中的各个元素，称之为'节点'。一个节点也没有的链表，就是一个空链表。在非空的链表里，每个节点又分为两部分：第一部分是这个节点的容器，用来储存信息；另一部分是该节点指针，指向其他节点，以便我们将单个的节点串联起来。]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[rank_math_focus_keyword]]></wp:meta_key>
		<wp:meta_value><![CDATA[链表,数据结构,算法]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_wp_page_template]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>如何完成一个链表</title>
		<link>https://blog.varsion.cn/?p=313</link>
		<pubDate>Sat, 01 Aug 2020 10:47:22 +0000</pubDate>
		<dc:creator><![CDATA[Varsion]]></dc:creator>
		<guid isPermaLink="false">https://blog.varsion.cn/?p=313</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:block {"ref":187} /-->

<!-- wp:paragraph -->
<p>Ruby的简单的单链表实例：</p>
<!-- /wp:paragraph -->

<!-- wp:codemirror-blocks/code-block {"mode":"ruby","mime":"text/x-ruby"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre># 单链表节点
class Node
    attr_accessor :value , :next
    def initialize(value)
        @value = value # 节点值
        @next  = nil   # 指向下个节点
    end
end

# 新建节点
node1 = Node.new(1)
node2 = Node.new(2)
node3 = Node.new(3)

# 连接节点
node1.next = node2
node2.next = node3</pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:heading {"level":4} -->
<h4><strong>方法一:理解指针或引用的含义</strong></h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>有些语言有“指针”的概念，比如 C 语言；有些语言没有指针，取而代之的是“引用”，比如 Java、Python。不管是“指针”还是“引用”，实际上，它们的意思都是一样的，都是<strong>存储所指对象的内存地址</strong>。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>对于指针或引用的理解，</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>将某个变量赋值给指针，实际上就是将这个<strong>变量的地址赋值给指针</strong>，或者反过来说，指<strong>针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量</strong>。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><code>node1.next = node2</code>:指的就是将<code>node1</code>的<code>next</code>引用到（指向）<code>node2</code>节点的<code>value</code>的内存地址，从而实现链表结构。</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4><strong>方法二:警惕指针丢失或内存泄漏</strong></h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>使用单链表实例来展示指针丢失的情况，参考上面的代码，我们现在又<code>ndoe1-&gt;node2-&gt;node3</code>三个节点，现在在<code>node1</code>和<code>node2</code>之间插入<code>nodeX</code>节点</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p></p>
<!-- /wp:paragraph -->

<!-- wp:codemirror-blocks/code-block {"mode":"ruby","mime":"text/x-ruby"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre>nodeX = Node.new('x')

node1.next = nodeX # node1的next指向X
nodeX.next = node1.next # X的next指向node2</pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:paragraph -->
<p>一般来讲的错误，是第二步直接进行 <code>nodeX.next = node1.next</code> 因为此时，<code>node1.next</code> 已经是 <code>nodeX</code> 了相当于自己指向自己，整个链表也就断成了两半，从 <code>nodeX</code> 往后的所有结点都无法访问到了。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>对于有些语言来说，比如 C 语言，内存管理是由程序员负责的，如果没有手动释放结点对应的内存空间，就会产生内存泄露。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>所以，插入结点时，应当要注意操作的顺序，要先将结点 x 的 next 指针指向结点 <code>node2</code> ，再把结点 <code>node1</code> 的 next 指针指向结 <code>nodeX</code> ，这样才不会丢失指针，导致内存泄漏。</p>
<!-- /wp:paragraph -->

<!-- wp:codemirror-blocks/code-block {"mode":"ruby","mime":"text/x-ruby"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre>nodeX.next = node1.next
node1.next = nodeX </pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:paragraph -->
<p>同理，<strong>删除链表结点时，也一定要记得手动释放内存空间</strong>，否则，也会出现内存泄漏的问题。当然，对于像 Java 这种虚拟机自动管理内存的编程语言来说，就不需要考虑这么多了。</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4><strong>方法三:利用哨兵简化实现难度</strong></h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>当我们要向一个空链表中插入第一个结点，刚刚的代码逻辑就不能用了。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>需要对头节点进行判断</p>
<!-- /wp:paragraph -->

<!-- wp:codemirror-blocks/code-block {"mode":"ruby","mime":"text/x-ruby"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre>if head == null do
  head = Node.new('value')
end</pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:paragraph -->
<p>删除结点时，操作边的更为简单了。删除node2节点</p>
<!-- /wp:paragraph -->

<!-- wp:codemirror-blocks/code-block {"mode":"ruby","mime":"text/x-ruby"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre>node1.next = node1.next.next</pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:paragraph -->
<p>但是，如果要删除链表的末尾结点，仍然需要进行判断</p>
<!-- /wp:paragraph -->

<!-- wp:codemirror-blocks/code-block {"mode":"ruby","mime":"text/x-ruby"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre>if node3.next == null do
  node3 = null
end</pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:paragraph -->
<p>所以，<strong>针对链表的插入、删除操作，需要对插入第一个结点和删除最后一个结点的情况进行特殊处理</strong>。这里，引入“哨兵”的概念，这里说的哨兵也是<strong>解决“边界问题”的，不直接参与业务逻辑</strong>。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>如果我们引入哨兵结点，在任何时候，不管链表是不是空，head 指针都会一直指向这个哨兵结点。<strong>把这种有哨兵结点的链表叫带头链表</strong>。相反，<strong>没有哨兵结点的链表就叫作不带头链表</strong>。</p>
<!-- /wp:paragraph -->

<!-- wp:image {"align":"center","id":327,"sizeSlug":"large"} -->
<div class="wp-block-image"><figure class="aligncenter size-large"><img src="http://img.varsion.cn/blog-img/2020/08/image.png" alt="" class="wp-image-327"/><figcaption>带头链表</figcaption></figure></div>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>哨兵结点是不存储数据的。因为哨兵结点一直存在，所以插入第一个结点和插入其他结点，删除最后一个结点和删除其他结点，都可以统一为相同的代码实现逻辑了。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>实际上，这种利用哨兵简化编程难度的技巧，在很多代码实现中都有用到，比如插入排序、归并排序、动态规划等。</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4><strong>方法四:重点留意边界条件处理</strong></h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>软件开发中，代码在一些边界或者异常情况下，最容易产生 Bug。链表代码也不例外。要实现没有 Bug 的链表代码，一定要在编写的过程中以及编写完成之后，检查边界条件是否考虑全面，以及代码在边界条件下是否能正确运行。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>经常用来检查链表代码是否正确的边界条件有这样几个：</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul><li>如果链表为空时，代码是否能正常工作？</li><li>如果链表只包含一个结点时，代码是否能正常工作？</li><li>如果链表只包含两个结点时，代码是否能正常工作？</li><li>代码逻辑在处理头结点和尾结点的时候，是否能正常工作？</li></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>当完成链表代码之后，除了看下你写的代码在正常的情况下能否工作，还要看下在上面我列举的几个边界条件下，代码仍然能否正确工作。如果这些边界条件下都没有问题，那基本上可以认为没有问题了。</p>
<!-- /wp:paragraph -->

<!-- wp:separator {"className":"is-style-wide"} -->
<hr class="wp-block-separator is-style-wide"/>
<!-- /wp:separator -->

<!-- wp:block {"ref":178} /-->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>313</wp:post_id>
		<wp:post_date><![CDATA[2020-08-01 18:47:22]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2020-08-01 10:47:22]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e5%a6%82%e4%bd%95%e5%ae%8c%e6%88%90%e4%b8%80%e4%b8%aa%e9%93%be%e8%a1%a8-%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%8e%e7%ae%97%e6%b3%95]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="ruby"><![CDATA[Ruby]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
		<category domain="category" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%8e%e7%ae%97%e6%b3%95"><![CDATA[数据结构与算法]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<category domain="post_tag" nicename="%e9%93%be%e8%a1%a8"><![CDATA[链表]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[rank_math_internal_links_processed]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[rank_math_seo_score]]></wp:meta_key>
		<wp:meta_value><![CDATA[63]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[rank_math_focus_keyword]]></wp:meta_key>
		<wp:meta_value><![CDATA[链表,数据结构,算法,linked_list]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[rank_math_rich_snippet]]></wp:meta_key>
		<wp:meta_value><![CDATA[article]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[rank_math_snippet_article_type]]></wp:meta_key>
		<wp:meta_value><![CDATA[BlogPosting]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[rank_math_description]]></wp:meta_key>
		<wp:meta_value><![CDATA[有些语言有“指针”的概念，比如 C 语言；有些语言没有指针，取而代之的是“引用”，比如 Java、Python。不管是“指针”还是“引用”，实际上，它们的意思都是一样的，都是存储所指对象的内存地址。]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[rank_math_primary_category]]></wp:meta_key>
		<wp:meta_value><![CDATA[18]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>栈(stack)</title>
		<link>https://blog.varsion.cn/?p=333</link>
		<pubDate>Sun, 02 Aug 2020 08:20:43 +0000</pubDate>
		<dc:creator><![CDATA[Varsion]]></dc:creator>
		<guid isPermaLink="false">https://blog.varsion.cn/?p=333</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:block {"ref":187} /-->

<!-- wp:paragraph {"align":"center"} -->
<p class="has-text-align-center"><strong>后进者先出，先进者后出，这就是典型的“栈”结构。</strong></p>
<!-- /wp:paragraph -->

<!-- wp:image {"align":"center","id":334,"sizeSlug":"large"} -->
<div class="wp-block-image"><figure class="aligncenter size-large"><img src="http://img.varsion.cn/blog-img/2020/08/image-1.png" alt="" class="wp-image-334"/><figcaption>栈的结构</figcaption></figure></div>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>在上面这个栈中，我们加入节点的顺序是 node3, node2, node1。而访问节点的时候，我们则按照从上到下的顺序：node1, node2, node3。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>从栈的操作特性上来看，栈是一种“操作受限”的线性表，只允许在一端插入和删除数据。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>从功能上来说，数组或链表确实可以替代栈，但你要知道，特定的数据结构是对特定场景的抽象，而且，数组或链表暴露了太多的操作接口，操作上的确灵活自由，但使用时就比较不可控，自然也就更容易出错。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><strong>当某个数据集合只涉及在一端插入和删除数据，并且满足后进先出、先进后出的特性，我们就应该首选“栈”这种数据结构。</strong></p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>实现一个栈</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>栈既可以用数组来实现，也可以用链表来实现。<strong>用数组实现的栈，叫作顺序栈，用链表实现的栈，叫作链式栈。</strong></p>
<!-- /wp:paragraph -->

<!-- wp:codemirror-blocks/code-block {"fileName":"Ruby","mime":"text/x-ruby"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre># 节点
class Node
    attr_accessor :value , :next
    def initialize(value)
        @value = value # 节点值
        @next  = nil   # 指向下个节点
    end
end</pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:codemirror-blocks/code-block {"mode":"ruby","mime":"text/x-ruby"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre>class Stack
  def initialize # 初始化一个栈
    @first = nil
    @length = 0
  end

  attr_reader :first, :length
 
  def push(item) # 向栈顶压入一个节点
    old_first = @first        # 备份原来的栈顶节点
    @first = Node.new(item)   # 新建一个节点，并将它标记为新的栈顶节点
    @first.next = old_first   # 将新的栈顶节点的next指针指向原来的栈顶节点。
    @length += 1
  end
 
  def pop # 将栈顶的节点弹出
    return nil if is_empty?   # 栈本身为空的情况下直接返回空
    item = @first.item        # 保存原先栈顶节点的item
    @first = @first.next      # 将原栈的第二个节点标记为栈顶节点
    @length -= 1
    return item
  end
  
  def first # 返回栈顶的节点
    return @first
  end
 
  def length # 返回栈的长度
    return @length
  end
 
  def is_empty? # 返回栈是否为空
    return @length == 0
  end
end</pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:heading {"level":3} -->
<h3>函数调用栈</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>操作系统给每个线程分配了一块独立的内存空间，这块内存被组织成“栈”这种结构, 用来存储函数调用时的临时变量。每进入一个函数，就会将临时变量作为一个栈帧入栈，当被调用函数执行完成，返回之后，将这个函数对应的栈帧出栈。即，根据程序执行顺序，依次将每行代码压入数据栈。</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>利用栈实现表达式求值</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>编译器通过两个栈来实现表达式求值。其中一个保存操作数的栈，另一个是保存运算符的栈。我们从左向右遍历表达式，当遇到数字，我们就直接压入操作数栈；当遇到运算符，就与运算符栈的栈顶元素进行比较。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>如果比运算符栈顶元素的优先级高，就将当前运算符压入栈；如果比运算符栈顶元素的优先级低或者相同，从运算符栈中取栈顶运算符，从操作数栈的栈顶取 2 个操作数，然后进行计算，再把计算完的结果压入操作数栈，继续比较。</p>
<!-- /wp:paragraph -->

<!-- wp:image -->
<figure class="wp-block-image"><img src="https://static001.geekbang.org/resource/image/bc/00/bc77c8d33375750f1700eb7778551600.jpg" alt=""/><figcaption>这边就直接使用王争老师的图了</figcaption></figure>
<!-- /wp:image -->

<!-- wp:heading {"level":3} -->
<h3>栈在括号匹配中的应用</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>我们假设表达式中只包含三种括号，圆括号 <code>()</code>、方括号<code>[]</code>和花括号<code>{}</code>，并且它们可以任意嵌套。比如，<code>{[] ()[{}]}</code>或<code>[{()}([])]</code>等都为合法格式，而<code>{[}()]</code>或<code>[({)]</code>为不合法的格式。那我现在给你一个包含三种括号的表达式字符串，如何检查它是否合法呢？</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>这里也可以用栈来解决。我们用栈来保存未匹配的左括号，从左到右依次扫描字符串。<strong><span class="has-inline-color has-bright-blue-color">当扫描到左括号时，则将其压入栈中；当扫描到右括号时，从栈顶取出一个左括号。</span></strong>如果能够匹配，比如<code>(</code>跟<code>)</code>匹配，<code>[</code>跟<code>]</code>匹配，<code>{</code>跟<code>}</code>匹配，则继续扫描剩下的字符串。如果扫描的过程中，遇到不能配对的右括号，或者栈中没有数据，则说明为非法格式。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>当所有的括号都扫描完成之后，如果栈为空，则说明字符串为合法格式；否则，说明有未匹配的左括号，为非法格式。</p>
<!-- /wp:paragraph -->

<!-- wp:separator {"className":"is-style-wide"} -->
<hr class="wp-block-separator is-style-wide"/>
<!-- /wp:separator -->

<!-- wp:block {"ref":178} /-->

<!-- wp:paragraph -->
<p></p>
<!-- /wp:paragraph -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>333</wp:post_id>
		<wp:post_date><![CDATA[2020-08-02 16:20:43]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2020-08-02 08:20:43]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e6%a0%88%ef%bc%88stack%ef%bc%89-%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%8e%e7%ae%97%e6%b3%95]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="ruby"><![CDATA[Ruby]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
		<category domain="category" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%8e%e7%ae%97%e6%b3%95"><![CDATA[数据结构与算法]]></category>
		<category domain="post_tag" nicename="%e6%a0%88"><![CDATA[栈]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[rank_math_seo_score]]></wp:meta_key>
		<wp:meta_value><![CDATA[64]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[rank_math_internal_links_processed]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[rank_math_focus_keyword]]></wp:meta_key>
		<wp:meta_value><![CDATA[stack,ruby,数据结构,算法]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[rank_math_primary_category]]></wp:meta_key>
		<wp:meta_value><![CDATA[18]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>队列(queue)</title>
		<link>https://blog.varsion.cn/?p=350</link>
		<pubDate>Mon, 03 Aug 2020 13:59:56 +0000</pubDate>
		<dc:creator><![CDATA[Varsion]]></dc:creator>
		<guid isPermaLink="false">https://blog.varsion.cn/?p=350</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:block {"ref":187} /-->

<!-- wp:paragraph -->
<p>队列这个概念非常好理解。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>可以把它想象成排队买票，先来的先买，后来的人只能站末尾，不允许插队。先进者先出，这就是典型的“队列”。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>队列跟栈非常相似，支持的操作也很有限，最基本的操作也是两个：入队 enqueue()，放一个数据到队列尾部；出队 dequeue()，从队列头部取一个元素。队列跟栈一样，也是一种操作受限的线性表数据结构。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>作为一种非常基础的数据结构，队列的应用也非常广泛，特别是一些具有某些额外特性的队列，比如循环队列、阻塞队列、并发队列。它们在很多偏底层系统、框架、中间件的开发中，起着关键性的作用。</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>Ruby的链式队列实现</h3>
<!-- /wp:heading -->

<!-- wp:codemirror-blocks/code-block {"mode":"ruby","mime":"text/x-ruby"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre># Node
class Node
  attr_accessor :item, :next
  def initialize(item)
    @item = item                      # 用来保存信息
    @next = nil                       # 用来指向下一个节点
  end
end</pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:codemirror-blocks/code-block {"mode":"ruby","mime":"text/x-ruby"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre>class Queue
   attr_reader :first, :length 
def initialize       # 初始化一个队列
  @first = nil
  @last = nil
  @length = 0
end
 
def enqueue(item)            # 向队列的末尾添加一个元素
  node = Node.new(item)      # 新建一个节点
  if is_empty?               # 当队列为空的时候，首节点和尾节点都设置为这个新加入的节点
    @first = node
    @last = @first
  else
    @last.next = node        # 当队列不为空的时候，就将尾节点的下一个节点设置为新节点
    @last = @last.next       # 让后将队列的尾节点更新为新节点
  end
  @length += 1               # 新节点加入完成后，队列的长度增加1
end
 
 def dequeue                     # 删除队列的第一个元素
   return nil if @first == nil   # 当队列为空的时候，什么也不做，直接返回空值
   item = @first.item            # 队列不为空的时候，先保存会被删掉的节点的值
   @first = @first.next          # 将首节点重置为之前的第二个节点。这样我们就访问不到原来的首节点了。因此它成了孤儿，就被删除了。
   @length -= 1                  # 删除后队列的长度减去1
   @last = nil if is_empty?      # 删除节点后队列为空的话，就将队列的最后一个节点也设置为空
   return item                   # 返回之前保存的被删除的节点的值
 end
 
 def is_empty?               # 返回队列是否为空（即队列中是否没有节点）
   return @length == 0
 end
 
end</pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:paragraph -->
<p></p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>阻塞队列和并发队列</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>阻塞队列其实就是在队列基础上增加了阻塞操作。简单来说，就是在队列为空的时候，从队头取数据会被阻塞。因为此时还没有数据可取，直到队列中有了数据才能返回</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>如果队列已经满了，那么插入数据的操作就会被阻塞，直到队列中有空闲位置后再插入数据，然后再返回。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><strong>阻塞队列的定义定义就是一个"生产者 - 消费者模型"</strong></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>这种基于阻塞队列实现的"生产者 - 消费者模型"，可以有效地协调生产和消费的速度。当“生产者”生产数据的速度过快，“消费者”来不及消费时，存储数据的队列很快就会满了。这个时候，生产者就阻塞等待，直到“消费者”消费了数据，“生产者”才会被唤醒继续“生产”。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>线程安全的队列我们叫作并发队列。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>最简单直接的实现方式是直接在 enqueue()、dequeue() 方法上加锁，但是锁粒度大并发度会比较低，同一时刻仅允许一个存或者取操作。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>实际上，基于数组的循环队列，利用 CAS 原子操作，可以实现非常高效的并发队列。这也是循环队列比链式队列应用更加广泛的原因。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><strong>线程池没有空闲线程时，新的任务请求线程资源时，线程池该如何处理？</strong></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>第一种是非阻塞的处理方式，直接拒绝任务请求；另一种是阻塞的处理方式，将请求排队，等到有空闲线程时，取出排队的请求继续处理。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>我们希望公平地处理每个排队的请求，先进者先服务，所以队列这种数据结构很适合来存储排队请求。我们前面说过，队列有基于链表和基于数组这两种实现方式。这两种实现方式对于排队请求又有什么区别呢？</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>基于链表的实现方式，可以实现一个支持无限排队的无界队列，但是可能会导致过多的请求排队等待，请求处理的响应时间过长。所以，针对响应时间比较敏感的系统，基于链表实现的无限排队的线程池是不合适的。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>而基于数组实现的有界队列，队列的大小有限，所以线程池中排队的请求超过队列大小时，接下来的请求就会被拒绝，这种方式对响应时间敏感的系统来说，就相对更加合理。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>对于大部分资源有限的场景，当没有空闲资源时，基本上都可以通过“队列”这种数据结构来实现请求排队。</p>
<!-- /wp:paragraph -->

<!-- wp:separator {"className":"is-style-wide"} -->
<hr class="wp-block-separator is-style-wide"/>
<!-- /wp:separator -->

<!-- wp:block {"ref":178} /-->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>350</wp:post_id>
		<wp:post_date><![CDATA[2020-08-03 21:59:56]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2020-08-03 13:59:56]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e9%98%9f%e5%88%97queue-%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%8e%e7%ae%97%e6%b3%95]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="ruby"><![CDATA[Ruby]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
		<category domain="category" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%8e%e7%ae%97%e6%b3%95"><![CDATA[数据结构与算法]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<category domain="post_tag" nicename="%e9%98%9f%e5%88%97"><![CDATA[队列]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[rank_math_primary_category]]></wp:meta_key>
		<wp:meta_value><![CDATA[18]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[rank_math_seo_score]]></wp:meta_key>
		<wp:meta_value><![CDATA[59]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[rank_math_internal_links_processed]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[rank_math_focus_keyword]]></wp:meta_key>
		<wp:meta_value><![CDATA[Queue,Ruby,数据结构,算法,队列]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[rank_math_description]]></wp:meta_key>
		<wp:meta_value><![CDATA[

队列这个概念非常好理解。





可以把它想象成排队买票，先来的先买，后来的人只能站末尾，不允许插队。先进者先出，这就是典型的“队列”。

]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>Ruby实现循环队列（CircularQueue）</title>
		<link>https://blog.varsion.cn/?p=358</link>
		<pubDate>Tue, 04 Aug 2020 09:09:14 +0000</pubDate>
		<dc:creator><![CDATA[Varsion]]></dc:creator>
		<guid isPermaLink="false">https://blog.varsion.cn/?p=358</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:quote -->
<blockquote class="wp-block-quote"><p>昨天进行了队列的部分，准备今天把循环队列单独拿出来做一次笔记，关于Ruby的循环队列。</p><cite><em>没有找到什么值得参考的博文和例子，就只能自己慢慢摸索这着写。</em>同时参考了该题目<a href="https://leetcode-cn.com/problems/design-circular-queue/" class="rank-math-link">662.设计循环队列</a></cite></blockquote>
<!-- /wp:quote -->

<!-- wp:paragraph -->
<p>根据循环队列的需要列出了大概的结构框架，然后需要针对每个函数进行分析，</p>
<!-- /wp:paragraph -->

<!-- wp:codemirror-blocks/code-block {"mode":"ruby","mime":"text/x-ruby"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre>class LoopQueue

    def initialize(size)

    end

    # 入队
    def enQueue(item) 
        
    end

    # 出队
    def deQueue
        
    end

    # 判空
    def is_empty? 
    
    end

    # 判满
    def is_full? 
    	
    end    
end</pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:paragraph -->
<p>先来考虑的结构初始化所需要的内容:开辟循环队列所需要的空间，并指定头尾两个节点:</p>
<!-- /wp:paragraph -->

<!-- wp:codemirror-blocks/code-block {"mode":"ruby","mime":"text/x-ruby"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre>    attr_reader :head, :last, :Maxsize
    def initialize(size)
        @Maxsize = ++size
        @head = nil
        @last = nil
        @queue = Array.new(@Maxsize)
    end</pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:paragraph -->
<p>接下来考虑的是如何判满和判空</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul><li><strong>满</strong>：当队列添加元素到last的下一个元素是head的时候，也就是转圈子要碰头了，<code>(@last + 1) % @Maxsize == @head</code> 我们就认为队列满了。</li><li><strong>空</strong>：当队列删除元素到 <code>head == last</code> 的时候，我们认为队列空了。</li></ul>
<!-- /wp:list -->

<!-- wp:codemirror-blocks/code-block {"mode":"ruby","mime":"text/x-ruby"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre>    def is_empty? 
        if @head == @last
            return true
        else
            return false
        end
    end

    def is_full? 
        if (@last + 1) % @Maxsize == @head
            return true
        else
            return false
        end
    end</pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:paragraph -->
<p>最重要的两个操作是入队和出队，注意<code>%</code>的含义:</p>
<!-- /wp:paragraph -->

<!-- wp:codemirror-blocks/code-block {"mode":"ruby","mime":"text/x-ruby"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre>    # 入队
    def enQueue(item) 
        return false if is_full?
        @queue[@last] = item
        @last = (@last+1) % @Maxsize
        return true
    end

    # 出队
    def deQueue
        return false if is_empty?
        data = @queue[@head]
        @queue[@head] = 0 
        @head = (@head+1) % @Maxsize
        return data
    end</pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:paragraph -->
<p>获取队首元素和队尾元素，这里注意获取队尾时<code>last</code>应当<code>-1</code></p>
<!-- /wp:paragraph -->

<!-- wp:codemirror-blocks/code-block {"mode":"ruby","mime":"text/x-ruby"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre>    # 获取队首
    def front
        return -1 if is_empty?
        return @queue[@head]
    end
    # 获取队尾
    def rear
        return -1 if is_empty?
        return @queue[@last-1]
    end</pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:paragraph -->
<p>完整的代码我放在了最后这里:</p>
<!-- /wp:paragraph -->

<!-- wp:codemirror-blocks/code-block {"mode":"ruby","mime":"text/x-ruby"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre>class LoopQueue
    attr_accessor :head, :last, :Maxsize
    def initialize(size)
        @Maxsize = size+1
        @head = 0
        @last = 0
        @queue = Array.new(@Maxsize)
    end

    def getSize
        return @Maxsize
    end
    

    # 入队
    def enQueue(item) 
        return false if is_full?
        
        @queue[@last] = item
        @last = (@last+1) % @Maxsize

        return true
    end

    # 出队
    def deQueue
        return false if is_empty?
        data = @queue[@head]
        @queue[@head] = 0 
        @head = (@head+1) % @Maxsize
        return data
    end

    # 获取队首
    def front
        return -1 if is_empty?
        return @queue[@head]
    end
    # 获取队尾
    def rear
        return -1 if is_empty?
        return @queue[@last-1]
    end
    
    # 判空
    def is_empty? 
        if @head == @last
            return true
        else
            return false
        end
    end

    # 判满
    def is_full? 
        if (@last + 1) % @Maxsize == @head
            return true
        else
            return false
        end     
    end    
end</pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:paragraph -->
<p>这个代码并不符合题目<a href="https://leetcode-cn.com/problems/design-circular-queue/">662.设计循环队列</a>的要求，我这里是根据我的编码习惯写出代码，完成题目的话，也仅仅是根据题目修改方法名称即可。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>下面这个是符合题目要求的代码:</p>
<!-- /wp:paragraph -->

<!-- wp:codemirror-blocks/code-block {"mode":"ruby","mime":"text/x-ruby"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre>class MyCircularQueue

=begin
    Initialize your data structure here. Set the size of the queue to be k.
    :type k: Integer
=end
attr_accessor :head, :last, :Maxsize
    def initialize(k)
        @Maxsize = k+1
        @head = 0
        @last = 0
        @queue = Array.new(@Maxsize)
    end
=begin
    Insert an element into the circular queue. Return true if the operation is successful.
    :type value: Integer
    :rtype: Boolean
=end
    def en_queue(value)
        return false if is_full
        
        @queue[@last] = value
        @last = (@last+1) % @Maxsize

        return true
    end
=begin
    Delete an element from the circular queue. Return true if the operation is successful.
    :rtype: Boolean
=end
    def de_queue()
        return false if is_empty
        data = @queue[@head]
        @queue[@head] = 0 
        @head = (@head+1) % @Maxsize
        return true
    end
=begin
    Get the front item from the queue.
    :rtype: Integer
=end
    def front()
    return -1 if is_empty
        return @queue[@head]
    end
=begin
    Get the last item from the queue.
    :rtype: Integer
=end
    def rear()
    return -1 if is_empty
        return @queue[@last-1]
    end


=begin
    Checks whether the circular queue is empty or not.
    :rtype: Boolean
=end
    def is_empty()
        if @head == @last
            return true
        else
            return false
        end
    end
=begin
    Checks whether the circular queue is full or not.
    :rtype: Boolean
=end
    def is_full()
        if (@last + 1) % @Maxsize == @head
            return true
        else
            return false
        end
    end
end</pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:block {"ref":178} /-->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>358</wp:post_id>
		<wp:post_date><![CDATA[2020-08-04 17:09:14]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2020-08-04 09:09:14]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[ruby%e5%ae%9e%e7%8e%b0%e5%be%aa%e7%8e%af%e9%98%9f%e5%88%97%ef%bc%88circularqueue%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="ruby"><![CDATA[Ruby]]></category>
		<category domain="post_tag" nicename="ruby"><![CDATA[Ruby]]></category>
		<category domain="post_tag" nicename="%e5%be%aa%e7%8e%af%e9%98%9f%e5%88%97"><![CDATA[循环队列]]></category>
		<category domain="category" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%8e%e7%ae%97%e6%b3%95"><![CDATA[数据结构与算法]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[rank_math_primary_category]]></wp:meta_key>
		<wp:meta_value><![CDATA[3]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[rank_math_seo_score]]></wp:meta_key>
		<wp:meta_value><![CDATA[67]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[rank_math_internal_links_processed]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[rank_math_focus_keyword]]></wp:meta_key>
		<wp:meta_value><![CDATA[Ruby,循环队列,CircularQueue]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>递归(Recursion)</title>
		<link>https://blog.varsion.cn/?p=368</link>
		<pubDate>Wed, 05 Aug 2020 13:01:37 +0000</pubDate>
		<dc:creator><![CDATA[Varsion]]></dc:creator>
		<guid isPermaLink="false">https://blog.varsion.cn/?p=368</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:block {"ref":187} /-->

<!-- wp:paragraph -->
<p>递归是一种应用非常广泛的算法（或者编程技巧）。很多数据结构和算法的编码实现都要用到递归，比如 DFS 深度优先搜索、前中后序二叉树遍历等等。</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3><strong>递归的满足条件：</strong></h3>
<!-- /wp:heading -->

<!-- wp:list -->
<ul><li>一个问题的解可以分解为几个子问题的解</li><li> 这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样</li><li>存在递归终止条件</li></ul>
<!-- /wp:list -->

<!-- wp:heading {"level":4} -->
<h4><strong>如何写出递归代码：</strong></h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>写递归代码最关键的是写出递推公式，找到终止条件，剩下将递推公式转化为代码就很简单了。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><span class="has-inline-color has-bright-blue-color">写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码</span></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><span class="has-inline-color has-bright-blue-color">编写递归代码的关键是，只要遇到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤</span></p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4><strong>警惕堆栈溢出</strong></h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>函数调用会使用栈来保存临时变量。每调用一个函数，都会将临时变量封装为<strong><span class="has-inline-color has-bright-blue-color">栈帧</span>压入内存栈</strong>，等函数执行完成返回时，才出栈。系统栈或者虚拟机栈空间一般都不大。如果递归求解的数据规模很大，调用层次很深，一直压入栈，就会有堆栈溢出的风险。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>对于堆栈溢出，可以通过在代码中限制递归调用的最大深度的方式来解决这个问题。递归调用超过一定深度（比如 1000）之后，就不继续往下再递归了，直接返回报错。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>但这种做法并不能完全解决问题，因为最大允许的递归深度跟当前线程剩余的栈空间大小有关，事先无法计算。如果实时计算，代码过于复杂，就会影响代码的可读性。所以，如果最大深度比较小，比如 10、50，就可以用这种方法，否则这种方法并不是很实用。<strong>递归代码要警惕重复计算。</strong></p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4><strong>警惕重复计算</strong></h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>为了避免重复计算，我们可以通过一个数据结构（比如散列表）来保存已经求解过的 <code>f(k)</code>。当递归调用到 <code>f(k)</code> 时，先看下是否已经求解过了。如果是，则直接从散列表中取值返回，不需要重复计算。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>在时间效率上，递归代码里多了很多函数调用，当这些函数调用的数量较大时，就会积聚成一个可观的时间成本。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>在空间复杂度上，因为递归调用一次就会在内存栈中保存一次现场数据，所以在分析递归代码空间复杂度时，需要额外考虑这部分的开销。</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4>将递归代码改写为非递归代码</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>递归有利有弊，利是递归代码的表达力很强，写起来非常简洁；而弊就是空间复杂度高、有堆栈溢出的风险、存在重复计算、过多的函数调用会耗时较多等问题。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>递归本身就是借助栈来实现的，只不过使用的栈是系统或者虚拟机本身提供的。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>如果写代码时在内存堆上实现栈，手动模拟入栈、出栈过程，这样任何递归代码都可以改写成看上去不是递归代码的样子。</p>
<!-- /wp:paragraph -->

<!-- wp:separator {"className":"is-style-wide"} -->
<hr class="wp-block-separator is-style-wide"/>
<!-- /wp:separator -->

<!-- wp:block {"ref":178} /-->

<!-- wp:paragraph -->
<p></p>
<!-- /wp:paragraph -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>368</wp:post_id>
		<wp:post_date><![CDATA[2020-08-05 21:01:37]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2020-08-05 13:01:37]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e9%80%92%e5%bd%92%ef%bc%88recursion%ef%bc%89-%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%8e%e7%ae%97%e6%b3%95]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="recursion"><![CDATA[Recursion]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
		<category domain="category" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%8e%e7%ae%97%e6%b3%95"><![CDATA[数据结构与算法]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<category domain="post_tag" nicename="%e9%80%92%e5%bd%92"><![CDATA[递归]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[rank_math_seo_score]]></wp:meta_key>
		<wp:meta_value><![CDATA[53]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[rank_math_primary_category]]></wp:meta_key>
		<wp:meta_value><![CDATA[18]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[rank_math_internal_links_processed]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[rank_math_focus_keyword]]></wp:meta_key>
		<wp:meta_value><![CDATA[Recursion,递归,数据结构,算法,Ruby]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[rank_math_rich_snippet]]></wp:meta_key>
		<wp:meta_value><![CDATA[article]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>排序算法(sort)</title>
		<link>https://blog.varsion.cn/?p=375</link>
		<pubDate>Thu, 06 Aug 2020 15:08:11 +0000</pubDate>
		<dc:creator><![CDATA[Varsion]]></dc:creator>
		<guid isPermaLink="false">https://blog.varsion.cn/?p=375</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:block {"ref":187} /-->

<!-- wp:image {"align":"center"} -->
<div class="wp-block-image"><figure class="aligncenter"><img src="https://pic.leetcode-cn.com/88f1505afff7ae86bc3d197586467b609f47ab7a8ed59d42c2212b0848a89e78-image.png" alt="image.png"/></figure></div>
<!-- /wp:image -->

<!-- wp:heading {"level":3} -->
<h3>分析一个“排序算法”</h3>
<!-- /wp:heading -->

<!-- wp:heading {"level":4} -->
<h4>执行效率</h4>
<!-- /wp:heading -->

<!-- wp:paragraph {"align":"center"} -->
<p class="has-text-align-center"><strong>最好情况、最坏情况、平均情况时间复杂度：</strong></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>在分析排序算法的时间复杂度时，要分别给出最好情况、最坏情况、平均情况下的时间复杂度，同时还要大概了解一下这些情况下的原始数据的组成。</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul><li>对于要排序的数据，有的接近有序，有的完全无序。有序度不同的数据，对于排序的执行时间肯定是有影响的，我们要知道排序算法在不同数据下的性能表现。</li></ul>
<!-- /wp:list -->

<!-- wp:paragraph {"align":"center"} -->
<p class="has-text-align-center"><strong>时间复杂度的系数、常数 、低阶：</strong></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>时间复杂度反映的是数据规模 n 很大的时候的一个增长趋势，所以它表示的时候会忽略系数、常数、低阶。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>但是实际的软件开发中，排序的可能是 10 个、100 个、1000 个这样规模很小的数据，所以，在对同一阶时间复杂度的排序算法性能对比的时候，就要把系数、常数、低阶也考虑进来。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph {"align":"center"} -->
<p class="has-text-align-center"><strong>比较次数和交换（或移动）次数：</strong></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>基于比较的排序算法的执行过程，会涉及两种操作，一种是元素比较大小，另一种是元素交换或移动。所以，在分析排序算法的执行效率的时候，应该把比较次数和交换（或移动）次数也考虑进去。</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4><strong>排序算法的内存消耗</strong></h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>算法的内存消耗可以通过空间复杂度来衡量，排序算法也不例外。不过，针对排序算法的空间复杂度，还引入了一个新的概念，<strong>原地排序（Sorted in place）</strong>。原地排序算法，就是特指空间复杂度是 O(1) 的排序算法。</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4>排序算法的稳定性</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>这个概念是指，如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>比如有一组数据 <code>2、9、3、4、8、3</code>按照大小排序之后就是 <code>2、3、3、4、8、9</code>。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>这组数据里有两个 3。经过某种排序算法排序之后，如果两个 3 的前后顺序没有改变，那我们就把这种排序算法叫作<strong>稳定的排序算法</strong>；如果前后顺序发生变化，那对应的排序算法就叫作<strong>不稳定的排序算法</strong>。</p>
<!-- /wp:paragraph -->

<!-- wp:separator {"className":"is-style-wide"} -->
<hr class="wp-block-separator is-style-wide"/>
<!-- /wp:separator -->

<!-- wp:heading {"level":3} -->
<h3>冒泡排序(Bubble Sort)</h3>
<!-- /wp:heading -->

<!-- wp:codemirror-blocks/code-block {"mode":"ruby","mime":"text/x-ruby"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre>def bubbleSort (data)
    len = data.length
        return data if len &lt;= 1
    for i in 0...len
        flag = false
        for j in 0...(len-1)
            if data[j] &gt; data[j+1]
                tmp = data[j]
                data[j] = data[j+1]
                data[j+1] = tmp
                flag = true
            end
        end
        break if !flag
    end
    return data
end</pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:paragraph -->
<p>冒泡排序只会<strong>操作相邻的两个数据</strong>。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求。如果不满足就让它俩互换。一次冒泡会让至少一个元素移动到它应该在的位置，重复 n 次，就完成了 n 个数据的排序工作。</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul><li>冒泡的过程只涉及相邻数据的交换操作，只需要常量级的临时空间，所以它的空间复杂度为 <code>O(1)</code>，是一个原地排序算法。</li><li>在冒泡排序中，只有交换才可以改变两个元素的前后顺序。为了保证冒泡排序算法的稳定性，当有相邻的两个元素大小相等的时候，不做交换，相同大小的数据在排序前后不会改变顺序，所以冒泡排序是稳定的排序算法。</li><li>最好情况下，要排序的数据已经是有序的了，只需要进行一次冒泡操作，就可以结束了，所以最好情况时间复杂度是 <code>O(n)</code>。而最坏的情况是，要排序的数据刚好是倒序排列的，我们需要进行 n 次冒泡操作，所以最坏情况时间复杂度为 <code>O(n²)</code>。</li></ul>
<!-- /wp:list -->

<!-- wp:heading {"level":3} -->
<h3>插入排序(Insertion Sort)</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>首先，将数组中的数据分为两个区间，<strong>已排序区间</strong>和<strong>未排序区间</strong>。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>初始已排序区间只有一个元素，就是数组的第一个元素。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>插入算法的核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>重复这个过程，直到未排序区间中元素为空，算法结束。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>插入排序也包含两种操作，一种是元素的比较，一种是元素的移动。当需要将一个数据 a 插入到已排序区间时，需要拿 a 与已排序区间的元素依次比较大小，找到合适的插入位置。找到插入点之后，还需要将插入点之后的元素顺序往后移动一位，腾出位置给元素 a 插入。</p>
<!-- /wp:paragraph -->

<!-- wp:codemirror-blocks/code-block {"mode":"ruby","mime":"text/x-ruby"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre>def insertSort (data)
    len = data.length
        return data if len &lt;= 1
    for i in 1...len
        value = data[i]
        j = i - 1
            until j == 0 do
                if data[j] &gt; value
                    data[j+1] = data[j] # 数据移动
                else
                    break
                end
                j=j-1
            end
            data[j+1] = value # 插入数据
    end
    return data        
end</pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:list -->
<ul><li>插入排序算法的运行并不需要额外的存储空间，所以空间复杂度是 O(1)，也就是说，这是一个原地排序算法。</li><li>在插入排序中，对于值相同的元素，选择将后面出现的元素，插入到前面出现元素的后面，保持原有的前后顺序不变，所以插入排序是稳定的排序算法。</li><li>如果要排序的数据已经是有序的，并不需要搬移任何数据,这种情况下，最好是时间复杂度为 <code>O(n)</code>。注意，这里是从尾到头遍历已经有序的数据。如果数组是倒序的，每次插入都相当于在数组的第一个位置插入新的数据，所以需要移动大量的数据，所以最坏情况时间复杂度为 <code>O(n²)</code>。</li></ul>
<!-- /wp:list -->

<!-- wp:separator {"className":"is-style-wide"} -->
<hr class="wp-block-separator is-style-wide"/>
<!-- /wp:separator -->

<!-- wp:block {"ref":178} /-->

<!-- wp:paragraph -->
<p></p>
<!-- /wp:paragraph -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>375</wp:post_id>
		<wp:post_date><![CDATA[2020-08-06 23:08:11]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2020-08-06 15:08:11]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e6%8e%92%e5%ba%8fsort-%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%8e%e7%ae%97%e6%b3%95]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="ruby"><![CDATA[Ruby]]></category>
		<category domain="post_tag" nicename="%e6%8e%92%e5%ba%8f"><![CDATA[排序]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
		<category domain="category" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%8e%e7%ae%97%e6%b3%95"><![CDATA[数据结构与算法]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[rank_math_primary_category]]></wp:meta_key>
		<wp:meta_value><![CDATA[18]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[rank_math_seo_score]]></wp:meta_key>
		<wp:meta_value><![CDATA[63]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[rank_math_internal_links_processed]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[rank_math_focus_keyword]]></wp:meta_key>
		<wp:meta_value><![CDATA[sort,排序,数据结构,算法]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[rank_math_description]]></wp:meta_key>
		<wp:meta_value><![CDATA[在分析排序算法的时间复杂度时，要分别给出最好情况、最坏情况、平均情况下的时间复杂度，同时还要大概了解一下这些情况下的原始数据的组成。]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>归并排序和快速排序</title>
		<link>https://blog.varsion.cn/?p=392</link>
		<pubDate>Fri, 07 Aug 2020 08:02:45 +0000</pubDate>
		<dc:creator><![CDATA[Varsion]]></dc:creator>
		<guid isPermaLink="false">https://blog.varsion.cn/?p=392</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:block {"ref":187} /-->

<!-- wp:paragraph -->
<p>归并排序和快速排序，这两种排序算法适合大规模的数据排序，时间复杂度均为 <code>O(nlogn)</code>。</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>归并排序</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>如果要排序一个数组，先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就都有序了。</p>
<!-- /wp:paragraph -->

<!-- wp:image {"align":"center"} -->
<div class="wp-block-image"><figure class="aligncenter"><img src="https://static001.geekbang.org/resource/image/db/2b/db7f892d3355ef74da9cd64aa926dc2b.jpg" alt=""/></figure></div>
<!-- /wp:image -->

<!-- wp:paragraph {"fontSize":"medium"} -->
<p class="has-medium-font-size"><strong>算法思路</strong></p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul><li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；</li><li>设定两个指针，最初位置分别为两个已经排序序列的起始位置；</li><li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；</li><li>重复上一步骤直到某一指针达到序列尾；</li><li>将另一序列剩下的所有元素直接复制到合并序列尾</li></ul>
<!-- /wp:list -->

<!-- wp:codemirror-blocks/code-block {"mode":"ruby","mime":"text/x-ruby"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre>def merge (list)
  return list if list.size &lt; 2

  pivot = list.size / 2

  # Merge
  lambda { |left, right|
    final = []
    until left.empty? or right.empty?
      final &lt;&lt; if left.first &lt; right.first; left.shift else right.shift end
    end
    final + left + right
  }.call merge(list[0...pivot]), merge(list[pivot..-1])
end</pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:paragraph {"fontSize":"medium"} -->
<p class="has-medium-font-size"><strong>归并排序的性能分析</strong></p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul><li>归并排序是一个稳定的排序算法</li><li>归并排序不是原地排序算法</li><li>归并排序的执行效率与要排序的原始数组的有序程度无关，所以其时间复杂度是非常稳定的，不管是最好情况、最坏情况，还是平均情况，时间复杂度都是 <code>O(nlogn)</code>。</li><li>临时内存空间最大也不会超过 n 个数据的大小，空间复杂度是 <code>O(n)</code></li></ul>
<!-- /wp:list -->

<!-- wp:heading {"level":3} -->
<h3>快速排序</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>快排利用的也是分治思想。看起来，它有点像归并排序，但是思路其实完全不一样。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>快排的思想是这样的：如果要排序数组中下标从 p 到 r 之间的一组数据，我们选择 p 到 r 之间的任意一个数据作为 pivot（分区点）。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>遍历 p 到 r 之间的数据，将小于 pivot 的放到左边，将大于 pivot 的放到右边，将 pivot 放到中间。经过这一步骤之后，数组 p 到 r 之间的数据就被分成了三个部分，前面 p 到 q-1 之间都是小于 pivot 的，中间是 pivot，后面的 q+1 到 r 之间是大于 pivot 的。</p>
<!-- /wp:paragraph -->

<!-- wp:image {"align":"center"} -->
<div class="wp-block-image"><figure class="aligncenter"><img src="https://static001.geekbang.org/resource/image/4d/81/4d892c3a2e08a17f16097d07ea088a81.jpg" alt=""/></figure></div>
<!-- /wp:image -->

<!-- wp:separator {"className":"is-style-wide"} -->
<hr class="wp-block-separator is-style-wide"/>
<!-- /wp:separator -->

<!-- wp:image -->
<figure class="wp-block-image"><img src="https://static001.geekbang.org/resource/image/aa/05/aa03ae570dace416127c9ccf9db8ac05.jpg" alt=""/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>归并排序的处理过程是由下到上的，先处理子问题，然后再合并。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>而快排正好相反，它的处理过程是由上到下的，先分区，然后再处理子问题。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>归并排序虽然是稳定的、时间复杂度为 O(nlogn) 的排序算法，但是它是非原地排序算法。我们前面讲过，归并之所以是非原地排序算法，主要原因是合并函数无法在原地执行。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>快速排序通过设计巧妙的原地分区函数，可以实现原地排序，解决了归并排序占用太多内存的问题。</p>
<!-- /wp:paragraph -->

<!-- wp:separator {"className":"is-style-wide"} -->
<hr class="wp-block-separator is-style-wide"/>
<!-- /wp:separator -->

<!-- wp:block {"ref":178} /-->

<!-- wp:paragraph -->
<p></p>
<!-- /wp:paragraph -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>392</wp:post_id>
		<wp:post_date><![CDATA[2020-08-07 16:02:45]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2020-08-07 08:02:45]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e5%bd%92%e5%b9%b6%e6%8e%92%e5%ba%8f%e5%92%8c%e5%bf%ab%e9%80%9f%e6%8e%92%e5%ba%8f-%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%8e%e7%ae%97%e6%b3%95]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="ruby"><![CDATA[Ruby]]></category>
		<category domain="post_tag" nicename="%e6%8e%92%e5%ba%8f"><![CDATA[排序]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
		<category domain="category" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%8e%e7%ae%97%e6%b3%95"><![CDATA[数据结构与算法]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[rank_math_seo_score]]></wp:meta_key>
		<wp:meta_value><![CDATA[68]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[rank_math_internal_links_processed]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[rank_math_primary_category]]></wp:meta_key>
		<wp:meta_value><![CDATA[18]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[rank_math_focus_keyword]]></wp:meta_key>
		<wp:meta_value><![CDATA[归并排序,快速排序,数据结构,算法,Ruby]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>二叉树</title>
		<link>https://blog.varsion.cn/?p=579</link>
		<pubDate></pubDate>
		<dc:creator><![CDATA[Varsion]]></dc:creator>
		<guid isPermaLink="false">https://blog.varsion.cn/?p=579</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:block {"ref":187} /-->

<!-- wp:paragraph -->
<p></p>
<!-- /wp:paragraph -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>579</wp:post_id>
		<wp:post_date><![CDATA[2020-09-03 16:22:34]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[0000-00-00 00:00:00]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[]]></wp:post_name>
		<wp:status><![CDATA[draft]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="%e5%85%85%e9%b8%ad%e7%9a%84%e4%bb%8b%e7%bb%8d"><![CDATA[Me]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_primary_category]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_content_score]]></wp:meta_key>
		<wp:meta_value><![CDATA[60]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>CentOS+Apache环境下 Rails部署</title>
		<link>https://blog.varsion.cn/?p=1735</link>
		<pubDate></pubDate>
		<dc:creator><![CDATA[Varsion]]></dc:creator>
		<guid isPermaLink="false">https://blog.varsion.cn/?p=1735</guid>
		<description></description>
		<content:encoded><![CDATA[]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1735</wp:post_id>
		<wp:post_date><![CDATA[2020-12-15 16:56:38]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[0000-00-00 00:00:00]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[]]></wp:post_name>
		<wp:status><![CDATA[draft]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="%e5%85%85%e9%b8%ad%e7%9a%84%e4%bb%8b%e7%bb%8d"><![CDATA[Me]]></category>
						</item>
					<item>
		<title>线性排序</title>
		<link>https://blog.varsion.cn/?p=408</link>
		<pubDate>Sat, 08 Aug 2020 14:28:55 +0000</pubDate>
		<dc:creator><![CDATA[Varsion]]></dc:creator>
		<guid isPermaLink="false">https://blog.varsion.cn/?p=408</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:block {"ref":187} /-->

<!-- wp:paragraph {"align":"center","fontSize":"medium"} -->
<p class="has-text-align-center has-medium-font-size"><strong>基数排序 vs 计数排序 vs 桶排序</strong></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul><li>基数排序：根据键值的每位数字来分配桶；</li><li>计数排序：每个桶只存储单一键值；</li><li>桶排序：每个桶存储一定范围的数值；</li></ul>
<!-- /wp:list -->

<!-- wp:heading {"level":3} -->
<h3>桶排序(Bucket sort)</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>桶排序，顾名思义，会用到“桶”，<strong>核心思想是将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行排序。</strong>桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。</p>
<!-- /wp:paragraph -->

<!-- wp:image {"align":"center"} -->
<div class="wp-block-image"><figure class="aligncenter"><img src="https://static001.geekbang.org/resource/image/98/ae/987564607b864255f81686829503abae.jpg" alt=""/></figure></div>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>排序的数据有 n 个，把它们均匀地划分到 m 个桶内，每个桶里就有 <code>k=n/m</code> 个元素。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>每个桶内部使用快速排序，时间复杂度为 <code>O(k * logk)</code>。m 个桶排序的时间复杂度就是 <code>O(m * k * logk)</code>，因为 <code>k=n/m</code>，所以整个桶排序的时间复杂度就是 <code>O(n*log(n/m))</code>。当桶的个数 m 接近数据个数 n 时，<code>log(n/m)</code> 就是一个非常小的常量，这个时候桶排序的时间复杂度接近 <code>O(n)</code>。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>首先，要排序的数据需要很容易就能划分成 m 个桶，并且，桶与桶之间有着天然的大小顺序。这样每个桶内的数据都排序完之后，桶与桶之间的数据不需要再进行排序。其次，数据在各个桶之间的分布是比较均匀的。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>如果数据经过桶的划分之后，有些桶里的数据非常多，有些非常少，很不平均，那桶内数据排序的时间复杂度就不是常量级了。在极端情况下，如果数据都被划分到一个桶里，那就退化为 <code>O(nlogn)</code> 的排序算法了。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>桶排序比较适合用在外部排序中。所谓的外部排序就是数据存储在外部磁盘中，数据量比较大，内存有限，无法将数据全部加载到内存中。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph {"fontSize":"medium"} -->
<p class="has-medium-font-size"><strong>实现思想</strong></p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>function bucket-sort(array, n) is
  buckets ← new array of n empty lists
  for i = 0 to (length(array)-1) do
    insert array&#91;i] into buckets&#91;msbits(array&#91;i], k)]
  for i = 0 to n - 1 do
    next-sort(buckets&#91;i])
  return the concatenation of buckets&#91;0], ..., buckets&#91;n-1]</code></pre>
<!-- /wp:code -->

<!-- wp:heading {"level":3} -->
<h3>计数排序(Counting sort)</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>计数排序其实是桶排序的一种特殊情况。当要排序的 n 个数据，所处的范围并不大的时候，比如最大值是 k，我们就可以把数据划分成 k 个桶。每个桶内的数据值都是相同的，省掉了桶内排序的时间。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p>
<!-- /wp:paragraph -->

<!-- wp:image {"align":"center","sizeSlug":"large"} -->
<div class="wp-block-image"><figure class="aligncenter size-large"><img src="https://www.runoob.com/wp-content/uploads/2019/03/countingSort.gif" alt="计数排序动画演示"/></figure></div>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>算法思路</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul><li>（1）找出待排序的数组中最大和最小的元素</li><li>（2）统计数组中每个值为<code>i</code>的元素出现的次数，存入数组C的第<code>i</code>项</li><li>（3）对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）</li><li>（4）反向填充目标数组：将每个元素i放在新数组的第<code>C(i)</code>项，每放一个元素就将<code>C(i)</code>减去1</li></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>计数排序只能用在数据范围不大的场景中，如果数据范围 k 比要排序的数据 n 大很多，就不适合用计数排序了。而且，计数排序只能给非负整数排序，如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数。</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>基数排序</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</p>
<!-- /wp:paragraph -->

<!-- wp:image {"align":"center","sizeSlug":"large"} -->
<div class="wp-block-image"><figure class="aligncenter size-large"><img src="https://www.runoob.com/wp-content/uploads/2019/03/radixSort.gif" alt="基数排序动画演示"/></figure></div>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>基数排序对要排序的数据是有要求的，需要可以分割出独立的<strong>“位”</strong>来比较，而且位之间有递进的关系，如果 a 数据的高位比 b 数据大，那剩下的低位就不用比较了。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>除此之外，每一位的数据范围不能太大，要可以用线性排序算法来排序，否则，基数排序的时间复杂度就无法做到 O(n) 了。</p>
<!-- /wp:paragraph -->

<!-- wp:separator {"className":"is-style-wide"} -->
<hr class="wp-block-separator is-style-wide"/>
<!-- /wp:separator -->

<!-- wp:block {"ref":178} /-->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>408</wp:post_id>
		<wp:post_date><![CDATA[2020-08-08 22:28:55]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2020-08-08 14:28:55]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e7%ba%bf%e6%80%a7%e6%8e%92%e5%ba%8f-%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%8e%e7%ae%97%e6%b3%95]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="ruby"><![CDATA[Ruby]]></category>
		<category domain="post_tag" nicename="%e6%8e%92%e5%ba%8f"><![CDATA[排序]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
		<category domain="category" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%8e%e7%ae%97%e6%b3%95"><![CDATA[数据结构与算法]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[rank_math_primary_category]]></wp:meta_key>
		<wp:meta_value><![CDATA[18]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[rank_math_internal_links_processed]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[rank_math_seo_score]]></wp:meta_key>
		<wp:meta_value><![CDATA[68]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[rank_math_focus_keyword]]></wp:meta_key>
		<wp:meta_value><![CDATA[线性排序,数据结构,算法,Ruby]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>排序优化</title>
		<link>https://blog.varsion.cn/?p=421</link>
		<pubDate>Sun, 09 Aug 2020 08:10:30 +0000</pubDate>
		<dc:creator><![CDATA[Varsion]]></dc:creator>
		<guid isPermaLink="false">https://blog.varsion.cn/?p=421</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:block {"ref":187} /-->

<!-- wp:image {"sizeSlug":"large"} -->
<figure class="wp-block-image size-large"><img src="https://www.runoob.com/wp-content/uploads/2019/03/sort.png" alt=""/></figure>
<!-- /wp:image -->

<!-- wp:paragraph {"fontSize":"medium"} -->
<p class="has-medium-font-size"><strong>选择合适的排序算法</strong></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>如果对小规模数据进行排序，可以选择时间复杂度是 <code>O(n2)</code> 的算法</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>如果对大规模数据进行排序，时间复杂度是 <code>O(nlogn)</code> 的算法更加高效。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>为了兼顾任意规模数据的排序，一般都会首选时间复杂度是 <code>O(nlogn)</code> 的排序算法来实现排序函数。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph {"fontSize":"medium"} -->
<p class="has-medium-font-size"><strong>优化快速排序</strong></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>最理想的分区点是：<strong>被分区点分开的两个分区中，数据的数量差不多。</strong></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>1. 三数取中法</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>从区间的首、尾、中间，分别取出一个数，然后对比大小，取这 3 个数的中间值作为分区点。这样每间隔某个固定的长度，取数据出来比较，将中间值作为分区点的分区算法，肯定要比单纯取某一个数据更好。但是，如果要排序的数组比较大，那“三数取中”可能就不够了，可能要“五数取中”或者“十数取中”。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>2. 随机法</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>随机法就是每次从要排序的区间中，随机选择一个元素作为分区点。这种方法并不能保证每次分区点都选的比较好，但是从概率的角度来看，也不大可能会出现每次分区点都选得很差的情况，所以平均情况下，这样选的分区点是比较好的。时间复杂度退化为最糟糕的 <code>O(n²)</code> 的情况，出现的可能性不大。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>快速排序是用递归来实现的。同时，递归要警惕堆栈溢出。为了避免快速排序里，递归过深而堆栈过小，导致堆栈溢出，有两种解决办法：</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>第一种是限制递归深度。一旦递归过深，超过了事先设定的阈值，就停止递归。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>第二种是通过在堆上模拟实现一个函数调用栈，手动模拟递归压栈、出栈的过程，这样就没有了系统栈大小的限制。</p>
<!-- /wp:paragraph -->

<!-- wp:separator {"className":"is-style-wide"} -->
<hr class="wp-block-separator is-style-wide"/>
<!-- /wp:separator -->

<!-- wp:block {"ref":178} /-->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>421</wp:post_id>
		<wp:post_date><![CDATA[2020-08-09 16:10:30]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2020-08-09 08:10:30]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e6%8e%92%e5%ba%8f%e4%bc%98%e5%8c%96-%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e7%ae%97%e6%b3%95]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="ruby"><![CDATA[Ruby]]></category>
		<category domain="post_tag" nicename="%e6%8e%92%e5%ba%8f"><![CDATA[排序]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
		<category domain="category" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%8e%e7%ae%97%e6%b3%95"><![CDATA[数据结构与算法]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[rank_math_primary_category]]></wp:meta_key>
		<wp:meta_value><![CDATA[18]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[rank_math_internal_links_processed]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[rank_math_seo_score]]></wp:meta_key>
		<wp:meta_value><![CDATA[62]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[rank_math_focus_keyword]]></wp:meta_key>
		<wp:meta_value><![CDATA[排序,数据结构,算法,Ruby]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[rank_math_rich_snippet]]></wp:meta_key>
		<wp:meta_value><![CDATA[article]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[rank_math_description]]></wp:meta_key>
		<wp:meta_value><![CDATA[如何选择合适的排序算法]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_wp_old_slug]]></wp:meta_key>
		<wp:meta_value><![CDATA[%e6%8e%92%e5%ba%8f%e4%bc%98%e5%8c%96]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_focuskw]]></wp:meta_key>
		<wp:meta_value><![CDATA[数据结构算法]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_metadesc]]></wp:meta_key>
		<wp:meta_value><![CDATA[如果对小规模数据进行排序，可以选择时间复杂度是 O(n2) 的算法如果对大规模数据进行排序，时间复杂度是 O(nlogn) 的算法更加高效。为了兼顾任意规模数据的排序，一般都会首选时间复杂度是 O(nlogn) 的排序算法来实现排序函数。]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_linkdex]]></wp:meta_key>
		<wp:meta_value><![CDATA[31]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_content_score]]></wp:meta_key>
		<wp:meta_value><![CDATA[90]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>二分查找(Binary Search)</title>
		<link>https://blog.varsion.cn/?p=440</link>
		<pubDate>Tue, 11 Aug 2020 09:57:14 +0000</pubDate>
		<dc:creator><![CDATA[Varsion]]></dc:creator>
		<guid isPermaLink="false">https://blog.varsion.cn/?p=440</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:block {"ref":187} /-->

<!-- wp:paragraph -->
<p>二分查找针对的是一个有序的数据集合，查找思想有点类似分治思想。每次都通过跟区间的中间元素对比，将待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间被缩小为 0。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>二分查找是一种非常高效的查找算法</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>假设数据大小是 n，每次查找后数据都会缩小为原来的一半，也就是会除以 2。最坏情况下，直到查找区间被缩小为空，才停止。</p>
<!-- /wp:paragraph -->

<!-- wp:image {"align":"center"} -->
<div class="wp-block-image"><figure class="aligncenter"><img src="https://static001.geekbang.org/resource/image/d1/94/d1e4fa1542e187184c87c545c2fe4794.jpg" alt=""/></figure></div>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>可以看出来，这是一个等比数列。其中 <code>n/2k=1</code> 时，k 的值就是总共缩小的次数。而每一次缩小操作只涉及两个数据的大小比较，所以，经过了 k 次区间缩小操作，时间复杂度就是 <code>O(k)</code>。通过 <code>n/2k=1</code>，我们可以求得 <code>k=log2n</code>，所以时间复杂度就是 <code>O(logn)</code>。</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>二分查找应用场景的局限性</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p><strong>二分查找依赖的是顺序表结构，简单点说就是数组</strong></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>二分查找算法需要按照下标随机访问元素</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>二分查找只能用在数据是通过顺序表来存储的数据结构上。如果数据是通过其他数据结构存储的，则无法应用二分查找。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><strong>二分查找针对的是有序数据</strong></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>二分查找对这一点的要求比较苛刻，数据必须是有序的。如果数据无序，需要先排序</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>如果针对的是一组静态的数据，没有频繁地插入、删除，我们可以进行一次排序，多次二分查找。这样排序的成本可被均摊，二分查找的边际成本就会比较低。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>如果数据集合有频繁的插入和删除操作，要想用二分查找，要么每次插入、删除操作之后保证数据仍然有序，要么在每次二分查找之前都先进行排序。针对这种动态数据集合，无论哪种方法，维护有序的成本都是很高的。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><strong>数据量太小或者太大都不适合二分查找</strong></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>如果要处理的数据量很小，完全没有必要用二分查找，顺序遍历就足够了。比如在一个大小为 10 的数组中查找一个元素，不管用二分查找还是顺序遍历，查找速度都差不多。只有数据量比较大的时候，二分查找的优势才会比较明显。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>二分查找的底层需要依赖数组这种数据结构，而数组为了支持随机访问的特性，要求内存空间连续，对内存的要求比较苛刻。</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3><strong>总结</strong></h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>有三种方法查找循环有序数组:</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>找到分界下标，分成两个有序数组<br>判断目标值在哪个有序数据范围内，做二分查找<br><br>找到最大值的下标 x;<br>所有元素下标 +x 偏移，超过数组范围值的取模;<br>利用偏移后的下标做二分查找；<br>如果找到目标下标，再作 -x 偏移，就是目标值实际下标。<br>&nbsp;两种情况最高时耗都在查找分界点上，所以时间复杂度是 O(N）。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>循环数组存在一个性质：以数组中间点为分区，会将数组分成一个有序数组和一个循环有序数组</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul><li> 如果首元素小于 mid，说明前半部分是有序的，后半部分是循环有序数组</li><li> 如果首元素大于 mid，说明后半部分是有序的，前半部分是循环有序的数组</li><li> 如果目标元素在有序数组范围中，使用二分查找</li><li> 如果目标元素在循环有序数组中，设定数组边界后，使用以上方法继续查找</li></ul>
<!-- /wp:list -->

<!-- wp:separator {"className":"is-style-wide"} -->
<hr class="wp-block-separator is-style-wide"/>
<!-- /wp:separator -->

<!-- wp:block {"ref":178} /-->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>440</wp:post_id>
		<wp:post_date><![CDATA[2020-08-11 17:57:14]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2020-08-11 09:57:14]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e4%ba%8c%e5%88%86%e6%9f%a5%e6%89%bebinary-search]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="%e4%ba%8c%e5%88%86%e6%b3%95"><![CDATA[二分法]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
		<category domain="category" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%8e%e7%ae%97%e6%b3%95"><![CDATA[数据结构与算法]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[rank_math_internal_links_processed]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_primary_category]]></wp:meta_key>
		<wp:meta_value><![CDATA[18]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_focuskw]]></wp:meta_key>
		<wp:meta_value><![CDATA[二分查找(Binary Search)]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_metadesc]]></wp:meta_key>
		<wp:meta_value><![CDATA[二分查找针对的是一个有序的数据集合，查找思想有点类似分治思想。每次都通过跟区间的中间元素对比，将待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间被缩小为 0。]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_linkdex]]></wp:meta_key>
		<wp:meta_value><![CDATA[32]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_content_score]]></wp:meta_key>
		<wp:meta_value><![CDATA[90]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>跳表(Skip List)</title>
		<link>https://blog.varsion.cn/?p=452</link>
		<pubDate>Wed, 12 Aug 2020 13:57:24 +0000</pubDate>
		<dc:creator><![CDATA[Varsion]]></dc:creator>
		<guid isPermaLink="false">https://blog.varsion.cn/?p=452</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:block {"ref":187} /-->

<!-- wp:heading {"level":3} -->
<h3>如何理解"跳表"</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>对于一个单链表来讲，即便链表中存储的数据是有序的，如果要想在其中查找某个数据，也只能从头到尾遍历链表。这样查找效率就会很低，时间复杂度会很高，是 <code>O(n)</code>。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p></p>
<!-- /wp:paragraph -->

<!-- wp:image {"align":"center"} -->
<div class="wp-block-image"><figure class="aligncenter"><img src="https://static001.geekbang.org/resource/image/e1/6d/e18303fcedc068e5a168de04df956f6d.jpg" alt=""/><figcaption>原始链表</figcaption></figure></div>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>每两个结点提取一个结点到上一级，我们把抽出来的那一级叫做索引或索引层。图中的 down 表示 down 指针，指向下一级结点。</p>
<!-- /wp:paragraph -->

<!-- wp:image -->
<figure class="wp-block-image"><img src="https://static001.geekbang.org/resource/image/14/8e/14753c824a5ee4a976ea799727adc78e.jpg" alt=""/><figcaption>索引</figcaption></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>如果现在要查找某个结点，比如 16。可以先在索引层遍历，当遍历到索引层中值为 13 的结点时，发现下一个结点是 17，那要查找的结点 16 肯定就在这两个结点之间。然后通过索引层结点的 down 指针，下降到原始链表这一层，继续遍历。这个时候，只需要再遍历 2 个结点，就可以找到值等于 16 的这个结点了。这样，原来如果要查找 16，需要遍历 10 个结点，现在只需要遍历 7 个结点。</p>
<!-- /wp:paragraph -->

<!-- wp:image {"align":"center"} -->
<div class="wp-block-image"><figure class="aligncenter"><img src="https://static001.geekbang.org/resource/image/49/65/492206afe5e2fef9f683c7cff83afa65.jpg" alt=""/></figure></div>
<!-- /wp:image -->

<!-- wp:image {"align":"center"} -->
<div class="wp-block-image"><figure class="aligncenter"><img src="https://static001.geekbang.org/resource/image/46/a9/46d283cd82c987153b3fe0c76dfba8a9.jpg" alt=""/><figcaption>多级跳表</figcaption></figure></div>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>这种链表加多级索引的结构，就是跳表。</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>跳表查询的效率</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>假设，每两个结点抽出一个结点作为上一级索引的结点，那第一级索引的结点个数大约就是 n/2，第二级索引的结点个数大约就是 n/4，第三级索引的结点个数大约就是 n/8，依次类推，也就是说，第 k 级索引的结点个数是第 k-1 级索引的结点个数的 1/2，那第 k级索引结点的个数就是 <code>n/(2k)</code>。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>假设索引有 h 级，最高级的索引有 2 个结点。通过上面的公式，我们可以得到 <code>n/(2h)=2</code>，从而求得 <code>h=log2n-1</code>。如果包含原始链表这一层，整个跳表的高度就是 <code>log₂n</code>。我们在跳表中查询某个数据的时候，如果每一层都要遍历 m 个结点，那在跳表中查询一个数据的时间复杂度就是 <code>O(m*logn)</code>。</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>跳表的空间占用</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>比起单纯的单链表，跳表需要存储多级索引，要消耗更多的存储空间。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>假设原始链表大小为 n，那第一级索引大约有 n/2 个结点，第二级索引大约有 n/4 个结点，以此类推，每上升一级就减少一半，直到剩下 2 个结点:</p>
<!-- /wp:paragraph -->

<!-- wp:image {"align":"center"} -->
<div class="wp-block-image"><figure class="aligncenter"><img src="https://static001.geekbang.org/resource/image/10/55/100e9d6e5abeaae542cf7841be3f8255.jpg" alt=""/></figure></div>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>这几级索引的结点总和就是 <code>n/2+n/4+n/8…+8+4+2=n-2</code>。所以，跳表的空间复杂度是 O(n)。也就是说，如果将包含 n 个结点的单链表构造成跳表，我们需要额外再用接近 n 个结点的存储空间。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph {"fontSize":"medium"} -->
<p class="has-medium-font-size"><strong>降低索引占用的内存空间</strong></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>前面都是每两个结点抽一个结点到上级索引,所以，可以每三个结点或五个结点，抽一个结点到上级索引。</p>
<!-- /wp:paragraph -->

<!-- wp:image {"align":"center"} -->
<div class="wp-block-image"><figure class="aligncenter"><img src="https://static001.geekbang.org/resource/image/0b/f7/0b0680ecf500f9349fc142e1a9eb73f7.jpg" alt=""/></figure></div>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>通过等比数列求和公式，总的索引结点大约就是 <code>n/3+n/9+n/27+…+9+3+1=n/2</code>。尽管空间复杂度还是 <code>O(n)</code>，但比上面的每两个结点抽一个结点的索引构建方法，要减少了一半的索引结点存储空间。</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>高效的动态插入和删除</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>跳表这个动态数据结构，不仅支持查找操作，还支持动态的插入、删除操作，而且插入、删除操作的时间复杂度也是 <code>O(logn)</code>。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>对于纯粹的单链表，需要遍历每个结点，来找到插入的位置。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>但是，对于跳表来说，查找某个结点的时间复杂度是 <code>O(logn)</code>，所以这里查找某个数据应该插入的位置，方法也是类似的，时间复杂度也是 <code>O(logn)</code>。</p>
<!-- /wp:paragraph -->

<!-- wp:image {"align":"center"} -->
<div class="wp-block-image"><figure class="aligncenter"><img src="https://static001.geekbang.org/resource/image/65/6c/65379f0651bc3a7cfd13ab8694c4d26c.jpg" alt=""/></figure></div>
<!-- /wp:image -->

<!-- wp:heading {"level":3} -->
<h3>跳表索引的动态更新</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>当我们不停地往跳表中插入数据时，如果我们不更新索引，就有可能出现某 2 个索引结点之间数据非常多的情况。极端情况下，跳表还会退化成单链表。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>作为一种动态数据结构，需要某种手段来维护索引与原始链表大小之间的平衡，也就是说，如果链表中结点多了，索引结点就相应地增加一些，避免复杂度退化，以及查找、插入、删除操作性能下降。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>通过一个随机函数，来决定将这个结点插入到哪几级索引中，比如随机函数生成了值 K，那就将这个结点添加到第一级到第 K 级这 K 级索引中。</p>
<!-- /wp:paragraph -->

<!-- wp:image {"align":"center"} -->
<div class="wp-block-image"><figure class="aligncenter"><img src="https://static001.geekbang.org/resource/image/a8/a7/a861445d0b53fc842f38919365b004a7.jpg" alt=""/></figure></div>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>随机函数的选择很有讲究，从概率上来讲，能够保证跳表的索引大小和数据大小平衡性，不至于性能过度退化。</p>
<!-- /wp:paragraph -->

<!-- wp:separator {"className":"is-style-wide"} -->
<hr class="wp-block-separator is-style-wide"/>
<!-- /wp:separator -->

<!-- wp:block {"ref":178} /-->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>452</wp:post_id>
		<wp:post_date><![CDATA[2020-08-12 21:57:24]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2020-08-12 13:57:24]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e8%b7%b3%e8%a1%a8skip-list]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="ruby"><![CDATA[Ruby]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
		<category domain="category" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%8e%e7%ae%97%e6%b3%95"><![CDATA[数据结构与算法]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<category domain="post_tag" nicename="%e8%b7%b3%e8%a1%a8"><![CDATA[跳表]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_content_score]]></wp:meta_key>
		<wp:meta_value><![CDATA[90]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_primary_category]]></wp:meta_key>
		<wp:meta_value><![CDATA[18]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_metadesc]]></wp:meta_key>
		<wp:meta_value><![CDATA[这种链表加多级索引的结构，就是跳表。]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_focuskw]]></wp:meta_key>
		<wp:meta_value><![CDATA[跳表]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_linkdex]]></wp:meta_key>
		<wp:meta_value><![CDATA[32]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>哈希表(hash table)</title>
		<link>https://blog.varsion.cn/?p=464</link>
		<pubDate>Sat, 15 Aug 2020 03:16:46 +0000</pubDate>
		<dc:creator><![CDATA[Varsion]]></dc:creator>
		<guid isPermaLink="false">https://blog.varsion.cn/?p=464</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:block {"ref":187} /-->

<!-- wp:paragraph -->
<p><strong>散列表用的是数组支持按照下标随机访问数据的特性，所以散列表其实就是数组的一种扩展，由数组演化而来。可以说，如果没有数组，就没有散列表。</strong></p>
<!-- /wp:paragraph -->

<!-- wp:image {"align":"center"} -->
<div class="wp-block-image"><figure class="aligncenter"><img src="https://static001.geekbang.org/resource/image/92/73/92c89a57e21f49d2f14f4424343a2773.jpg" alt=""/></figure></div>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>散列表用的就是数组支持按照下标随机访问的时候，时间复杂度是 O(1) 的特性。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><strong>通过散列函数把元素的键值(key)映射为下标</strong>，然后将数据存储在数组中对应下标的位置。当我们按照键值查询元素时，我们用同样的散列函数，将键值转化数组下标，从对应的数组下标的位置取数据。</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>散列函数</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>散列函数，顾名思义，它是一个函数。可以把它定义成 <code>hash(key)</code>，其中 key 表示元素的键值，hash(key) 的值表示经过散列函数计算得到的散列值。</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4>构造散列函数</h4>
<!-- /wp:heading -->

<!-- wp:list -->
<ul><li>散列函数计算得到的散列值是一个非负整数</li><li>如果 <code>key1 = key2</code>，那 <code>hash(key1) == hash(key2)</code></li><li>如果 <code>key1 ≠ key2</code>，那 <code>hash(key1) ≠ hash(key2)</code></li></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>第三点理解起来可能会有问题。这个要求看起来合情合理，但是在真实的情况下，要想找到一个不同的 key 对应的散列值都不一样的散列函数，几乎是不可能的。即便像业界著名的<code>MD5</code>、<code>SHA</code>、<code>CRC</code>等哈希算法，也无法完全避免这种<strong>散列冲突</strong>。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>而且，因为数组的存储空间有限，也会加大散列冲突的概率。</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>散列冲突</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>开放寻址法（open addressing）和链表法（chaining）</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph {"fontSize":"medium"} -->
<p class="has-medium-font-size"><strong>开放寻址法</strong></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>开放寻址法的核心思想是，如果出现了散列冲突，我们就重新探测一个空闲位置，将其插入。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>线性探测（Linear Probing）</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>当往散列表中插入数据时，如果某个数据经过散列函数散列之后，存储位置已经被占用了，就从当前位置开始，依次往后查找，看是否有空闲位置，直到找到为止。</p>
<!-- /wp:paragraph -->

<!-- wp:image {"align":"center"} -->
<div class="wp-block-image"><figure class="aligncenter"><img src="https://static001.geekbang.org/resource/image/5c/d5/5c31a3127cbc00f0c63409bbe1fbd0d5.jpg" alt=""/></figure></div>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>从图中可以看出，散列表的大小为 10，在元素 x 插入散列表之前，已经 6 个元素插入到散列表中。<code>x</code> 经过 Hash 算法之后，被散列到位置下标为 7 的位置，但是这个位置已经有数据了，所以就产生了冲突。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>于是就顺序地往后一个一个找，看有没有空闲的位置，遍历到尾部都没有找到空闲的位置，于是我们再从表头开始找，直到找到空闲位置 2，于是将其插入到这个位置。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>在散列表中查找元素的过程有点儿类似插入过程。通过散列函数求出要查找元素的键值对应的散列值，然后比较数组中下标为散列值的元素和要查找的元素。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>如果相等，则说明就是我们要找的元素；否则就顺序往后依次查找。如果遍历到数组中的空闲位置，还没有找到，就说明要查找的元素并没有在散列表中。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>散列表跟数组一样，不仅支持插入、查找操作，还支持删除操作。对于使用线性探测法解决冲突的散列表，删除操作稍微有些特别。不能单纯地把要删除的元素设置为空。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>在查找的时候，一旦我们通过线性探测方法，找到一个空闲位置，就可以认定散列表中不存在这个数据。但是，如果这个空闲位置是我们后来删除的，就会导致原来的查找算法失效。本来存在的数据，会被认定为不存在。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>可以将删除的元素，特殊标记为 deleted。当线性探测查找的时候，遇到标记为 deleted 的空间，并不是停下来，而是继续往下探测。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>对于开放寻址冲突解决方法，除了线性探测方法之外，还有另外两种比较经典的探测方法，二次探测（Quadratic probing）和双重散列（Double hashing）。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>所谓二次探测，跟线性探测很像，线性探测每次探测的步长是 1，那它探测的下标序列就是 <code>hash(key)+0，hash(key)+1，hash(key)+2……</code>而二次探测探测的步长就变成了原来的“二次方”，也就是说，它探测的下标序列就是 <code>hash(key)+0，hash(key)+12，hash(key)+22……</code></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>所谓双重散列，意思就是不仅要使用一个散列函数。使用一组散列函数 <code>hash1(key)，hash2(key)，hash3(key)……</code>我们先用第一个散列函数，如果计算得到的存储位置已经被占用，再用第二个散列函数，依次类推，直到找到空闲的存储位置。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>不管采用哪种探测方法，当散列表中空闲位置不多的时候，散列冲突的概率就会大大提高。为了尽可能保证散列表的操作效率，一般情况下，我们会尽可能保证散列表中有一定比例的空闲槽位。用装载因子（load factor）来表示空位的多少。</p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">散列表的装载因子=填入表中的元素个数/散列表的长度</pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<p>装载因子越大，说明空闲位置越少，冲突越多，散列表的性能会下降。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph {"fontSize":"medium"} -->
<p class="has-medium-font-size"><strong>链表法</strong></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>链表法是一种更加常用的散列冲突解决办法，相比开放寻址法，它要简单很多。我们来看这个图，在散列表中，每个“桶（bucket）”或者“槽（slot）”会对应一条链表，所有散列值相同的元素我们都放到相同槽位对应的链表中。</p>
<!-- /wp:paragraph -->

<!-- wp:image {"align":"center"} -->
<div class="wp-block-image"><figure class="aligncenter"><img src="https://static001.geekbang.org/resource/image/a4/7f/a4b77d593e4cb76acb2b0689294ec17f.jpg" alt=""/></figure></div>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>当插入的时候，我们只需要通过散列函数计算出对应的散列槽位，将其插入到对应链表中即可，所以插入的时间复杂度是 <code>O(1)</code>。当查找、删除一个元素时，同样通过散列函数计算出对应的槽，然后遍历链表查找或者删除。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>实际上，这两个操作的时间复杂度跟链表的长度 k 成正比，也就是 <code>O(k)</code>。对于散列比较均匀的散列函数来说，理论上讲，<code>k=n/m</code>，其中 n 表示散列中数据的个数，m 表示散列表中“槽”的个数。</p>
<!-- /wp:paragraph -->

<!-- wp:separator {"className":"is-style-wide"} -->
<hr class="wp-block-separator is-style-wide"/>
<!-- /wp:separator -->

<!-- wp:block {"ref":178} /-->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>464</wp:post_id>
		<wp:post_date><![CDATA[2020-08-15 11:16:46]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2020-08-15 03:16:46]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[hash-table]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="%e5%93%88%e5%b8%8c"><![CDATA[哈希]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
		<category domain="category" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%8e%e7%ae%97%e6%b3%95"><![CDATA[数据结构与算法]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_metadesc]]></wp:meta_key>
		<wp:meta_value><![CDATA[散列表用的是数组支持按照下标随机访问数据的特性，所以散列表其实就是数组的一种扩展，由数组演化而来。可以说，如果没有数组，就没有散列表。]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_content_score]]></wp:meta_key>
		<wp:meta_value><![CDATA[90]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_primary_category]]></wp:meta_key>
		<wp:meta_value><![CDATA[18]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_focuskw]]></wp:meta_key>
		<wp:meta_value><![CDATA[哈希表]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_linkdex]]></wp:meta_key>
		<wp:meta_value><![CDATA[32]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>设计哈希表</title>
		<link>https://blog.varsion.cn/?p=479</link>
		<pubDate>Sun, 16 Aug 2020 12:54:31 +0000</pubDate>
		<dc:creator><![CDATA[Varsion]]></dc:creator>
		<guid isPermaLink="false">https://blog.varsion.cn/?p=479</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:block {"ref":187} /-->

<!-- wp:paragraph -->
<p>哈希列表的查询效率并不能笼统地说成是 O(1)。它跟散列函数、装载因子、散列冲突等都有关系。如果散列函数设计得不好，或者装载因子过高，都可能导致散列冲突发生的概率升高，查询效率下降。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>在极端情况下，有些恶意的攻击者，还有可能通过精心构造的数据，使得所有的数据经过散列函数之后，都散列到同一个槽里。如果我们使用的是基于链表的冲突解决方法，那这个时候，散列表就会退化为链表，查询的时间复杂度就从 O(1) 急剧退化为 O(n)。</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>如何设计散列函数</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>散列函数的设计不能太复杂</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>过于复杂的散列函数，会消耗很多计算时间，会间接地影响到散列表的性能。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>散列函数生成的值要尽可能随机并且均匀分布，这样才能避免或者最小化散列冲突，而且即便出现冲突，散列到每个槽里的数据也会比较平均，不会出现某个槽内数据特别多的情况。</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>如何解决装载因子过大</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>装载因子越大，说明散列表中的元素越多，空闲位置越少，散列冲突的概率就越大。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>不仅插入数据的过程要多次寻址或者拉很长的链，查找的过程也会因此变得很慢。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>对于动态散列表来说，数据集合是频繁变动的，事先无法预估将要加入的数据个数，所以也无法事先申请一个足够大的散列表。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>随着数据慢慢加入，装载因子就会慢慢变大。当装载因子大到一定程度之后，散列冲突就会变得不可接受、不可避免。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>针对哈希表，可以进行动态扩容，重新申请一个更大的空间，并将数据搬移到新的哈希表中。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>假设每次扩容我们都申请一个原来散列表大小两倍的空间。如果原来散列表的装载因子是 0.8，那经过扩容之后，新散列表的装载因子就下降为原来的一半，变成了 0.4。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>对散列表的扩容，数据搬移操作要复杂很多。因为散列表的大小变了，数据的存储位置也变了，所以需要通过散列函数重新计算每个数据的存储位置。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>对于动态散列表，随着数据的删除，散列表中的数据会越来越少，空闲空间会越来越多。如果我们对空间消耗非常敏感，我们可以在装载因子小于某个值之后，启动动态缩容。当然，如果更加在意执行效率，能够容忍多消耗一点内存空间，那就可以不用费劲来缩容了。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>装载因子阈值的设置要权衡时间、空间复杂度。如果内存空间不紧张，对执行效率要求很高，可以降低负载因子的阈值；相反，如果内存空间紧张，对执行效率要求又不高，可以增加负载因子的值，甚至可以大于 1。</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>选择冲突的解决方法</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>两种主要的散列冲突的解决办法，开放寻址法和链表法。</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4>开放寻址法</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>开放寻址法不像链表法，需要拉很多链表。哈希中的数据都存储在数组中，可以有效地利用 CPU 缓存加快查询速度。同时，序列化起来比较简单。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>当数据量比较小、装载因子小的时候，适合采用开放寻址法。</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4>链表法</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>链表法比起开放寻址法，对大装载因子的容忍度更高。开放寻址法只能适用装载因子小于 1 的情况。接近 1 时，就可能会有大量的散列冲突，导致大量的探测、再散列等，性能会下降很多。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>但是对于链表法来说，只要哈希函数的值随机均匀，即便装载因子变成 10，也就是链表的长度变长了而已，虽然查找效率有所下降，但是比起顺序查找还是快很多。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>于链表的散列冲突处理方法比较适合存储大对象、大数据量的哈希表。</p>
<!-- /wp:paragraph -->

<!-- wp:separator {"className":"is-style-wide"} -->
<hr class="wp-block-separator is-style-wide"/>
<!-- /wp:separator -->

<!-- wp:block {"ref":178} /-->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>479</wp:post_id>
		<wp:post_date><![CDATA[2020-08-16 20:54:31]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2020-08-16 12:54:31]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e8%ae%be%e8%ae%a1%e5%93%88%e5%b8%8c%e8%a1%a8]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="%e5%93%88%e5%b8%8c"><![CDATA[哈希]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
		<category domain="category" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%8e%e7%ae%97%e6%b3%95"><![CDATA[数据结构与算法]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_primary_category]]></wp:meta_key>
		<wp:meta_value><![CDATA[18]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_content_score]]></wp:meta_key>
		<wp:meta_value><![CDATA[90]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_focuskw]]></wp:meta_key>
		<wp:meta_value><![CDATA[设计哈希表]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_metadesc]]></wp:meta_key>
		<wp:meta_value><![CDATA[哈希列表的查询效率并不能笼统地说成是 O(1)。它跟散列函数、装载因子、散列冲突等都有关系。如果散列函数设计得不好，或者装载因子过高，都可能导致散列冲突发生的概率升高，查询效率下降。]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_linkdex]]></wp:meta_key>
		<wp:meta_value><![CDATA[32]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>哈希算法</title>
		<link>https://blog.varsion.cn/?p=497</link>
		<pubDate>Mon, 31 Aug 2020 08:53:21 +0000</pubDate>
		<dc:creator><![CDATA[Varsion]]></dc:creator>
		<guid isPermaLink="false">https://blog.varsion.cn/?p=497</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:block {"ref":187} /-->

<!-- wp:paragraph -->
<p>终于忙完手头的事情再次回归到学习中了，hhh。</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>哈希算法</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>将任意长度的二进制值串映射为固定长度的二进制值串，这个映射的规则就是哈希算法，而通过原始数据映射之后得到的二进制值串就是哈希值。</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul><li>从哈希值不能反向推导出原始数据（所以哈希算法也叫单向哈希算法）；</li><li>对输入数据非常敏感，哪怕原始数据只修改了一个 Bit，最后得到的哈希值也大不相同；</li><li>散列冲突的概率要很小，对于不同的原始数据，哈希值相同的概率非常小；</li><li>哈希算法的执行效率要尽量高效，针对较长的文本，也能快速地计算出哈希值。</li></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>哈希算法的应用非常非常多，较为常见的应用是安全加密、唯一标识、数据校验、散列函数、负载均衡、数据分片、分布式存储。</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>安全加密</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>对用于加密的哈希算法来说，有两点格外重要。第一点是很难根据哈希值反向推导出原始数据，第二点是散列冲突的概率要很小。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>第一点好理解，加密的目的就是为了防止原始数据泄露，所以"很难通过哈希值推算出反向推导出原始数据"是一个最基本的要求。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>但是，无论是什么哈希算法，都无法避免散列冲突，只能尽可能的减少碰撞冲突的的概率。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>这里就基于组合数学中一个非常基础的理论，<strong><a href="https://wiki.mbalib.com/wiki/%E9%B8%BD%E5%B7%A2%E5%8E%9F%E7%90%86">鸽巢原理</a></strong>（也叫抽屉原理）。这个原理本身很简单，它是说，如果有 10 个鸽巢，有 11 只鸽子，那肯定有 1 个鸽巢中的鸽子数量多于 1 个，换句话说就是，肯定有 2 只鸽子在 1 个鸽巢内。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>哈希算法产生的哈希值的长度是固定且有限的。比如 MD5 ，哈希值是固定的 128 位二进制串，能表示的数据是有限的，最多能表示 2^128 个数据，而需要哈希算法处理的数据是无穷的。基于鸽巢原理，如果我们对 2^128+1 个数据求哈希值，就必然会存在哈希值相同的情况。这里你应该能想到，一般情况下，哈希值越长的哈希算法，散列冲突的概率越低。</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>
2^128=340282366920938463463374607431768211456</code></pre>
<!-- /wp:code -->

<!-- wp:heading {"level":3} -->
<h3>唯一标识</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>哈希算法可以对大数据做信息摘要，通过一个较短的二进制编码来表示很大的数据。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>比如要在海量的图库中，搜索一张图是否存在，我们不能单纯地用图片的元信息（比如图片名称）来比对，因为有可能存在名称相同但图片内容不同，或者名称不同图片内容相同的情况。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>任何文件在计算中都可以表示成二进制码串，所以，比较笨的办法就是，拿要查找的图片的二进制码串与图库中所有图片的二进制码串一一比对。如果相同，则说明图片在图库中存在。但是，每个图片小则几十 KB、大则几 MB，转化成二进制是一个非常长的串，比对起来非常耗时。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>同时，有一个比较快速的方法：</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>可以给每一个图片取一个唯一标识，或者说信息摘要。比如，可以从图片的二进制码串开头取 100 个字节，从中间取 100 个字节，从最后再取 100 个字节，然后将这 300 个字节放到一块，通过哈希算法（比如 MD5），得到一个哈希字符串，用它作为图片的唯一标识。通过这个唯一标识来判定图片是否在图库中，这样就可以减少很多工作量。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>如果不存在，那就说明这个图片不在图库中；如果存在，再通过散列表中存储的文件路径，获取到这个已经存在的图片，跟现在要插入的图片做全量的比对，看是否完全一样。如果一样，就说明已经存在；如果不一样，说明两张图片尽管唯一标识相同，但是并不是相同的图片。</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>数据校验</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>BT 下载的原理是基于 P2P 协议的。我们从多个机器上并行下载一个 2GB 的电影，这个电影文件可能会被分割成很多文件块（比如可以分成 100 块，每块大约 20MB）。等所有的文件块都下载完成之后，再组装成一个完整的电影文件就行了。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>当然网络传输是不安全的，下载的文件块有可能是被宿主机器恶意修改过的，又或者下载过程中出现了错误，所以下载的文件块可能不是完整的。如果没有能力检测这种恶意修改或者文件下载出错，就会导致最终合并后的电影无法观看，甚至导致电脑中毒。现在的问题是，如何来校验文件块的安全、正确、完整。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>可以通过哈希算法，对这100 个文件块分别取哈希值，并且保存在种子文件中。哈希算法有一个特点，对数据很敏感。只要文件块的内容有一丁点儿的改变，最后计算出的哈希值就会完全不同。所以，当文件块下载完成之后，我们可以通过相同的哈希算法，对下载好的文件块逐一求哈希值，然后跟种子文件中保存的哈希值比对。如果不同，说明这个文件块不完整或者被篡改了。</p>
<!-- /wp:paragraph -->

<!-- wp:separator {"className":"is-style-wide"} -->
<hr class="wp-block-separator is-style-wide"/>
<!-- /wp:separator -->

<!-- wp:block {"ref":178} /-->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>497</wp:post_id>
		<wp:post_date><![CDATA[2020-08-31 16:53:21]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2020-08-31 08:53:21]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e5%93%88%e5%b8%8c%e7%ae%97%e6%b3%95]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="%e5%93%88%e5%b8%8c"><![CDATA[哈希]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
		<category domain="category" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%8e%e7%ae%97%e6%b3%95"><![CDATA[数据结构与算法]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_content_score]]></wp:meta_key>
		<wp:meta_value><![CDATA[90]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_primary_category]]></wp:meta_key>
		<wp:meta_value><![CDATA[18]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_focuskw]]></wp:meta_key>
		<wp:meta_value><![CDATA[哈希算法]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_metadesc]]></wp:meta_key>
		<wp:meta_value><![CDATA[将任意长度的二进制值串映射为固定长度的二进制值串，这个映射的规则就是哈希算法，而通过原始数据映射之后得到的二进制值串就是哈希值。]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_linkdex]]></wp:meta_key>
		<wp:meta_value><![CDATA[34]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>哈希算法（2</title>
		<link>https://blog.varsion.cn/?p=523</link>
		<pubDate>Tue, 01 Sep 2020 02:10:31 +0000</pubDate>
		<dc:creator><![CDATA[Varsion]]></dc:creator>
		<guid isPermaLink="false">https://blog.varsion.cn/?p=523</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:block {"ref":187} /-->

<!-- wp:heading {"level":3} -->
<h3>负载均衡</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>常见的负载均衡算法包括轮询、随机、加权轮询等</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>那么如何实现一个会话粘滞的负载均衡算法。也就是说，需要在同一个客户端，在一次会话中的所有请求路由都同步到同一个服务器上。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>最直接的办法就是维护一张客户端IP地址胡总和会话ID与服务器编号的映射关系的映射关系表。客户端发出的每次请求，都要现在该表中查找应该路由到的服务器编号，然后再请求编号对应的服务器。这是个简单直观的方法，同时也存在几个弊端。</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul><li>如果客户端很多，映射表可能会很大，比较浪费内存空间</li><li>客户端下线、上线，服务器扩容、缩容都会导致映射失效，这样维护映射表的成本就会很大</li></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>哈希算法可以完美的解决这些问题。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>可以通过哈希算法，对客户端IP地址或者会话ID计算哈希值，将得到的哈希值与服务器列表的大小进行去模运算，最终得到的值就是应该被路由到的服务器编号。</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>数据分片</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>假如现在有1T的记录了用户数搜索关键词的日志文件，我们应该如何快速统计出每个关键词的搜索量。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>存在有两个问题，一是搜索日志文件很大，没办法放到一台机器的内存中，二是如果只用一台机器去处理这个工作，时间会很长。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>针对这两个难点，可以先对数据进行分片，然后采用多台机器处理的方法，来提高处理速度。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>具体的思路是这样的：</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>为了提高处理的速度，我们用 n 台机器并行处理。我们从搜索记录的日志文件中，依次读出每个搜索关键词，并且通过哈希函数计算哈希值，然后再跟 n 取模，最终得到的值，就是应该被分配到的机器编号。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>这样，哈希值相同的搜索关键词就被分配到了同一个机器上。也就是说，同一个搜索关键词会被分配到同一个机器上。每个机器会分别计算关键词出现的次数，最后合并起来就是最终的结果。</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>分布式存储</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>现在互联网面对的都是海量的数据、海量的用户。为了提高数据的读取能力和写入能力，一般都采用分布式的而方式来存储数据，比如分布式缓存。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>同时一台缓存机器是肯定不够用的，需要将数据分布在多台机器上。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>可以借用前面数据分片的思想，即通过哈希算法对数据取哈希值，然后对机器个数取模，来根据这个最终值决定存储该数据的缓存机器编号。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>但是，数据增多时就需要再次增加机器，但是不单单应该是简单的增加一台机器。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>假如原来有10台机器，要根据10来取模，原来的数据是通过与 10 来取模的。比如 13 这个数据，存储在编号为 3 这台机器上。但是新加了一台机器中，我们对数据按照 11 取模，原来 13 这个数据就被分配到 2 号这台机器上了。</p>
<!-- /wp:paragraph -->

<!-- wp:image -->
<figure class="wp-block-image"><img src="https://static001.geekbang.org/resource/image/13/7c/138b060ee522cd2eae83c0c31a16bc7c.jpg" alt=""/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>因此，所有的数据都要重新计算哈希值，然后重新搬移到正确的机器上。这样就相当于，缓存中的数据一下子就都失效了。所有的数据请求都会穿透缓存，直接去请求数据库。这样就可能发生<a href="https://zh.wikipedia.org/wiki/%E9%9B%AA%E5%B4%A9%E6%95%88%E5%BA%94" target="_blank" rel="noreferrer noopener">雪崩效应</a>，压垮数据库。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>所以，需要一种方法，使得在新加入一个机器后，并不需要做大量的数据搬移。这时候，<strong>一致性哈希算法</strong>就要登场了。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>假设有 k 个机器，数据的哈希值的范围是[0, MAX]。将整个范围划分成 m 个小区间（m 远大于 k），每个机器负责 m/k 个小区间。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>当有新机器加入的时候，就将某几个小区间的数据，从原来的机器中搬移到新的机器中。这样，既不用全部重新哈希、搬移数据，也保持了各个机器上数据数量的均衡。</p>
<!-- /wp:paragraph -->

<!-- wp:separator {"className":"is-style-wide"} -->
<hr class="wp-block-separator is-style-wide"/>
<!-- /wp:separator -->

<!-- wp:block {"ref":178} /-->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>523</wp:post_id>
		<wp:post_date><![CDATA[2020-09-01 10:10:31]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2020-09-01 02:10:31]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e5%93%88%e5%b8%8c%e7%ae%97%e6%b3%95%ef%bc%882]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="%e5%93%88%e5%b8%8c"><![CDATA[哈希]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
		<category domain="category" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%8e%e7%ae%97%e6%b3%95"><![CDATA[数据结构与算法]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_content_score]]></wp:meta_key>
		<wp:meta_value><![CDATA[90]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_primary_category]]></wp:meta_key>
		<wp:meta_value><![CDATA[18]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_focuskw]]></wp:meta_key>
		<wp:meta_value><![CDATA[哈希算法]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_metadesc]]></wp:meta_key>
		<wp:meta_value><![CDATA[关于哈希算法的部分应用讲解]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_linkdex]]></wp:meta_key>
		<wp:meta_value><![CDATA[29]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>一致性哈希算法原理</title>
		<link>https://blog.varsion.cn/?p=543</link>
		<pubDate>Tue, 01 Sep 2020 08:51:02 +0000</pubDate>
		<dc:creator><![CDATA[Varsion]]></dc:creator>
		<guid isPermaLink="false">https://blog.varsion.cn/?p=543</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:quote -->
<blockquote class="wp-block-quote"><p></p><cite>参考了<a href="https://www.cnblogs.com/lpfuture/p/5796398.html" target="_blank" rel="noreferrer noopener">该文章</a>进行了该算法原理的学习笔记</cite></blockquote>
<!-- /wp:quote -->

<!-- wp:paragraph -->
<p>一致性哈希算法再分布式系统中得到了广泛的应用，这里以mamcached缓存数据库举例。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>mamcached服务器端本身不提供分布式cache的一致性，而是由客户端提供的，具体计算一致性哈希时采用如下步骤：</p>
<!-- /wp:paragraph -->

<!-- wp:list {"ordered":true} -->
<ol><li>首先求出memcached服务器（节点）的哈希值，并将其配置到0～2<sup>32</sup>的圆上。</li><li>然后采用同样的方法求出存储数据的键的哈希值，并映射到相同的圆上。</li><li>然后从数据映射到的位置开始顺时针查找，将数据保存到找到的第一个服务器上。如果超过2<sup>32</sup>仍然找不到服务器，就会保存到第一台memcached服务器上。</li></ol>
<!-- /wp:list -->

<!-- wp:image {"align":"center","id":547,"sizeSlug":"large"} -->
<div class="wp-block-image"><figure class="aligncenter size-large"><img src="http://img.varsion.cn/blog-img/2020/09/498077-20160822172408386-366341651.png" alt="" class="wp-image-547"/></figure></div>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>从上图状态中添加一台服务器。余数分布式算法由于保存键的服务器会发生巨大的变化而影响缓存的命中率，但是一致性哈希中，只有在圆上增加服务器的地点逆时针方向的第一台服务器上的键会受到影响：</p>
<!-- /wp:paragraph -->

<!-- wp:image {"align":"center"} -->
<div class="wp-block-image"><figure class="aligncenter"><img src="https://images2015.cnblogs.com/blog/498077/201608/498077-20160822172431933-546286787.png" alt=""/></figure></div>
<!-- /wp:image -->

<!-- wp:heading -->
<h2>一致性哈希算法的性质</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>考虑到分布式系统每个接待你都有可能失效，并且新的节点很可能动态的增加进来，如何保证当系统的节点数目发生变化时，仍然能够对外提供良好的服务。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>在设计分布式系统的时候，如果某台服务器失效，对于整个系统来说如果不采用合适的算法来保持一致性，那么缓存与系统中的所有数据可能会失效。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>即，由于系统节点数目变少，客户端在请求某一对象时需要从新计算其哈希值，由于哈希值已经改变，所以很可能找不到保存该对象的服务器节点。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>因此，一致性哈希就显得格外重要。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>良好的分布式缓存系统中的一致性哈希算法应满足以下的方面</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul><li><strong>平衡性(Balance)</strong></li></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>平衡性是指哈希的结果能够尽可能分布到所有的缓冲中去，这样可以使得所有的缓冲空间都得到利用。很多哈希算法都能够满足这一条件。</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul><li><strong>单调性(Monotonicity)</strong></li></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>单调性是指如果已经有一些内容通过哈希分派到了相应的缓冲中，又有新的缓冲区加入到系统中，那么哈希的结果应能够保证原有已分配的内容可以被映射到新的缓冲区中去，而不会被映射到旧的缓冲集合中的其他缓冲区。简单的哈希算法往往不能满足单调性的要求，如最简单的线性哈希：x = (ax + b) mod (P)，在上式中，P表示全部缓冲的大小。不难看出，当缓冲大小发生变化时(从P1到P2)，原来所有的哈希结果均会发生变化，从而不满足单调性的要求。哈希结果的变化意味着当缓冲空间发生变化时，所有的映射关系需要在系统内全部更新。而在P2P系统内，缓冲的变化等价于Peer加入或退出系统，这一情况在P2P系统中会频繁发生，因此会带来极大计算和传输负荷。单调性就是要求哈希算法能够应对这种情况。</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul><li><strong>分散性(Spread)</strong></li></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>在分布式环境中，终端有可能看不到所有的缓冲，而是只能看到其中的一部分。当终端希望通过哈希过程将内容映射到缓冲上时，由于不同终端所见的缓冲范围有可能不同，从而导致哈希的结果不一致，最终的结果是相同的内容被不同的终端映射到不同的缓冲区中。这种情况显然是应该避免的，因为它导致相同内容被存储到不同缓冲中去，降低了系统存储的效率。分散性的定义就是上述情况发生的严重程度。好的哈希算法应能够尽量避免不一致的情况发生，也就是尽量降低分散性。</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul><li><strong>负载(Load)</strong></li></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>负载问题实际上是从另一个角度看待分散性问题。既然不同的终端可能将相同的内容映射到不同的缓冲区中，那么对于一个特定的缓冲区而言，也可能被不同的用户映射为不同的内容。与分散性一样，这种情况也是应当避免的，因此好的哈希算法应能够尽量降低缓冲的负荷。</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul><li><strong>平滑性(Smoothness)</strong></li></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>平滑性是指缓存服务器的数目平滑改变和缓存对象的平滑改变是一致的。</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>一致性哈希算法原理概念</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>一致性哈希将整个哈希值空间组织成一个虚拟的圆环，如假设某哈希函数H的值空间为0-2^<sup>32</sup>-1（即哈希值是一个32位无符号整形），整个哈希空间环如下：</p>
<!-- /wp:paragraph -->

<!-- wp:image {"align":"center"} -->
<div class="wp-block-image"><figure class="aligncenter"><img src="https://images2015.cnblogs.com/blog/498077/201608/498077-20160822172453355-790656043.png" alt=""/></figure></div>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>整个空间按顺时针防线组织。0和2<sup>32</sup>-1在零点中方向重合。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>将各个服务器使用Hash进行一个哈希计算，具体可以选择服务器的ip或主机名作为关键字进行哈希，这样每台机器就能确定其在哈希环上的位置，这里假设将四台服务器使用ip地址哈希后在环空间的位置如下：</p>
<!-- /wp:paragraph -->

<!-- wp:image {"align":"center"} -->
<div class="wp-block-image"><figure class="aligncenter"><img src="https://images2015.cnblogs.com/blog/498077/201608/498077-20160822172523808-1567363338.png" alt=""/></figure></div>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>使用如下算法定位数据访问到相应服务器：将数据key使用相同的函数Hash计算出哈希值，并确定此数据在环上的位置，从此位置沿环顺时针“行走”，第一台遇到的服务器就是其应该定位到的服务器。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>例如我们有<code>Object_A</code>,<code>Object_B</code>,<code>Object_C</code>,<code>Object_D</code>四个数据对象，经过哈希计算后，在环空间上的位置如下：</p>
<!-- /wp:paragraph -->

<!-- wp:image {"align":"center","id":563,"sizeSlug":"large"} -->
<div class="wp-block-image"><figure class="aligncenter size-large"><img src="http://img.varsion.cn/blog-img/2020/09/498077-20160822172807745-742859090.png" alt="" class="wp-image-563"/></figure></div>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>根据一致性哈希算法，数据A会被定位到Node A上，B会被定位到Node B上...</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>一致性哈希算法的容错性和可扩展性</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>假设Node_C宕机,可以看到此时ObjectA、B、D并不受影响，只有Object_C被重定位到Node_D。一般的，在一致性哈希算法中，如果一台服务器不可用，则受到影响的数据，仅仅是此服务器到其换空间中前一台服务器，即沿着逆时针方向的第一台服务器，仅仅是这之间的数据，其他则不会受到影响。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>如果在系统中增加一台服务器Node_X，</p>
<!-- /wp:paragraph -->

<!-- wp:image {"align":"center"} -->
<div class="wp-block-image"><figure class="aligncenter"><img src="https://images2015.cnblogs.com/blog/498077/201608/498077-20160822172901526-169091807.png" alt=""/></figure></div>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>此时Object_A,B,D不受影响，只有Object_C需要重新定位到新的Node_X。一般的，在一致性哈希算法中，如果增加一台服务器，则受影响的数据仅仅是新服务器到其环空间中的一小部分数据，即沿着逆时针方向行走遇到的第一台服务器中的数据，其他数据不会受到影响。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>综上，一致性哈希算法对于节点的增减都只需要重定位换空间中的一小部分数据，具有较好的容错性和可拓展性。</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>虚拟节点机制</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>一致性哈希算法在服务节点太少时，容易因为节点分部不均匀而造成数据倾斜问题。例如系统中只有两台服务器，其环分布如下：</p>
<!-- /wp:paragraph -->

<!-- wp:image {"align":"center"} -->
<div class="wp-block-image"><figure class="aligncenter"><img src="https://images2015.cnblogs.com/blog/498077/201608/498077-20160822172922917-1331181630.png" alt=""/></figure></div>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>此时必然造成大量数据集中到Node A上，而只有极少量会定位到Node B上。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>为了解决这种数据倾斜问题，一致性哈希算法引入了<strong>虚拟节点机制</strong>：</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><strong>即对每一个服务节点计算多个哈希，每个计算结果位置都放置一个此服务节点，称为虚拟节点。</strong></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>具体做法可以在服务器ip或主机名的后面增加编号来实现。例如上面的情况，可以为每台服务器计算三个虚拟节点，于是可以分别计算 “Node A#1”、“Node A#2”、“Node A#3”、“Node B#1”、“Node B#2”、“Node B#3”的哈希值，于是形成六个虚拟节点：</p>
<!-- /wp:paragraph -->

<!-- wp:image {"align":"center","id":575,"sizeSlug":"large"} -->
<div class="wp-block-image"><figure class="aligncenter size-large"><img src="http://img.varsion.cn/blog-img/2020/09/498077-20160822172943917-133540408.png" alt="" class="wp-image-575"/></figure></div>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>同时，数据定位算法不变，只是多了一步虚拟节点到实际节点的映射。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>例如定位到“Node A#1”、“Node A#2”、“Node A#3”三个虚拟节点的数据均定位到Node A上。这样就解决了服务节点少时数据倾斜的问题。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>在实际应用中，通常将虚拟节点数设置为32甚至更大，因此即使很少的服务节点也能做到相对均匀的数据分布。</p>
<!-- /wp:paragraph -->

<!-- wp:separator {"className":"is-style-wide"} -->
<hr class="wp-block-separator is-style-wide"/>
<!-- /wp:separator -->

<!-- wp:block {"ref":178} /-->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>543</wp:post_id>
		<wp:post_date><![CDATA[2020-09-01 16:51:02]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2020-09-01 08:51:02]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e4%b8%80%e8%87%b4%e6%80%a7%e5%93%88%e5%b8%8c%e7%ae%97%e6%b3%95%e5%8e%9f%e7%90%86]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="%e5%93%88%e5%b8%8c"><![CDATA[哈希]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
		<category domain="category" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%8e%e7%ae%97%e6%b3%95"><![CDATA[数据结构与算法]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_primary_category]]></wp:meta_key>
		<wp:meta_value><![CDATA[18]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_content_score]]></wp:meta_key>
		<wp:meta_value><![CDATA[90]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_focuskw]]></wp:meta_key>
		<wp:meta_value><![CDATA[一致性哈希算法]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_metadesc]]></wp:meta_key>
		<wp:meta_value><![CDATA[一致性哈希算法再分布式系统中得到了广泛的应用，这里以mamcached缓存数据库举例。mamcached服务器端本身不提供分布式cache的一致性，而是由客户端提供的，具体计算一致性哈希时采用如下步骤：]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_linkdex]]></wp:meta_key>
		<wp:meta_value><![CDATA[31]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>Ruby方法查找</title>
		<link>https://blog.varsion.cn/?p=581</link>
		<pubDate>Wed, 02 Sep 2020 11:55:46 +0000</pubDate>
		<dc:creator><![CDATA[Varsion]]></dc:creator>
		<guid isPermaLink="false">https://blog.varsion.cn/?p=581</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p>每当对象接收到消息的时候，预期的结局就是在对象的类或者超类中，再往上追溯，到达Object甚至BasicObject中，或者在混合到类的模块中，执行与消息同名的方法。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>如果类和混和后的模块中都定义了相同名称的方法，这种发生混淆的例子，对象最终会选择哪个方法执行呢？</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>方法查找的基本原理</h2>
<!-- /wp:heading -->

<!-- wp:codemirror-blocks/code-block {"fileName":"证明模块的包含和继承","mode":"ruby","mime":"text/x-ruby"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre>module M
  def report
    puts &quot;'report' method in module M&quot;
  end
end

class C
  include M
end

class D &lt; C
end

obj = D.new
obj.report</pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:paragraph -->
<p>实例方法<code>report</code>被定义在模块M中，而模块M被混合到了类C中。类D是C的子类，obj是D的一个实例。通过这样的层级关机，对象<code>obj</code>可以访问到<code>report</code>方法。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph {"align":"left"} -->
<p class="has-text-align-left"><strong>方法查找对象视角</strong></p>
<!-- /wp:paragraph -->

<!-- wp:verse -->
<pre class="wp-block-verse">对象Obj，发送了"report"消息，需要在方法查找路径中找到<code>report</code>方法进行调用

<code>Obj</code>是类D的一个实例，D中并没有包含<code>report</code>方法

类D是类C的子类，类C也没有包含<code>report</code>方法

类C中混合了模块M，M中定义了<code>report</code>方法

调用<code>report</code>方法</pre>
<!-- /wp:verse -->

<!-- wp:paragraph -->
<p>最后在搜索结束前，找到了该方法，如果没有找到该方法，则会触发一个错误。错误条件是由<code>method_missing</code>触发</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><strong>方法查找距离</strong></p>
<!-- /wp:paragraph -->

<!-- wp:image {"id":592,"sizeSlug":"large"} -->
<figure class="wp-block-image size-large"><img src="http://img.varsion.cn/blog-img/2020/09/QEHD@B43V@AY_LFABWV.png" alt="" class="wp-image-592"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>按照分布的方式，说明了类D的对象中方法的搜索路径，示例中，在模块M中成功的搜索到了目标。图中，展示了如果方法没有被搜索到，将会搜索更远的距离。当消息<code>report</code>被发送到对象，就开始的方法搜索，如图中箭头所指向的不同类和混合的模块。</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>同名方法的多次定义</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p> 在类中定义一个方法两次，第二次的定义将会取代第一次。这个在模块中也依然如此，其遵循如下规则：</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>在任意指定时间内，针对每一个类和模块仅仅拥有一个同名方法。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>当然对象的法则与类和模块的法则是相似的：在特定的时间，对象仅可以看到一个既定方法中的其中的一个版本。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>假如对象的查找路径中有多个同方法，会执行第一次找到的方法块。</p>
<!-- /wp:paragraph -->

<!-- wp:codemirror-blocks/code-block {"fileName":"单一搜索路径上的两个同名方法","mode":"ruby","mime":"text/x-ruby"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre>module InterestBearing
  	def calculate_interest
      	puts &quot;this is in module&quot;
    end
end

class BankAccount
  include InterestBearing
  def calculate_interest
    puts &quot;this is in class&quot;
  end
end

account = BankAccount.new
account.calculate_interest</pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:paragraph -->
<p>执行结果如下</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>this is in class</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>一个对象在其查找路径中有两个或多个同名方法的另一种情况是：</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>当一个类混合了两个或多个模块时，将搜索到方法的多个实现。这样的例子包含的逆序查找模块，这意味着，最新混合到类中的模块将会最先被搜索到。假如最新被混合的模块中包含一个同名方法，其方法在早先被混合的模块中出现过。最新被混合的模块中的方法版本将会占有最高的优先级，因为其是<strong>最短路径</strong>。</p>
<!-- /wp:paragraph -->

<!-- wp:codemirror-blocks/code-block {"fileName":"混合拥有同名方法的多个模块","mode":"ruby","mime":"text/x-ruby"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre>module M
  def report
    puts&quot;this is M&quot;
  end
end

module N
  def report
    puts &quot;this is N&quot;
  end
end

class C
  include M
  include N
end

obj = C.new
obj.report</pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:paragraph -->
<p>执行结果如下</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>this is N</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>N模块中的<code>report</code>方法是obj在查找路径中命中的最近混合模块中的方法。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>因此模块N中的方法占有最高优先级。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><strong>包含一个模块多次</strong></p>
<!-- /wp:paragraph -->

<!-- wp:codemirror-blocks/code-block {"fileName":"引用一个模块多次","mode":"ruby","mime":"text/x-ruby"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre>class C
  include M
  include N
  include M
end
obj = C.new
obj.report</pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:paragraph -->
<p>但是，该代码块的执行结果仍然是<code>this in N</code></p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>Prepend(前置)的工作原理</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>每次在类中include包含一个模块，都会影响那个类的实例。必须处理对应方法名的消息过程。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>对于<code>prepend</code>来说也是一样的，只不过，如果前置了一个模块在该类中，对象会首先在该模块中查找，而后才是在类中查找</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>查找方法规则</h2>
<!-- /wp:heading -->

<!-- wp:image {"align":"center","id":613,"sizeSlug":"large"} -->
<div class="wp-block-image"><figure class="aligncenter size-large"><img src="http://img.varsion.cn/blog-img/2020/09/image-1.png" alt="" class="wp-image-613"/><figcaption>类D的实例在其方法查找路径中，跨越包含和前置的两个模块进行方法查找</figcaption></figure></div>
<!-- /wp:image -->

<!-- wp:separator {"className":"is-style-wide"} -->
<hr class="wp-block-separator is-style-wide"/>
<!-- /wp:separator -->

<!-- wp:block {"ref":178} /-->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>581</wp:post_id>
		<wp:post_date><![CDATA[2020-09-02 19:55:46]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2020-09-02 11:55:46]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[ruby%e6%96%b9%e6%b3%95%e6%9f%a5%e6%89%be]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="ruby"><![CDATA[Ruby]]></category>
		<category domain="post_tag" nicename="ruby"><![CDATA[Ruby]]></category>
		<category domain="post_tag" nicename="%e6%96%b9%e6%b3%95%e6%9f%a5%e6%89%be"><![CDATA[方法查找]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_primary_category]]></wp:meta_key>
		<wp:meta_value><![CDATA[3]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_content_score]]></wp:meta_key>
		<wp:meta_value><![CDATA[90]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_focuskw]]></wp:meta_key>
		<wp:meta_value><![CDATA[ruby方法查找]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_metadesc]]></wp:meta_key>
		<wp:meta_value><![CDATA[每当对象接收到消息的时候，预期的结局就是在对象的类或者超类中，再往上追溯，到达Object甚至BasicObject中，或者在混合到类的模块中，执行与消息同名的方法。如果类和混和后的模块中都定义了相同名称的方法，这种发生混淆的例子，对象最终会选择哪个方法执行呢？]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_linkdex]]></wp:meta_key>
		<wp:meta_value><![CDATA[36]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>Ruby中Super向上追溯方法路径</title>
		<link>https://blog.varsion.cn/?p=618</link>
		<pubDate>Thu, 03 Sep 2020 07:52:16 +0000</pubDate>
		<dc:creator><![CDATA[Varsion]]></dc:creator>
		<guid isPermaLink="false">https://blog.varsion.cn/?p=618</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p>在方法定义主体中，<code>Super</code>关键字可以在当前执行的方法查找路径的方法中，跳转到下一个高级定义。</p>
<!-- /wp:paragraph -->

<!-- wp:codemirror-blocks/code-block {"fileName":"Super关键字到达查找路径的上一级","mode":"ruby","mime":"text/x-ruby"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre>module M
  def Report
    puts &quot;this is in module M&quot;
  end
end

class C
  include M
  def Report
    puts &quot;this is in class C&quot;
    super
    puts &quot;back from the super call&quot;
  end
end

c = C.new
c.report</pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:paragraph -->
<p>该份代码的输出结果是：</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>this is in class C
this is in module M
back from the super call</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>一个C的实例接收到了<code>report</code>消息，方法查找过程将会从类C开始，非常肯定这里是有一个<code>Report</code>方法，并且被执行了。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>在方法内部有一个<code>super</code>调用，这说明即使对象找到了一个方法去响应该消息，也必须去继续搜索和查找以进行下一次匹配。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p> 如果类C中不存在该方法，那么模块M中的<code>report</code>方法将会首先被匹配到。如果某个合适版本的方法在查找路径的后期被覆盖，<code>super</code>关键字提供了一种调用这个方法的方式。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>有时，在编写一个子类的时候，存在类中的一个方法的功能已经几乎满足了用户的期望。但也不完全是这样，使用<code>super</code>可以同时拥有钩子和包装原始方法机制。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>同时<code>super</code>处理传递参数的方式如下：</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul><li>无参数列表调用<code>super</code>自动转发被调用的方法的实参</li><li>空参数列表调用<code>super()</code>不传递参数到更高一级的调用中。即使当前方法接受了传参</li><li>指定参数的调用<code>super(a,b,c)</code>精准转发这些参数</li></ul>
<!-- /wp:list -->

<!-- wp:separator {"className":"is-style-wide"} -->
<hr class="wp-block-separator is-style-wide"/>
<!-- /wp:separator -->

<!-- wp:block {"ref":178} /-->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>618</wp:post_id>
		<wp:post_date><![CDATA[2020-09-03 15:52:16]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2020-09-03 07:52:16]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[ruby%e4%b8%adsuper%e5%90%91%e4%b8%8a%e8%bf%bd%e6%ba%af%e6%96%b9%e6%b3%95%e8%b7%af%e5%be%84]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="ruby"><![CDATA[Ruby]]></category>
		<category domain="post_tag" nicename="ruby"><![CDATA[Ruby]]></category>
		<category domain="post_tag" nicename="super%e6%96%b9%e6%b3%95%e5%9b%9e%e6%ba%af"><![CDATA[Super方法回溯]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_primary_category]]></wp:meta_key>
		<wp:meta_value><![CDATA[3]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_content_score]]></wp:meta_key>
		<wp:meta_value><![CDATA[90]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_focuskw]]></wp:meta_key>
		<wp:meta_value><![CDATA[Ruby中的Super方法向上追溯]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_metadesc]]></wp:meta_key>
		<wp:meta_value><![CDATA[在方法定义主体中，Super关键字可以在当前执行的方法查找路径的方法中，跳转到下一个高级定义。]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_linkdex]]></wp:meta_key>
		<wp:meta_value><![CDATA[24]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>Ruby-迭代器和代码块</title>
		<link>https://blog.varsion.cn/?p=636</link>
		<pubDate>Mon, 07 Sep 2020 07:15:53 +0000</pubDate>
		<dc:creator><![CDATA[Varsion]]></dc:creator>
		<guid isPermaLink="false">https://blog.varsion.cn/?p=636</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:code -->
<pre class="wp-block-code"><code>loop {puts "loop forever" }</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p><code>loop</code>是一个迭代器，是一种方法。他在调用的语法上附加了一个条件：需要额外提供一个代码块。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><code>loop</code>方法访问了在代码块中的代码：方法可以调用执行该代码块。为了在迭代器中实现它，可以使用关键字<code>yield</code>。代码块(由调用代码提供)和<code>yield</code>(从方法内部调用)一同作为调用的主要条件。</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>迭代</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p><code>loop</code>的任务是为了把控制教改代码块，然后不断的循环。</p>
<!-- /wp:paragraph -->

<!-- wp:codemirror-blocks/code-block {"fileName":"my_loop","mode":"ruby","mime":"text/x-ruby"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre>def my_loop
  while true
    yield
  end
end
# 或者更简短的方式
def my_loop
  yield while true
end</pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:paragraph -->
<p>然后就可以像调用<code>loop</code>一样使用<code>my_loop</code></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>提供一个代码块给<code>my_loop</code>方法，就能交出控制权(yield)。当方法的控制权交给代码块，其中的代码运行完毕之后，控制权会立刻返回到方法中调用<code>yield</code>的的地方。</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>解析方法调用</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Ruby中的每个方法调用都遵循一下的语法：</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul><li>接收者对象或者变量（如果缺少则默认为self</li><li>点（假如有明确的接收者则为必要条件，不允许其他情况</li><li>方法名（必要</li><li>参数列表（可选，默认为<code>()</code></li><li>代码块（可选，没有默认</li></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>要注意的是，参数列表和代码块是分离的，他们是独立变化的个体，如下有部分实例</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>loop { puts "Hi"}
loop() { puts "Hi"}
string.scan(/&#91;^,]+/)
string.scan(/&#91;^,]+/) { |word| puts word}</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>方法调用有没有代码块的区别在于方法内部是否有<code>yield</code>子句可以调用。如果有代码块，则可以调用，如果没有则不能。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><strong>假如将代码块作为方法调用的语法元素而不是作为参数来考虑，那么就能够对以迭代为基础的更多变化有更清晰的思路。</strong></p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2><code>Times</code>方法</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p><code>times</code>方法是一个<code>Integer</code>类的实例方法，这意味着可以在整型对象上调用它，根据整型的数值n来运行n次代码，并在方法的结尾返回数值n。</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>5.times { |i| puts "this is the #{i} times"}</code></pre>
<!-- /wp:code -->

<!-- wp:image {"align":"center","id":653,"sizeSlug":"large"} -->
<div class="wp-block-image"><figure class="aligncenter size-large"><img src="http://img.varsion.cn/blog-img/2020/09/image-2.png" alt="" class="wp-image-653"/></figure></div>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p><code>times</code>的行为说明了一个很美好的事实：使用<code>yield</code>运行一个代码块和从方法返回值是截然不同的事情。一个方法可以从0到无限多次调用他的<code>yield</code>语句。但是每次方法完成所有事情后，他将会严格的返回一次（确保没有错误的情况下）。</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>从<code>each</code>方法到<code>map</code>方法</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p><code>each</code>方法很简单：在集合对象上运行<code>each</code>方法，他把集合中的元素逐个的去除传递给代码块。Ruby中有很多集合类，甚至像一些很像集合的类都支持<code>each</code>方法。</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>array = &#91;1,2,3,4,5]
text = array.each { |i| puts "we got #{i}"}
print text</code></pre>
<!-- /wp:code -->

<!-- wp:image {"align":"center","id":658,"sizeSlug":"large"} -->
<div class="wp-block-image"><figure class="aligncenter size-large"><img src="http://img.varsion.cn/blog-img/2020/09/image-4.png" alt="" class="wp-image-658"/></figure></div>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>同时，<code>each</code>方法没有返回值，但是他会因为自身将取出的值传递给<code>block</code>，每取一次就会产生一个值。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>和<code>each</code>方法类似的是<code>map</code>方法，<code>map</code>方法一次遍历数组的一个元素，然后传递给代码块。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>不同的地方在于，<code>each</code>方法返回它的接收者，<code>map</code>方法返回一个新数组。新数组的大小和原来的一致，但是元素和原始元素不同，新数组包含的元素由迭代代码块的返回值构成：</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>array = &#91;1,2,3,4,5]
text = array.map {|i| i*10}
print text</code></pre>
<!-- /wp:code -->

<!-- wp:image {"align":"center","id":665,"sizeSlug":"large"} -->
<div class="wp-block-image"><figure class="aligncenter size-large"><img src="http://img.varsion.cn/blog-img/2020/09/image-5.png" alt="" class="wp-image-665"/></figure></div>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>新数组的映射结果中，其每一个元素都对应在原始数组的相同位置，只是经过了代码的处理。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>在迭代分析过程中使用<code>map</code>是考虑到代码会返回一个值给调用它的方法，虽然仅只有方法可以调用<code>yield</code>并传递一个值，但是代码块能返回一个值，这个返回值作为调用<code>yield</code>的值返回。</p>
<!-- /wp:paragraph -->

<!-- wp:separator {"className":"is-style-wide"} -->
<hr class="wp-block-separator is-style-wide"/>
<!-- /wp:separator -->

<!-- wp:block {"ref":178} /-->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>636</wp:post_id>
		<wp:post_date><![CDATA[2020-09-07 15:15:53]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2020-09-07 07:15:53]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[ruby-%e8%bf%ad%e4%bb%a3%e5%99%a8%e5%92%8c%e4%bb%a3%e7%a0%81%e5%9d%97]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="ruby"><![CDATA[Ruby]]></category>
		<category domain="post_tag" nicename="ruby"><![CDATA[Ruby]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_primary_category]]></wp:meta_key>
		<wp:meta_value><![CDATA[3]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_content_score]]></wp:meta_key>
		<wp:meta_value><![CDATA[90]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_focuskw]]></wp:meta_key>
		<wp:meta_value><![CDATA[Ruby迭代器]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_metadesc]]></wp:meta_key>
		<wp:meta_value><![CDATA[loop方法访问了在代码块中的代码：方法可以调用执行该代码块。为了在迭代器中实现它，可以使用关键字yield。代码块(由调用代码提供)和yield(从方法内部调用)一同作为调用的主要条件]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_linkdex]]></wp:meta_key>
		<wp:meta_value><![CDATA[27]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>Ruby错误处理和异常</title>
		<link>https://blog.varsion.cn/?p=676</link>
		<pubDate>Wed, 09 Sep 2020 06:53:15 +0000</pubDate>
		<dc:creator><![CDATA[Varsion]]></dc:creator>
		<guid isPermaLink="false">https://blog.varsion.cn/?p=676</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:heading -->
<h2>引发和捕获异常</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>异常(exception)是一种特殊对象。是<code>Exception</code>类或者子类的实例。引发一个异常意味着停止程序的正常执行，之后要么处理初心的问题，要么完全退出程序。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>处理问题还是退出程序，取决于是否使用了<code>rescue</code>子句。如果程序中有该子句，程序控制流将会移交该子句控制。</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2><code>rescue</code>关键字</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>引发异常并不意味着程序的终结。可以对异常进行处理，处理发生的问题并保持程序的运行。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><code>rescue</code>代码段用于挽救关键程序，它被限定于<code>begin</code>和<code>end</code>关键字的范围，并在中间的位置放置一个<code>rescue</code>子句</p>
<!-- /wp:paragraph -->

<!-- wp:codemirror-blocks/code-block {"mode":"ruby","mime":"text/x-ruby"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre>print &quot;Enter a number&quot;
n = gets.to_i
begin
  result = 100 / n
rescue
  puts &quot;Error Number,was it 0?&quot;
  exit
end
puts &quot;100/#{n} is #{result}&quot;</pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:paragraph -->
<p>如果这段程序输入0，除法运算 100 / 0 会引发<code>ZeroDivisionError</code>异常，由于已经在<code>begin/end</code>中包含了一个<code>rescue</code>语句，控制流能顺利转入<code>rescue</code>语句。错误信息会被打印输出，而后程序正常退出</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>假如输入的是0以外的数据,运算将会成功,程序控制也将会跳过<code>rescue</code>语句,然后在那之后将会恢复执行.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><code>begin/end</code>的存在是为了限制<code>rescue</code>的控制粒度(细腻程度).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>如果在一个方法中没有使用<code>begin/end</code>进行包装,就容易对整个方法的所有代码进行异常控制,控制粒度不明确,会引发不必要的麻烦.</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>显示的引发异常</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>为了引发一个异常,可以使用<code>raise</code>加上想要引发的异常的名称.加入没有提供异常的名称(并且加入没有重新引发一个不同的异常)Ruby则会引发一个通用的<code>RuntimeError</code></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>也可以给<code>raise</code>指定第二个参数,他被用于在异常引发是的说明信息</p>
<!-- /wp:paragraph -->

<!-- wp:codemirror-blocks/code-block {"mode":"ruby","mime":"text/x-ruby"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre>def Hello
  raise NameError,&quot;go out&quot;
end</pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:heading -->
<h2>捕获异常</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>为了将异常对象赋值给一个变量,可以配合<code>rescue</code>指令使用特殊的操作符<code>=></code></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>异常对象如其他对象一样可以相应消息,尤其有用的是<code>backtrace</code>和<code>message</code>方法</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul><li><code>backtrace</code>可以返回一个字符串数组,用于表示异常出发时的调用栈:它包括方法名称,文件名和代码行数,并展示了异常发生时代码执行的整个路线图.</li><li>只要信息存在<code>message</code>方法就可以返回在<code>raise</code>提供的信息</li></ul>
<!-- /wp:list -->

<!-- wp:codemirror-blocks/code-block {"mode":"ruby","mime":"text/x-ruby"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre>...
  rescue ArfumentError =&gt; e
	puts e.backtrace
	puts e.message
...</pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:heading {"level":3} -->
<h3>被引发的是一个异常还是一个异常类?</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>在编程的角度上,异常触发的是类:使用<code>raise ZeroDivisionError</code>而不是<code>raise ZeroDivisionError.new</code></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>但实际上是异常类的实例被引发了.这个语法引发了一个类,因为那笔实例化看起来更为贴切和抽象,假如在<code>rescue</code>子句中测试自己捕获的异常对象,可以看到类和实例中的关系是断开的.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>不适用<code>new</code>也达到了相同的效果,并使得代码有一个较高层次的样式,以提供足够的信息里展示代码余小宁的过程,从而不必关心其操作的细节.</p>
<!-- /wp:paragraph -->

<!-- wp:separator {"className":"is-style-wide"} -->
<hr class="wp-block-separator is-style-wide"/>
<!-- /wp:separator -->

<!-- wp:block {"ref":178} /-->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>676</wp:post_id>
		<wp:post_date><![CDATA[2020-09-09 14:53:15]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2020-09-09 06:53:15]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[ruby%e9%94%99%e8%af%af%e5%a4%84%e7%90%86%e5%92%8c%e5%bc%82%e5%b8%b8]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="ruby"><![CDATA[Ruby]]></category>
		<category domain="post_tag" nicename="ruby"><![CDATA[Ruby]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_primary_category]]></wp:meta_key>
		<wp:meta_value><![CDATA[3]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_content_score]]></wp:meta_key>
		<wp:meta_value><![CDATA[90]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_focuskw]]></wp:meta_key>
		<wp:meta_value><![CDATA[Ruby]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_metadesc]]></wp:meta_key>
		<wp:meta_value><![CDATA[异常(exception)是一种特殊对象。是Exception类或者子类的实例。引发一个异常意味着停止程序的正常执行，之后要么处理初心的问题，要么完全退出程序。]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_linkdex]]></wp:meta_key>
		<wp:meta_value><![CDATA[25]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>Ruby - 深入理解Symbol</title>
		<link>https://blog.varsion.cn/?p=686</link>
		<pubDate>Sun, 13 Sep 2020 08:20:14 +0000</pubDate>
		<dc:creator><![CDATA[Varsion]]></dc:creator>
		<guid isPermaLink="false">https://blog.varsion.cn/?p=686</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p> 符号(symbol)是Ruby内置类<code>Symbol</code>中的实例。它拥有一个字面构造器：冒号引导符，可以通过这个记号，从字面上辨认出符号与字符串、变量名、方法名等等的区别。</p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">:a
:book
:"This is Chongya"</pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<p>也可以通过程序的方式，在字符串上调用<code>to_sym</code>方法也可以通过类似的<code>intern</code>方法来创建一个符号：</p>
<!-- /wp:paragraph -->

<!-- wp:codemirror-blocks/code-block {"mode":"ruby","mime":"text/x-ruby"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre>&quot;a&quot;.to_sym
&quot;This is Chongya&quot;.intern</pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:paragraph -->
<p>同时可以通过<code>to_s</code>方法，轻松的将符号转换为字符串。</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>符号的主要特点</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>符号不想其他任何东西，在某些方面。他更像字符串，同时，又更像整形，主要特点是<strong>唯一性</strong>、<strong>不变性。</strong></p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>符号的不变性</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>符号是不可变的，不能添加字符，一旦字符存在，就不能修改，更不存在<code>:abc &lt;&lt; :d</code>或者类似的方法。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>这并不是说<code>:adcd</code>不存在，而是，我们不能改变<code>:abc</code>本身，让其追加一个<code>:d</code>，从而让其变成<code>:adcd</code>。如同整形一样，符号不能被改变。如果想要引入整数<code>5</code>，不能通过将对象<code>4</code>本身加上1来得到它，尽管可以通过调用<code>4.+(1)</code>来给4加上1，但是不能使得<code>object 4</code> 变成<code>object 5</code>。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>相似的，尽管可以使用一个符号座位Ruby生成另外一个符号的条件，但是并不能修改指定的符号。因为。符号是一个完完全全的对象</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>符号的唯一性</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>符号是唯一的，无论何时看到<code>:abc</code>，看到的都是同一个对象。在这个方面相比，较字符串而言，更像是个整形。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>当看到表示法<code>"abc"</code>出现在两个地方，他们表述的是两个字符穿对象，因为字符串构造器<code>""</code>创建了新的字符穿串。但是<code>:abc</code>总是表示相同的<code>Symbol</code>对象。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>通过查询用于表示每个独立对象唯一性<code>object_id</code>就可以发现，在唯一性上的不同。</p>
<!-- /wp:paragraph -->

<!-- wp:image {"align":"center","id":696,"sizeSlug":"large"} -->
<div class="wp-block-image"><figure class="aligncenter size-large"><img src="http://img.varsion.cn/blog-img/2020/09/image-6.png" alt="" class="wp-image-696"/></figure></div>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>正因为符号是唯一的，所有他并没有构造器，也没有提供<code>Symbol # new</code>方法，用户创建一个符号所做的事情，并没有创建一个整形复杂。在任何情况下，都只能是引用该符号而已。</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>符号和标识符</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>下面的代码包含了一个<code>Symbol</code>对象和已发个本地变量标识符。</p>
<!-- /wp:paragraph -->

<!-- wp:codemirror-blocks/code-block {"mode":"ruby","mime":"text/x-ruby"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre>s = :a</pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:paragraph -->
<p>将<code>s</code>引用为一个符号的情况是很常见的。它作为一个符号，所代表的一起除了他本身就没有更多了。而事实上，围绕着<code>Symbol</code>类和符号对象让人困惑的潜在因素是:<strong>符号不能代表除了自己以外的更多事物。</strong></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><strong>从某种意义上来说，一个变量名更多的是"符号性"的而不是一个符号。</strong></p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>符号与实践</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>符号最常见的用法是<strong>方法参数</strong>和<strong>哈希表</strong>。</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>符号作为方法参数</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>大量核心的Ruby方法都使用符号作为方法参数，这些方法中的大多数也可以使用字符串作为方法参数。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>例如<code>attr_*</code>的方法</p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">attr_accessor :name
attr_reader :age</pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<p>通常<code>send</code>方法用符号作为参数，可以不使用点运算符就能发送消息给对象</p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">"abc".send(:upcase)</pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<p>如果事先知道完整的方法名称，一般情况不需要<code>send</code>方法。但是这里要注意的是，<code>send</code>方法可以带有一个符号参数，即使这个符号参数存储在一个变量值，或者是运行时动态确定的，该符号依然可用。</p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted"><strong>思考允许符号或者字符串作为方法参数</strong>
编写一个需要携带参数的方法时，可能会思考参数应该使用字符串或者符号，通常最好是两这都可以。
在大多数处理由用户产生的内容以及任意的字符串的时候，或者从文件中读取所包含文本的时候，是没必要这样的，这些内容不会以符号的形式出现。
但如有一个方法，他期待的参数是一个方法名或者也许是从商标或者标签的有限列表中找到的一个值，那么最好是同时允许字符串和符号的使用。
这样可以不用要求参数对象的类型必须是其中一种，并且可以避免由错误的传参而导致的错误。</pre>
<!-- /wp:preformatted -->

<!-- wp:heading {"level":3} -->
<h3>符号作为哈希键值</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>哈希是使用键读取的数据结构：将一个值赋给一个键然后插入其中，然后通过值的引用的键取回该值。Ruby对哈希键没有任何限制。可以使用数组、类、另一个哈希、字符串或者任意想要作为哈希键的对象。但是大多情况会使用字符串或者符号。</p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">hosts{
       'beijing' =&gt; 'machine1',
       'shanghai'  =&gt; 'machine2',
       'guangzhou' =&gt; 'machine3',
       'tianjin' =&gt;  'machine4',
       'shenzhen' =&gt;　'machine5'
}</pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<p>　如果要引用 <code>beijing</code> 的机器，使用 <code>hosts['beijing']</code> 。但如果我们程序中要频繁引用哈希表中 value ，这样就不大好了，因为 Ruby 对每一次字符串引用都会生成一个 String 对象，累积下来这个开销是相当大的。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>我们完全可以使用 Symbol ，因为对于这些 key 来讲，我们用的就是名字而已，例如下面<code>hosts[:beijing]</code></p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">hosts　=　{
　:beijing　=&gt;　'machine1',
　:shanghai　=&gt;　'machine2',
　:guangzhou　=&gt;　'machine3',
　:tianjin 　=&gt;　'machine4',
　:shenzhen　=&gt;　'machine5'
}</pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<p>如果使用字符串作为散列键没什么问题，尤其是已经有一个字符串集合，需要将他纳入一个散列是，但是使用符号的散列键也有一些优势：</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul><li>Ruby处理符号更快，因此如果要大量处理散列查找的话，就会节省很多时间</li><li>符号作为散列键看起来会更好一些。</li></ul>
<!-- /wp:list -->

<!-- wp:separator {"className":"is-style-wide"} -->
<hr class="wp-block-separator is-style-wide"/>
<!-- /wp:separator -->

<!-- wp:block {"ref":178} /-->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>686</wp:post_id>
		<wp:post_date><![CDATA[2020-09-13 16:20:14]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2020-09-13 08:20:14]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[ruby-%e6%b7%b1%e5%85%a5%e7%90%86%e8%a7%a3symbol]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="ruby"><![CDATA[Ruby]]></category>
		<category domain="post_tag" nicename="ruby"><![CDATA[Ruby]]></category>
		<category domain="post_tag" nicename="symbol"><![CDATA[Symbol]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_primary_category]]></wp:meta_key>
		<wp:meta_value><![CDATA[3]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_content_score]]></wp:meta_key>
		<wp:meta_value><![CDATA[90]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_focuskw]]></wp:meta_key>
		<wp:meta_value><![CDATA[Ruby Symbol]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_metadesc]]></wp:meta_key>
		<wp:meta_value><![CDATA[符号(symbol)是Ruby内置类Symbol中的实例。它拥有一个字面构造器：冒号引导符，可以通过这个记号，从字面上辨认出符号与字符串、变量名、方法名等等的区别。]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_linkdex]]></wp:meta_key>
		<wp:meta_value><![CDATA[27]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>Ruby - 默认哈希值行为</title>
		<link>https://blog.varsion.cn/?p=719</link>
		<pubDate>Tue, 15 Sep 2020 01:31:02 +0000</pubDate>
		<dc:creator><![CDATA[Varsion]]></dc:creator>
		<guid isPermaLink="false">https://blog.varsion.cn/?p=719</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p>默认情况下，如果我们使用不存在的键值去请求哈希时，会得到nil</p>
<!-- /wp:paragraph -->

<!-- wp:image {"align":"center","id":722,"sizeSlug":"large"} -->
<div class="wp-block-image"><figure class="aligncenter size-large"><img src="http://img.varsion.cn/blog-img/2020/09/image-7.png" alt="" class="wp-image-722"/></figure></div>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>但是，如果我们给<code>Hash</code>指定了默认值</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>h = Hash.new(0)</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>代码中初始化哈希的默认值为0，当使用一个不存在的键时，就会返回该默认值（也可以使用<code>defalut</code>方法为已存在的哈希设置默认值）</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>重要的是：无论指定什么作为默认值，都会在使用不存在的键时获得该值，该键都会一直维持不存在的而窗体，知道为他分配一个值。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>换句话说调用<code>User["Chongya"]</code>并不意味着<code>User</code>现在有了<code>Chongya</code>这个键。如果想要在哈希中使用这个键，就必须把这个键放到哈希中。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>如果要引入一个不存在的键，然后使其变为存在哈希中的键，那么<code>Hash.new</code>上英语一个代码块可以达到此目的。这个代码块会在每次不存在的键被引用的时候被执行。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>有两个对象将会作为这个代码块的参数，分别是哈希和不存在的键。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>这可以自动设置键值，但是这并不是Ruby中的优雅的用法，但是的确有用（虽然不怎么好，但是的确好用），并足以编写一个可以抓取到哈希和键的代码块，然后执行设置操作：</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>user = Hash.new {|hash,key| hash&#91;key] =  visitor}</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>当一个不存在的用户访问<code>user</code>的以判断他的身份的时候，代码块参数，就会将其的值设置为<code>visitor</code>（访客）并将其添加到<code>user</code>自身。</p>
<!-- /wp:paragraph -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>719</wp:post_id>
		<wp:post_date><![CDATA[2020-09-15 09:31:02]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2020-09-15 01:31:02]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[ruby-%e9%bb%98%e8%ae%a4%e5%93%88%e5%b8%8c%e5%80%bc%e8%a1%8c%e4%b8%ba]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="ruby"><![CDATA[Ruby]]></category>
		<category domain="post_tag" nicename="ruby"><![CDATA[Ruby]]></category>
		<category domain="post_tag" nicename="%e5%93%88%e5%b8%8c"><![CDATA[哈希]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_primary_category]]></wp:meta_key>
		<wp:meta_value><![CDATA[3]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_content_score]]></wp:meta_key>
		<wp:meta_value><![CDATA[90]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_focuskw]]></wp:meta_key>
		<wp:meta_value><![CDATA[哈希默认值]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_metadesc]]></wp:meta_key>
		<wp:meta_value><![CDATA[默认情况下，如果我们使用不存在的键值去请求哈希时，会得到nil]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_linkdex]]></wp:meta_key>
		<wp:meta_value><![CDATA[27]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>Ruby - 具名参数</title>
		<link>https://blog.varsion.cn/?p=728</link>
		<pubDate>Wed, 16 Sep 2020 07:12:05 +0000</pubDate>
		<dc:creator><![CDATA[Varsion]]></dc:creator>
		<guid isPermaLink="false">https://blog.varsion.cn/?p=728</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:codemirror-blocks/code-block {"fileName":"具名参数","mode":"ruby","mime":"text/x-ruby"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre>def func(a:,b:)
  puts a,b
end

func(a:1,b:2)</pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:image {"align":"center","id":731,"sizeSlug":"large"} -->
<div class="wp-block-image"><figure class="aligncenter size-large"><img src="http://img.varsion.cn/blog-img/2020/09/image-8.png" alt="" class="wp-image-731"/></figure></div>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>在方法定义中，有两个以冒号结尾的参数。而在调用的时候，却更像是使用哈希。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Ruby的匹配规则会使得a和b的绑定值与期望的一致，而不需要去研究是怎么转化成哈希的。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>同时，通过具名参数给其一个默认值们可以将关键字参数作为可选的，这样就会是参数列表看起来更像哈希。</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>def func(a:1,b:2)</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>如果调用函数时没有传递该参数值，则会使用其默认值。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>而如果采用另外一种方式，调用一个使用具名参数的方法时，传递给方法的值并没有声明过。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>这时候，有一个参数变量可以吸收所有未声明的变量参数。</p>
<!-- /wp:paragraph -->

<!-- wp:codemirror-blocks/code-block {"fileName":"吸收参数","mode":"ruby","mime":"text/x-ruby"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre>def func(a:1,b:2,**c)
  puts a,b,c
end

func(x:1,y:2,Z:3)</pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:image {"align":"center","id":733,"sizeSlug":"large"} -->
<div class="wp-block-image"><figure class="aligncenter size-large"><img src="http://img.varsion.cn/blog-img/2020/09/image-9.png" alt="" class="wp-image-733"/></figure></div>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>如果没有可以吸收的参数，类似于<code>func(x:1,y:2)</code>的方法调用仅仅是随着哈希传递，这有可能失败，也有可能不会，最终取决于方法所需要的参数。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>当然，也可以合并具名参数和非具名参数。</p>
<!-- /wp:paragraph -->

<!-- wp:codemirror-blocks/code-block {"fileName":"合并参数","mode":"ruby","mime":"text/x-ruby"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre>def func(x,y,*z,a:1,b:,**c,&amp;block)
  puts x,y,z,a,b,c
end
func(1,2,3,4,5,b:10,p:20,q:30)</pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:image {"align":"center","id":736,"sizeSlug":"large"} -->
<div class="wp-block-image"><figure class="aligncenter size-large"><img src="http://img.varsion.cn/blog-img/2020/09/image-10.png" alt="" class="wp-image-736"/></figure></div>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>对该方法的说明：</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul><li>带有两个必选的定位参数<code>x,y</code></li><li>拥有一个'吸收'参数<code>z</code>用以处理跟随在定位参数后额外的参数（这里吸收了3，4，5</li><li>拥有一个可选和一个必选参数（a是默认的1，b是绑定的10</li><li>拥有一个'吸收'参数c用于吸收未知的具名参数（p和q哈希）</li><li>拥有一个变量用于绑定代码块，仅当代码块（block）存在时</li></ul>
<!-- /wp:list -->

<!-- wp:separator {"className":"is-style-wide"} -->
<hr class="wp-block-separator is-style-wide"/>
<!-- /wp:separator -->

<!-- wp:block {"ref":178} /-->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>728</wp:post_id>
		<wp:post_date><![CDATA[2020-09-16 15:12:05]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2020-09-16 07:12:05]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[ruby-%e5%85%b7%e5%90%8d%e5%8f%82%e6%95%b0]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="ruby"><![CDATA[Ruby]]></category>
		<category domain="post_tag" nicename="ruby"><![CDATA[Ruby]]></category>
		<category domain="post_tag" nicename="%e5%85%b7%e5%90%8d%e5%8f%82%e6%95%b0"><![CDATA[具名参数]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_content_score]]></wp:meta_key>
		<wp:meta_value><![CDATA[90]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_primary_category]]></wp:meta_key>
		<wp:meta_value><![CDATA[3]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_focuskw]]></wp:meta_key>
		<wp:meta_value><![CDATA[Ruby具名参数]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_metadesc]]></wp:meta_key>
		<wp:meta_value><![CDATA[在方法定义中，有两个以冒号结尾的参数。而在调用的时候，却更像是使用哈希。]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_linkdex]]></wp:meta_key>
		<wp:meta_value><![CDATA[27]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>Ruby - 枚举 Enumerable (一)</title>
		<link>https://blog.varsion.cn/?p=741</link>
		<pubDate>Fri, 18 Sep 2020 03:06:32 +0000</pubDate>
		<dc:creator><![CDATA[Varsion]]></dc:creator>
		<guid isPermaLink="false">https://blog.varsion.cn/?p=741</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p>所有集合类型对象的创建都不一样，但是他们中大多数都有共通的特性。在Ruby中，集合类型对象通常都包含<code>Enumerable</code>模块。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>使用<code>Enumerable</code>的类有一种协定：该类必须定义一个名为<code>each</code>的实例方法，而同时该模块也赋予了该类一组集合类型的相关行为。</p>
<!-- /wp:paragraph -->

<!-- wp:codemirror-blocks/code-block {"fileName":"集合类","mode":"ruby","mime":"text/x-ruby"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre>class C
    include Enumerable
  def each
    # code
  end
end</pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:heading {"level":3} -->
<h3>依赖<code>each</code>获得枚举能力</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>任何可枚举的类都具有一个<code>each</code>方法（必须）。其作用是将其中的元素逐个的做为参数传递给代码块（<code>yield</code>）</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul><li>在数组中,<code>each</code>依次传递各个元素给代码块</li><li>在哈希中,则是以两个元素的数组来传递键值对</li><li>在文件处理的情况下,会依次传递文件中的第一行给代码块</li><li>范围则会首先判断迭代是否可用(如起点是浮点数的情况)然后会伪装成数组进行传递</li></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>而如果在自己的类中定义了<code>each</code>方法,就可以将其自定义,只要传递参数给代码块即可</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>但是无论怎样,只要实现了<code>each</code>,就可以通过他来调用<code>Enumerab</code>模块中的方法</p>
<!-- /wp:paragraph -->

<!-- wp:codemirror-blocks/code-block {"fileName":"Rainbow","mode":"ruby","mime":"text/x-ruby"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre>class Rainbow
  include Enumerable
  def each
    yield &quot;red&quot;
    yield &quot;orange&quot;
    yield &quot;yellow&quot;
    yield &quot;green&quot;
    yield &quot;blue&quot;
    yield &quot;indigo&quot;
    yield &quot;violet&quot;
  end
end</pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:paragraph -->
<p><code>Rainbow</code>的每个实例都可以迭代这些函数,最简单的情况下可以这样使用<code>each</code>来遍历所有元素</p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">Rainbow.new.each do |color|
   puts "Color is #{color}"
end</pre>
<!-- /wp:preformatted -->

<!-- wp:heading {"level":3} -->
<h3>可枚举对象的搜索和选择</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p><code>Enumerable</code>提供了很多功能,可用于在集合类型对象中根据一些条件过滤和搜索其中的一个或多个元素</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>这些条件过滤和搜索方法中,所使用的全都是迭代器,全都需要提供一个代码块,而这个代码块就是一个选择过滤器,可以在该代码块中定义自己的过滤条件.整个方法的返回值也会不相同,可能会返回一个对象,一个包含匹配对象的数组(数组可能为空)或者没有任何条件匹配时返回<code>nil</code></p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4>使用<code>find</code>方法进行第一次匹配</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>通过将数组中的元素作为参数传递个代码块并执行条件判断</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><code>find</code>(还有一个可用的同义方法<code>detect</code>)会定位数组中第一个条件判断为真的元素例如</p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">[1,2,3,4,5,6,7,8].find {|n| n&gt;5}</pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<p>这行代码会返回<code>6</code>,即第一个符合条件判断为真的元素</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><code>find</code>迭代整个数组,将每个元素依传递到代码块中.如果代码使用布尔值为真的形式作为返回值,那么当前的元素就获得了优先,<code>find</code>代码就会停止迭代,如果<code>find</code>并没有查找到符合的元素,将会返回<code>nil</code></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>而如果只是为了测试该数组或者该对象中是否存在一个值,更建议的方法是使用<code>include</code></p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">[1,2,3,4,nil,5,6].find {|n| n.nil?}</pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<p>如果在当前情境下使用<code>find</code>方法,无论是否存在元素为<code>nil</code>该代码都将返回<code>nil</code>这个时候<code>include</code>更能解决问题<code>array.include?nil</code></p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4><code>find_all</code>和<code>reject</code>获取所有匹配元素</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p><code>find_all</code>又名<code>select</code>会返回一个新集合类型的对象,其中包含了在代码块中所有匹配从原始集合类型对象中得到的元素,而不仅仅是第一个匹配到的元素</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>如果没有匹配到任何元素,会返回一个空类型集合对象</p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">[1,2,3,4,5,6,7,8,9].find_all {|n| n>5 }</pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<p>这段代码会返回<code>[6,7,8,9]</code>即原数组中所有符合<code>n>5</code>的元素</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>同时数组,散列,集合都有<code>select!</code>的bang方法版本,会让源集合只留下条件判断为真的数据,不过不存在<code>find_all!</code>必须使用<code>select!</code></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><code>reject</code>方法可以排除元素,即将所有符合条件判断的数据剔除</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>同时,<code>reject</code>存在bang方法<code>reject!</code>会直接在源数据上修改.适用于数组,哈希,集合</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4>基于三等号匹配的<code>grep</code>来选择元素</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p><code>Enumerab#grep</code>方法会基于<code>case</code>的相等性运算符<code>===</code>,从可枚举对象中选择元素,<code>grep</code>最常见的用户,即字符串匹配模式</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><code>grep</code>的普遍性可以让我们做一些花哨的工作</p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">array.grep(/o/)      # 利用正则匹配元素
array.grep(String)   #利用类型匹配元素
array.grep(50..100)  #利用范围匹配元素</pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<p>总言之<code>array.grep(expression)</code>等同于:</p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted"><code>array.select [ |element| expression === element}</code></pre>
<!-- /wp:preformatted -->

<!-- wp:heading {"level":4} -->
<h4><code>group_by</code>和<code>partition</code></h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p><code>group_by</code>操作包含一个代码块并返回一个散列</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>对于每个对象,代码块都会被执行一次,每个独立代码块返回的值,最终会作为返回值的散列键,而键对应的值则是一个数组,该数组的元素包含哪些可枚举对象中的元素是通过代码的返回值来确定的.</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>colors = %w{red orange yellow green blue}
colors.group_by {|color| color.size}</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>改代码的返回值则是如下的散列</p>
<!-- /wp:paragraph -->

<!-- wp:image {"align":"center","id":797,"sizeSlug":"large"} -->
<div class="wp-block-image"><figure class="aligncenter size-large"><img src="http://img.varsion.cn/blog-img/2020/09/image-11.png" alt="" class="wp-image-797"/></figure></div>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>根据其字符串的长度来分组</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><code>partition</code>会基于代码块是否返回为真,来将可枚举对象的元素分割为两个数组</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>&#91;1,2,3,4,5,6,7,8].partition {|x| x%2 == 0}</code></pre>
<!-- /wp:code -->

<!-- wp:image {"align":"center","id":802,"sizeSlug":"large"} -->
<div class="wp-block-image"><figure class="aligncenter size-large"><img src="http://img.varsion.cn/blog-img/2020/09/image-12.png" alt="" class="wp-image-802"/></figure></div>
<!-- /wp:image -->

<!-- wp:separator {"className":"is-style-wide"} -->
<hr class="wp-block-separator is-style-wide"/>
<!-- /wp:separator -->

<!-- wp:block {"ref":178} /-->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>741</wp:post_id>
		<wp:post_date><![CDATA[2020-09-18 11:06:32]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2020-09-18 03:06:32]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[ruby-%e6%9e%9a%e4%b8%be-enumerable-%e4%b8%80]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="enumerable"><![CDATA[Enumerable]]></category>
		<category domain="category" nicename="ruby"><![CDATA[Ruby]]></category>
		<category domain="post_tag" nicename="ruby"><![CDATA[Ruby]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_primary_category]]></wp:meta_key>
		<wp:meta_value><![CDATA[3]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_content_score]]></wp:meta_key>
		<wp:meta_value><![CDATA[90]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_focuskw]]></wp:meta_key>
		<wp:meta_value><![CDATA[Ruby 可枚举对象]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_metadesc]]></wp:meta_key>
		<wp:meta_value><![CDATA[所有集合类型对象的创建都不一样，但是他们中大多数都有共通的特性。在Ruby中，集合类型对象通常都包含模块。]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_linkdex]]></wp:meta_key>
		<wp:meta_value><![CDATA[27]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>Git协同开发流程</title>
		<link>https://blog.varsion.cn/?p=805</link>
		<pubDate>Fri, 18 Sep 2020 05:36:49 +0000</pubDate>
		<dc:creator><![CDATA[Varsion]]></dc:creator>
		<guid isPermaLink="false">https://blog.varsion.cn/?p=805</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:image {"align":"center","id":811,"sizeSlug":"large"} -->
<div class="wp-block-image"><figure class="aligncenter size-large"><img src="http://img.varsion.cn/blog-img/2020/09/image-15.png" alt="" class="wp-image-811"/><figcaption>开发流程</figcaption></figure></div>
<!-- /wp:image -->

<!-- wp:heading -->
<h2>具体操作</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>每次项目开始时，我会将基础代码框架并配置需要用到的组件，然后将基础代码包更新到我自己的仓库中。</p>
<!-- /wp:paragraph -->

<!-- wp:image {"align":"center","id":813,"sizeSlug":"large"} -->
<div class="wp-block-image"><figure class="aligncenter size-large"><img src="http://img.varsion.cn/blog-img/2020/09/image-16-1024x282.png" alt="" class="wp-image-813"/></figure></div>
<!-- /wp:image -->

<!-- wp:heading {"level":3} -->
<h3>Fork</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>需要点击右上角的 forl 按钮，将主仓库的代码 fork 到自己的仓库中。</p>
<!-- /wp:paragraph -->

<!-- wp:image {"align":"center","id":816,"sizeSlug":"large"} -->
<div class="wp-block-image"><figure class="aligncenter size-large"><img src="http://img.varsion.cn/blog-img/2020/09/image-19.png" alt="" class="wp-image-816"/></figure></div>
<!-- /wp:image -->

<!-- wp:heading {"level":3} -->
<h3>Clone</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>然后转到自己的Github仓库，将Fork来的代码 clone 到本地。</p>
<!-- /wp:paragraph -->

<!-- wp:image {"align":"center","id":818,"sizeSlug":"large"} -->
<div class="wp-block-image"><figure class="aligncenter size-large"><img src="http://img.varsion.cn/blog-img/2020/09/image-20.png" alt="" class="wp-image-818"/></figure></div>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>然后在<a rel="noreferrer noopener" href="https://cmder.net/" target="_blank">Cmder</a>，或者Git命令行中进行代码 clone，将代码 clone 本地。</p>
<!-- /wp:paragraph -->

<!-- wp:image {"align":"center","id":819,"sizeSlug":"large"} -->
<div class="wp-block-image"><figure class="aligncenter size-large"><img src="http://img.varsion.cn/blog-img/2020/09/image-21.png" alt="" class="wp-image-819"/></figure></div>
<!-- /wp:image -->

<!-- wp:heading {"level":3} -->
<h3>push</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>在完成自己的部分代码的开发之后，需要将自己的代码推到自己的远程仓库中</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>这边举一个例子：</p>
<!-- /wp:paragraph -->

<!-- wp:image {"id":822,"sizeSlug":"large"} -->
<figure class="wp-block-image size-large"><img src="http://img.varsion.cn/blog-img/2020/09/image-22.png" alt="" class="wp-image-822"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>这是一份已经 clone 到本地并完成的代码，假设我现在修改/新增了文件：test.md</p>
<!-- /wp:paragraph -->

<!-- wp:image {"align":"center","id":824,"sizeSlug":"large"} -->
<div class="wp-block-image"><figure class="aligncenter size-large"><img src="http://img.varsion.cn/blog-img/2020/09/image-23.png" alt="" class="wp-image-824"/></figure></div>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>我现在要如何将该文件推送到自己的Github，然后应该如何再将该文件的改动推送到源仓库。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>首先是切换到 develop 分支，将 test.md 添加至本地仓库，并设置提交信息，然后推送到自己的仓库中。</p>
<!-- /wp:paragraph -->

<!-- wp:image {"id":827,"sizeSlug":"large"} -->
<figure class="wp-block-image size-large"><img src="http://img.varsion.cn/blog-img/2020/09/image-26.png" alt="" class="wp-image-827"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>依次的代码是：</p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">git checkout develop
git add test.md
git commit -m "The test"
git pust origin develop # 第一次执行时会提示填写用户名和密码</pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<p>这时候，我们会在自己的代码仓库中看到刚刚提交的修改（注意切换到 develop 分支</p>
<!-- /wp:paragraph -->

<!-- wp:image {"align":"center","id":830,"sizeSlug":"large"} -->
<div class="wp-block-image"><figure class="aligncenter size-large"><img src="http://img.varsion.cn/blog-img/2020/09/image-28.png" alt="" class="wp-image-830"/></figure></div>
<!-- /wp:image -->

<!-- wp:image {"align":"center","id":832,"sizeSlug":"large"} -->
<div class="wp-block-image"><figure class="aligncenter size-large"><img src="http://img.varsion.cn/blog-img/2020/09/image-30.png" alt="" class="wp-image-832"/></figure></div>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>至此，我们已经将修改后的代码/文件推送到了自己的Github仓库。</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>提交主仓库请求</h3>
<!-- /wp:heading -->

<!-- wp:image {"align":"center","id":834,"sizeSlug":"large"} -->
<div class="wp-block-image"><figure class="aligncenter size-large"><img src="http://img.varsion.cn/blog-img/2020/09/image-31.png" alt="" class="wp-image-834"/></figure></div>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>我们要 Pull Request 中提交请求。</p>
<!-- /wp:paragraph -->

<!-- wp:image {"align":"center","id":835,"sizeSlug":"large"} -->
<div class="wp-block-image"><figure class="aligncenter size-large"><img src="http://img.varsion.cn/blog-img/2020/09/image-32-1024x259.png" alt="" class="wp-image-835"/></figure></div>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>尤其是注意，要从自己的 develop 分支提交到源仓库的 develop 分支，下文会讲述详细的原因。</p>
<!-- /wp:paragraph -->

<!-- wp:image {"id":836,"sizeSlug":"large"} -->
<figure class="wp-block-image size-large"><img src="http://img.varsion.cn/blog-img/2020/09/image-33-1024x223.png" alt="" class="wp-image-836"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>然后写明提交内容，点击提交按钮：</p>
<!-- /wp:paragraph -->

<!-- wp:image {"align":"center","id":837,"sizeSlug":"large"} -->
<div class="wp-block-image"><figure class="aligncenter size-large"><img src="http://img.varsion.cn/blog-img/2020/09/image-34.png" alt="" class="wp-image-837"/></figure></div>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>我会再主仓库检查并核对代码之后，将其合并到主分支中。</p>
<!-- /wp:paragraph -->

<!-- wp:image {"align":"center","id":839,"sizeSlug":"large"} -->
<div class="wp-block-image"><figure class="aligncenter size-large"><img src="http://img.varsion.cn/blog-img/2020/09/image-35.png" alt="" class="wp-image-839"/></figure></div>
<!-- /wp:image -->

<!-- wp:heading -->
<h2>develop 分支和 master 分支</h2>
<!-- /wp:heading -->

<!-- wp:image {"align":"center","id":840,"sizeSlug":"large"} -->
<div class="wp-block-image"><figure class="aligncenter size-large"><img src="http://img.varsion.cn/blog-img/2020/09/image-36.png" alt="" class="wp-image-840"/></figure></div>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>关于 develop 分支和 master 分支，master 分支是建立代码库是就拥有的分支，而 develop 分支是代码仓库建立后，建立该分支用来开发。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>所有开发者开发好的功能会在源仓库的 develop 分支中进行汇总，当 develop 中的代码经过不断的测试，已经逐渐趋于稳定了，接近产品目标了。这时候，我们就可以把 develop 分支合并到 master 分支中，发布一个新版本。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>当然我们也可以把 develop 分支命名为 demo 分支，或者其他好听的名字。但是其意义是不变的。</p>
<!-- /wp:paragraph -->

<!-- wp:verse -->
<pre class="wp-block-verse">这里放上Github链接：欢迎大家的关注和Star
<a href="https://github.com/coderTH" target="_blank" rel="noreferrer noopener">CoderTH</a>
<a href="https://github.com/Varsion" target="_blank" rel="noreferrer noopener">Varsion</a></pre>
<!-- /wp:verse -->

<!-- wp:separator {"className":"is-style-wide"} -->
<hr class="wp-block-separator is-style-wide"/>
<!-- /wp:separator -->

<!-- wp:block {"ref":178} /-->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>805</wp:post_id>
		<wp:post_date><![CDATA[2020-09-18 13:36:49]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2020-09-18 05:36:49]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[git%e5%8d%8f%e5%90%8c%e5%bc%80%e5%8f%91%e6%b5%81%e7%a8%8b]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="developer"><![CDATA[Developer]]></category>
		<category domain="post_tag" nicename="developer"><![CDATA[Developer]]></category>
		<category domain="post_tag" nicename="git"><![CDATA[Git]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_primary_category]]></wp:meta_key>
		<wp:meta_value><![CDATA[47]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_content_score]]></wp:meta_key>
		<wp:meta_value><![CDATA[90]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_focuskw]]></wp:meta_key>
		<wp:meta_value><![CDATA[Git协同开发]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_linkdex]]></wp:meta_key>
		<wp:meta_value><![CDATA[27]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>Ruby – 枚举 Enumerable (二)</title>
		<link>https://blog.varsion.cn/?p=856</link>
		<pubDate>Fri, 18 Sep 2020 12:30:58 +0000</pubDate>
		<dc:creator><![CDATA[Varsion]]></dc:creator>
		<guid isPermaLink="false">https://blog.varsion.cn/?p=856</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p>集合类型就是为遍历出现的，而他们可以包含特殊状态的独立对象：集合类型中的第一个或最后一个，最大一个或者最小一个。<code>Enumable</code>对象带来了许多用于元素处理的工具。</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3><code>first</code></h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>就像这个名字一样<code>Enumable # first</code>方法返回可枚举对象迭代时的第一个元素。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>通过<code>first</code>方法返回的对象和使用迭代时第一个得到的对象。换句话说，它是通过<code>each</code>方法第一个传递到代码块中的元素。与散列以两个元素的数组传递键值对的情况是一致的，获取散列的第一个元素会得到以两个元素形式表示的键值对数组。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>需要知道的时，并没有和<code>Enumable # first</code>相对应的<code>Enumable # last</code>，是因为寻找迭代的末尾不像寻找其开端一样简单明了。</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3><code>take</code>方法和<code>drop</code>方法</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>可枚举对象知道如何从它自身的起点得到指定数量的元素，相反的，他也知道如何排除指定数量的元素。<code>take</code>和<code>drop</code>方法从本质上完成的是相同的事情，他只使用指定更多位置拆分集合，而不同点在于返回值不同。</p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">a = [1,2,3,4,5,6]
a.take(2)
# [1,2]
a.drop(2)
# [3,4,5,6]</pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<p><code>#</code>为输出</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>只要获取元素，就会得到这些元素。而排除一些元素，就会得到从原始集合中键取要排除的元素而剩下的元素。可以通过使用代码块以及<code>take</code>和<code>drop</code>的变化形式<code>take_while</code>和<code>drop_while</code>来约束操作，他们会根据代码块的返回值是否为真来决定获取元素的数量。</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3><code>min</code>方法和<code>max</code>方法</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p><code>min</code>方法和<code>max</code>方法的用法同其名称一样，但是其的大小判断是通过<code>&lt;=></code>逻辑来判定的。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>这里要讲的是他们的衍生方法：<code>min_by</code>、<code>max_by</code>以及<code>minmax</code>和其对应的<code>minmax_by</code>。</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>%w{ Ruby C C# PHP JavaScript}.max_by { |lang| lang.size}
# JavaScript
%w{ Ruby C C# PHP JavaScript}.minmax_by { |lang| lang.size}
# C  JavaScript</code></pre>
<!-- /wp:code -->

<!-- wp:separator {"className":"is-style-wide"} -->
<hr class="wp-block-separator is-style-wide"/>
<!-- /wp:separator -->

<!-- wp:block {"ref":178} /-->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>856</wp:post_id>
		<wp:post_date><![CDATA[2020-09-18 20:30:58]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2020-09-18 12:30:58]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[ruby-%e6%9e%9a%e4%b8%be-enumerable-%e4%ba%8c]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="enumerable"><![CDATA[Enumerable]]></category>
		<category domain="category" nicename="ruby"><![CDATA[Ruby]]></category>
		<category domain="post_tag" nicename="ruby"><![CDATA[Ruby]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_primary_category]]></wp:meta_key>
		<wp:meta_value><![CDATA[3]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_content_score]]></wp:meta_key>
		<wp:meta_value><![CDATA[90]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_focuskw]]></wp:meta_key>
		<wp:meta_value><![CDATA[ruby Enumable 元素级操作]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_metadesc]]></wp:meta_key>
		<wp:meta_value><![CDATA[集合类型就是为遍历出现的，而他们可以包含特殊状态的独立对象：集合类型中的第一个或最后一个，最大一个或者最小一个。Enumable对象带来了许多用于元素处理的工具。]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_linkdex]]></wp:meta_key>
		<wp:meta_value><![CDATA[25]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>Ruby – 枚举 Enumerable (三)</title>
		<link>https://blog.varsion.cn/?p=879</link>
		<pubDate>Mon, 28 Sep 2020 02:42:40 +0000</pubDate>
		<dc:creator><![CDATA[Varsion]]></dc:creator>
		<guid isPermaLink="false">https://blog.varsion.cn/?p=879</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:heading -->
<h2><code>Each</code>相关方法</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p><code>Enumable</code>对象有很多与<code>each</code>详细的方法，他们可以遍历整个集合并且传递其中的元素到代码块，直到完全遍历完成迭代才会停止。这些方法体系中的每个成员都有自己特定的语义和定位。</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3><code>reverse_each</code></h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>该方法可反向迭代一个枚举对象。</p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">[1,2,3].reverse_each { |e| puts e*10}
# 30
# 20
# 10</pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<p>需要注意的是，不要将该方法用于无限的迭代器中，因为反向的概念需要依赖于最后一个元素，而对于反向迭代器而言，使用该方法是毫无意义的。</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3><code>each_with_index</code>与<code>each.with_index</code></h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p><code>each_with_index</code>在遍历结合时，每次会传递一个额外的参数到代码块中，从命名上来讲，他是一个代表了元素序号的整数。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>每一个可枚举对象都可以拥有该方法<code>each_with_index</code>，但并不是每个可枚举队形都可以使用索引。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>宿主拥有基础的索引概念，而哈希没有，但是他确实与索引相关。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>哈希的键作为索引，而通过<code>each_with_index</code>迭代生成的序号却作为额外的或者元数据的索引。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><code>Enumerable</code>#<code>each_with_index</code>可以正常使用，但是更多的时候是考虑调用each所得的枚举器中可用的#<code>with_index</code>方法</p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">array = %w{red yellow blue}
array.each.with_index do |color ,i|
    puts "Color ID#{i} is #{color}"
end</pre>
<!-- /wp:preformatted -->

<!-- wp:heading {"level":3} -->
<h3><code>each_slice</code>和<code>each_cons</code>方法 </h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>这两个方法是<code>each</code>的特殊版本，他们可以一次集合中一定数量的元素，并将诸多元素作为数组在每次迭代的时候传递给代码块。</p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">ar.each_slice(3) {|slice| p slice}
puts "|"
ar.each_cons(3) {|cons| p cons}</pre>
<!-- /wp:preformatted -->

<!-- wp:image {"align":"center","id":903,"sizeSlug":"large"} -->
<div class="wp-block-image"><figure class="aligncenter size-large"><img src="http://img.varsion.cn/blog-img/2020/09/image-37.png" alt="" class="wp-image-903"/></figure></div>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p><code>each_slice</code>操作会将集合按照n或者小于n（如果剩余元素不足n个）的大小逐次划分为新集合传递到代码块中。相反的，<code>each_cons</code>则一次向前移动一个元素的位置，而每次迭代都把包含n个元素的数组传递到代码块中，当最后一个元素被传递过一次之后迭代停止。</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3><code>cycle</code>方法</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p><code>Enumerable</code>#<code>cycle</code>会反复的将对象中的所有元素作为参数传递到代码块中。如果调用时提供了一个参数，循环的次数将有该参数决定。如果没有该参数，则会无限进行。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>扑克牌案例</p>
<!-- /wp:paragraph -->

<!-- wp:codemirror-blocks/code-block {"fileName":"PokeCard","mode":"ruby","mime":"text/x-ruby"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre>class PokeCard 
    SUITS = %w{ clubs aidmonds hearts spades }
    RANKS = %w{ 2 3 4 5 6 7 8 9 10 J Q K A }

    class Deck
        attr_reader :cards
        def initialize(n=1)
            @cards = []
            SUITS.cycle(n) do |s|
                RANKS.cycle(1) do |r|
                    @cards &lt;&lt; &quot;#{r} of #{s}&quot;
                end
            end
        end
    end
end</pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:paragraph -->
<p><code>PokeCard</code>类定义了用于表示花色和牌级的常量，而<code>PokeCard::Deck</code>类定义了一个牌盒，所有卡牌都会保存在实例变量 <code>@cards</code>中，同时作为读取器属性。通过使用<code>cycle</code>很容易将两个甚至多副扑克牌排列。例如下面的代码会产生两幅扑克牌。</p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">deck = PokeCard::Deck.new</pre>
<!-- /wp:preformatted -->

<!-- wp:separator {"className":"is-style-wide"} -->
<hr class="wp-block-separator is-style-wide"/>
<!-- /wp:separator -->

<!-- wp:block {"ref":178} /-->]]></content:encoded>
		<excerpt:encoded><![CDATA[Enumable对象有很多与each详细的方法，他们可以遍历整个集合并且传递其中的元素到代码块，直到完全遍历完成迭代才会停止。这些方法体系中的每个成员都有自己特定的语义和定位。]]></excerpt:encoded>
		<wp:post_id>879</wp:post_id>
		<wp:post_date><![CDATA[2020-09-28 10:42:40]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2020-09-28 02:42:40]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[ruby-%e6%9e%9a%e4%b8%be-enumerable-%e4%b8%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="enum"><![CDATA[Enum]]></category>
		<category domain="category" nicename="ruby"><![CDATA[Ruby]]></category>
		<category domain="post_tag" nicename="ruby"><![CDATA[Ruby]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_primary_category]]></wp:meta_key>
		<wp:meta_value><![CDATA[3]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_content_score]]></wp:meta_key>
		<wp:meta_value><![CDATA[90]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_focuskw]]></wp:meta_key>
		<wp:meta_value><![CDATA[Enumabler Ruby]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_metadesc]]></wp:meta_key>
		<wp:meta_value><![CDATA[Enumable对象有很多与each详细的方法，他们可以遍历整个集合并且传递其中的元素到代码块，直到完全遍历完成迭代才会停止。这些方法体系中的每个成员都有自己特定的语义和定位。]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_linkdex]]></wp:meta_key>
		<wp:meta_value><![CDATA[27]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>约定优先于配置（CoC）</title>
		<link>https://blog.varsion.cn/?p=925</link>
		<pubDate>Mon, 28 Sep 2020 06:44:32 +0000</pubDate>
		<dc:creator><![CDATA[Varsion]]></dc:creator>
		<guid isPermaLink="false">https://blog.varsion.cn/?p=925</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p>约定优于配置（Convention Over Configuration）,也称作按约定编程是一种软件设计范式。目的在于减少软件开发人员所需要做出的决定的数量，从而获得简单的好处，而又不失去其中的灵活性。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>本质是说，开发人员仅需规定应用中不符约定的部分。例如，如果模型中有个名为Sale的类，那么数据库中对应的表就会默认命名为sales。只有在偏离这一约定时，例如将该表命名为"products_sold"，才需写有关这个名字的配置。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>如果所用工具的约定与期待相符，便可省去配置；反之，可以配置来达到所期待的方式。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><strong>|约定优于配置|</strong>能极大提高开发效率，并且也更有利于团队协作。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>这些约定可能会细致到一个单词的书写，一个文件的命名。一个完善的开发手册对于每次实际协同开发来讲，都是极其重要的。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>其目的就在于，减少开发者做决定的机会。有点类似于"中央集权"。</p>
<!-- /wp:paragraph -->

<!-- wp:separator {"className":"is-style-wide"} -->
<hr class="wp-block-separator is-style-wide"/>
<!-- /wp:separator -->

<!-- wp:block {"ref":178} /-->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>925</wp:post_id>
		<wp:post_date><![CDATA[2020-09-28 14:44:32]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2020-09-28 06:44:32]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e7%ba%a6%e5%ae%9a%e4%bc%98%e5%85%88%e4%ba%8e%e9%85%8d%e7%bd%ae%ef%bc%88coc%ef%bc%89]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="developer"><![CDATA[Developer]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_primary_category]]></wp:meta_key>
		<wp:meta_value><![CDATA[47]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_content_score]]></wp:meta_key>
		<wp:meta_value><![CDATA[90]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>Ruby - 可枚举对象排序</title>
		<link>https://blog.varsion.cn/?p=930</link>
		<pubDate>Tue, 29 Sep 2020 09:45:30 +0000</pubDate>
		<dc:creator><![CDATA[Varsion]]></dc:creator>
		<guid isPermaLink="false">https://blog.varsion.cn/?p=930</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p>如果有一个类，需要对他的实例化对象进行排序，就需要按照如下方式：</p>
<!-- /wp:paragraph -->

<!-- wp:list {"ordered":true} -->
<ol><li>定义类的比较方法 <code>&lt;=&gt;</code></li><li>将多个实例对象放入容器</li><li>对这个容器进行排序</li></ol>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>关键在于，虽然排序功能是由<code>Enumerable</code>提供的，但是我们自己的类可以不必混合该模块。当然将对象放到集合类型中也有等同于混合了该模块。作为可枚举的集合类型对象有两个可用的排序方法即:<code>sort</code>和<code>sort_by</code>。</p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">[2,4,1,7].sort</pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<p>当使用数字或者字符串的时候，是十分容易的，放置元素的数组有一种排序机制，整数或者字符串都有着可以排序的方式。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>例如需要对一个类的实例对象进行排序：</p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">[p1,p2,p3,p4].sort</pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<p>对于类<code>P</code>的对象来说，如果需要进行排序操作就必须定义飞船运算符<code>&lt;=&gt;</code>即<code>p#&lt;=&gt;</code></p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">def <=> (other_p)
    self.price <=> other_p.price
end</pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<p>定义了该类方法之后，对包含类P的对象进行排序时，会根据<code>price</code>属性来进行排序。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Ruby会应用<code>&lt;=&gt;</code>来测试这些元素，一次两个，以构建足够的信息用于执行完整的排序操作。</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>可枚举对象排序中的<code>Comparable</code>模块</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>如果要使在可枚举容器中的对象拥有可枚举能力，关键在于定义<code>&lt;=&gt;</code>，因此无需混合<code>Comparable</code>就可以获得<code>&lt;=&gt;</code>以及排序能力。</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul><li>如果为一个类定义了<code>&lt;=&gt;</code>，之后这个类的所有实例都可以放到数组或者可枚举对象中进行排序</li><li>如果没有定义<code>&lt;=&gt;</code>，仍然可以排序这些对象，只需要将他们放在数组中，并提供一个可以让数组知道如何排列两个对象的代码块。</li><li>如果在类中定义了<code>&lt;=&gt;</code>同时也包含了<code>Comparable</code>，之后就可以让数组在使用排序操作时，同时还可以在任意的两个元素对象间执行所有的比较操作。</li></ul>
<!-- /wp:list -->

<!-- wp:heading {"level":3} -->
<h3>使用代码块定义排序逻辑</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>如果对象中并没有定义<code>&lt;=&gt;</code>方法，也可以通过动态的使用代码块来指定对象应该如何排序。即使定义了<code>&lt;=&gt;</code>方法，也可以通过该方法来覆盖已经存在的方法。</p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">[p1,p2,p3,p4].sort do |a,b|
     a.price <=> b.price
end</pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<p>代码块可以携带两个参数，这样就可以根据需求多次调用代码块以比较两个对象。</p>
<!-- /wp:paragraph -->

<!-- wp:separator {"className":"is-style-wide"} -->
<hr class="wp-block-separator is-style-wide"/>
<!-- /wp:separator -->

<!-- wp:block {"ref":178} /-->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>930</wp:post_id>
		<wp:post_date><![CDATA[2020-09-29 17:45:30]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2020-09-29 09:45:30]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[__trashed-2]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="enumerable"><![CDATA[Enumerable]]></category>
		<category domain="category" nicename="ruby"><![CDATA[Ruby]]></category>
		<category domain="post_tag" nicename="ruby"><![CDATA[Ruby]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_primary_category]]></wp:meta_key>
		<wp:meta_value><![CDATA[3]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_content_score]]></wp:meta_key>
		<wp:meta_value><![CDATA[90]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_wp_desired_post_slug]]></wp:meta_key>
		<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>Ruby - 枚举器</title>
		<link>https://blog.varsion.cn/?p=959</link>
		<pubDate>Wed, 07 Oct 2020 02:48:18 +0000</pubDate>
		<dc:creator><![CDATA[Varsion]]></dc:creator>
		<guid isPermaLink="false">https://blog.varsion.cn/?p=959</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:heading {"level":3} -->
<h3>使用枚举器保护对象 </h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>思考使用一个数组作为参数的方法</p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">def get_array(array)</pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<p>如果传递一个数组对象给这个方法，这个方法就可以修改该数组对象</p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">array &lt;&lt; "new element"</pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<p>如果想要保护这个数组对象不被改变，可以选择复制改数组，并传递他的替代品，即，使用枚举器迭代</p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">def get_array(array.to_enum)</pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<p>枚举器很乐意去迭代数组，但是他不会接受被改变。（尝试对枚举器使用<code>&lt;&lt;</code> 会引起致命错误</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>枚举器可以作为集合类型对象对一种网关（gateway）：允许迭代和测试元素对操作，但是不允许破坏性操作。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>因为，枚举器本身就是对象，是有状态的。</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>细粒度迭代</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>枚举器可以维护状态，可以持续追踪自身迷局的过程，许多方法都可以直接获取到这些信息</p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">name = %w { M L }
e = name.to_enum
puts e.next
puts e.next 
e.rewind
puts e.next</pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<p>这些代码会输出<code> M L M </code>，枚举起允许使用者以慢镜头的方式移动，因此，在枚举过程中，可以随意的暂停或者重启。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>这一点明确了枚举器和迭代器的差异性。<strong>枚举器是一个对象，因此他可以保存状态，会记住枚举过程中的位置。迭代器是一个方法，调用它的过程是原子性的，整个调用的过程发生，然后结束。</strong></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>由于代码块的使用，Ruby的方法调用确实有了很多很有用的复杂特性：方法可以回调代码块。这样可能会影响方法的返回结果，但他仍旧是一个方法。迭代器没有状态，而枚举器是一个可枚举的对象</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>添加可枚举性</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>枚举器可以将可枚举性添加到不具有该特性的对象中。这就很像是一个关于连线的问题：如果将一个枚举器的<code>each</code>方法与任何迭代器关联，就是一使用枚举器在拥有该迭代器的对象上执行可枚举操作，不管该对象自身是否是可枚举的。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>将枚举器与<code>String # bytes</code>关联，就可以有效的添加可枚举性到没有这个特性的对象中，而<code>String</code>不必混合<code>Enumable</code>模块。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>枚举器将自己附加到特殊对象的特殊方法上，然后juicing该方法作为基础方法如<code>each</code>来使用，这样该方就可以作为整个可枚举工具集的其中一个工具来使用。</p>
<!-- /wp:paragraph -->

<!-- wp:separator {"className":"is-style-wide"} -->
<hr class="wp-block-separator is-style-wide"/>
<!-- /wp:separator -->

<!-- wp:block {"ref":178} /-->]]></content:encoded>
		<excerpt:encoded><![CDATA[枚举器是一个对象，因此他可以保存状态，会记住枚举过程中的位置。迭代器是一个方法，调用它的过程是原子性的，整个调用的过程发生，然后结束。]]></excerpt:encoded>
		<wp:post_id>959</wp:post_id>
		<wp:post_date><![CDATA[2020-10-07 10:48:18]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2020-10-07 02:48:18]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[ruby-%e6%9e%9a%e4%b8%be%e5%99%a8]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="ruby"><![CDATA[Ruby]]></category>
		<category domain="post_tag" nicename="ruby"><![CDATA[Ruby]]></category>
		<category domain="post_tag" nicename="%e6%9e%9a%e4%b8%be%e5%99%a8"><![CDATA[枚举器]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_content_score]]></wp:meta_key>
		<wp:meta_value><![CDATA[90]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_primary_category]]></wp:meta_key>
		<wp:meta_value><![CDATA[3]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_focuskw]]></wp:meta_key>
		<wp:meta_value><![CDATA[Ruby 枚举器]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_metadesc]]></wp:meta_key>
		<wp:meta_value><![CDATA[枚举器是一个对象，因此他可以保存状态，会记住枚举过程中的位置。迭代器是一个方法，调用它的过程是原子性的，整个调用的过程发生，然后结束。]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_linkdex]]></wp:meta_key>
		<wp:meta_value><![CDATA[32]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_thumbnail_id]]></wp:meta_key>
		<wp:meta_value><![CDATA[1379]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>Ruby - 枚举器的方法链</title>
		<link>https://blog.varsion.cn/?p=971</link>
		<pubDate>Wed, 07 Oct 2020 08:03:00 +0000</pubDate>
		<dc:creator><![CDATA[Varsion]]></dc:creator>
		<guid isPermaLink="false">https://blog.varsion.cn/?p=971</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p>方法链是Ruby中最常见的技术，常见的原因从某种程度上来讲，是因为它非常简单，仅仅将几个方法同时使用就可以达到某种目的：</p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">namse = %w{ David Case Ccsaa} 
puts names.select{ |n| n[0] < 'M' }.map(&:upcase).join(", ")</pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<p>数据的处理是从左到右的，就想传送带一样，同时，大部分的处理简单明了。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>方法链通常会在链之间为链接创建新对象。在前面的代码中，<code>names</code>是一个字符串数组，Ruby最终会创建两个或者更多的数组，其中一个是<code>select</code>的输出，另一个是map的输出以及一个从<code>join</code>返回的字符串。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>枚举器并没有解决所有方法链的问题，但他们的确在一些情况下缓减了创建中间对象的问题。</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>节约使用中间对象</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>许多从<code>Enumerable</code>模块中带来的方法在没有代码块的时候，可以返回一个枚举器。在多数情况下，没有必要将枚举器直接链接到另一个方法。例如：<code>name.each.inject</code>可以写成<code>name.inject</code>。相似的，<code>name.map.select</code>并没有比<code>name.select</code>多任何功能出来。<code>map</code>枚举器并不知道关于映射多功能，因此它智能传递值到原始数组到下一个链接。</p>
<!-- /wp:paragraph -->

<!-- wp:group -->
<div class="wp-block-group"><div class="wp-block-group__inner-container"><!-- wp:heading {"level":4} -->
<h4><strong>枚举器的字面表示</strong></h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>运行枚举器以及把他们作为无代码块的迭代器调用后并自动返回，可以以此来正确的阅读枚举器的代码。</p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">string = "An arbitrary string"
string.each_byte.map{ |b| b+1 }</pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<p>思考上述代码，这段的逻辑可能没有什么用途，但这看起来就像<code>string.each_byte</code>会返回一个数组。<code>map</code>的出现作为下一个操作，虽然没有形成数组的证据，但，明确地调用了左侧的集合。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>事实上，<code>string.each_byte</code>方法返回的是一个枚举器。关键在于枚举器就是一个集合类型的对象。它是一个与数组或者散列很像的可枚举对象。</p>
<!-- /wp:paragraph --></div></div>
<!-- /wp:group -->

<!-- wp:heading {"level":3} -->
<h3><code>with_index</code>检索可枚举对象</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>枚举器的<code>with_index</code>可以添加数字索引作为第二个代码块的参数，该参数可以用于任何枚举过程：</p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">('a'..'z').map.with_index{ |letter,i| {letter,i]}
# 输出 : [ ["a",0],["b",1],...]</pre>
<!-- /wp:preformatted -->

<!-- wp:separator {"className":"is-style-wide"} -->
<hr class="wp-block-separator is-style-wide"/>
<!-- /wp:separator -->

<!-- wp:block {"ref":178} /-->]]></content:encoded>
		<excerpt:encoded><![CDATA[方法链是Ruby中最常见的技术，常见的原因从某种程度上来讲，是因为它非常简单，仅仅将几个方法同时使用就可以达到某种目的：]]></excerpt:encoded>
		<wp:post_id>971</wp:post_id>
		<wp:post_date><![CDATA[2020-10-07 16:03:00]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2020-10-07 08:03:00]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[ruby-%e6%9e%9a%e4%b8%be%e5%99%a8%e7%9a%84%e6%96%b9%e6%b3%95%e9%93%be]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="ruby"><![CDATA[Ruby]]></category>
		<category domain="post_tag" nicename="ruby"><![CDATA[Ruby]]></category>
		<category domain="post_tag" nicename="%e6%96%b9%e6%b3%95%e9%93%be"><![CDATA[方法链]]></category>
		<category domain="post_tag" nicename="%e6%9e%9a%e4%b8%be%e5%99%a8"><![CDATA[枚举器]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_primary_category]]></wp:meta_key>
		<wp:meta_value><![CDATA[3]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_content_score]]></wp:meta_key>
		<wp:meta_value><![CDATA[90]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_focuskw]]></wp:meta_key>
		<wp:meta_value><![CDATA[Ruby 方法链]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_metadesc]]></wp:meta_key>
		<wp:meta_value><![CDATA[方法链是Ruby中最常见的技术，常见的原因从某种程度上来讲，是因为它非常简单，仅仅将几个方法同时使用就可以达到某种目的：]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_linkdex]]></wp:meta_key>
		<wp:meta_value><![CDATA[27]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_thumbnail_id]]></wp:meta_key>
		<wp:meta_value><![CDATA[1377]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>Ruby - 单例类和单例模式</title>
		<link>https://blog.varsion.cn/?p=985</link>
		<pubDate>Fri, 09 Oct 2020 00:53:34 +0000</pubDate>
		<dc:creator><![CDATA[Varsion]]></dc:creator>
		<guid isPermaLink="false">https://blog.varsion.cn/?p=985</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p>"单例"一词在Ruby中有第二个不同的含义：单例模式，描述一个类只能有一个实例。Ruby标准库中包含对单例模式的实现，通过 require "singleton 就可以使用。单例类并没有直接与单例模式相关联，"单例"这个词有着更多的重载的意思。</p>
<!-- /wp:paragraph -->

<!-- wp:separator -->
<hr class="wp-block-separator"/>
<!-- /wp:separator -->

<!-- wp:paragraph -->
<p>Ruby中涉及类和模块最常见的就是实例方法的定义，紧接着就是类的实例化以及这些实例方法的调用。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>同时，还可以直接在独立对象上定义单例方法：</p>
<!-- /wp:paragraph -->

<!-- wp:codemirror-blocks/code-block {"mode":"ruby","mime":"text/x-ruby"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre>obj = Object.new
def obj.talk
    puts &quot;hello&quot;
end

obj.talk</pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:paragraph -->
<p>几乎任何的对象都能将单例方法添加到其内部，基于独立对象的本质来定义行为的能力是Ruby设计的标志之一。</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>通过单例类双重决定 </h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>对象的单例方法存在与对象的单例类中，每个对象都有两个类</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul><li>实例方法所属的类</li><li>它的单例类</li></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>对象能调用他原生类中的实例方法，也能够调用他单例类中的方法这是双重的。对象可调用方法的总数量等于定义在这两个类中的实例方法的数量，加上贯穿其祖先类（对象类的超类，类的超类，以此类推）或者任何混合(mix)或前置(prepend)模块的可用方法的数量。可以把对象的单例类看作是某些方法的特殊存储空间，是为该对象特质的，不能与其他对象共享的。</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>检查和修改单例类</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>单例类是匿名的：尽管是类对象的实例，但是他们会自动出现且不需要指定名字。但是，可以打开单例类的类定义主体，然后添加实例方法、类方法和常量，如同常规类一般。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>使用 class 关键字的特殊形式可以做到这一点。</p>
<!-- /wp:paragraph -->

<!-- wp:codemirror-blocks/code-block {"mode":"ruby","mime":"text/x-ruby"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre>class C
    # method and constant def
end</pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:paragraph -->
<p>未来进入单例类的定义主体，需要以这个特殊的符号</p>
<!-- /wp:paragraph -->

<!-- wp:codemirror-blocks/code-block {"mode":"ruby","mime":"text/x-ruby"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre>classs object
    # method and constant def
end</pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:html -->
<p><< object 符号意味着 object 的单例类是匿名的。当位于单例对象定义主体中时，就可以定义方法，然后这些方法就会成为单例方法，只属于当前单例类的对象。</p>
<!-- /wp:html -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">str = "A String"
class &lt;&lt; str
    def twice
        self+" "+self
    end
end
puts str.twice
# A String A String</pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<p><code>twice</code>方法是字符串<code>str</code>的单例方法，同时，完全可以这样做</p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">def str.twice
    self+" "+self
end</pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<p>与上一代码块的区别只在于"撬开"了<code>str</code>的单例类，然后在那里定义的方法。</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4>def obj.method和 class &lt;&lt; obj def method 的区别</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p> 本质上是没有区别的，唯一区别是<strong>常量解析方式不同</strong>:</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>如果有一个顶层常量N，那也可以的定义一个常量N在对象的单例类中。</p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">N = 1
obj = Object.new
class &lt;&lt; obj
    N = 2
end</pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<p>这两种方式的不同点在于对常量的解析方式</p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">def obj.method
    puts N
end
# 输出 1 （外层的N

def &lt;&lt; obj
    def method_s
        puts N
    end
end
# 输出 2 （内层的N 属于obj的单例类</pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<p>这个区别在常量可见性对代码的影响上比较少见，大多数情况下，单例方法定义的两种符号都是可以互相替换的。</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4>使用 class &lt;&lt; 定义类方法</h4>
<!-- /wp:heading -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">class Ticket
    class &lt;&lt; self
        def most_exp(*tickets)
            tickets.max_by(&amp;:price)
        end
    end
end</pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<p> 使用<code>class &lt;&lt; object</code>方式打开了对象的单例类，然后在这个特殊的例子，涉及的对象是类对象<code>Ticket</code>，在代码中调用<code>class &lt;&lt; self</code>时<code>self</code>的值。把该方法定义在类定义快中，其结果是得到定义在<code>Ticket</code>的单例方法，可以说这是<strong>类方法</strong>。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>同样的，类方法也可以这样定义</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>class &lt;&lt; Ticket
    def method
# etc</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>因为在<code>class Ticket</code>定义的主体中，self就是Ticket，在主体的<code>class &lt;&lt; self</code>与主体外的<code>class &lt;&lt; Ticket</code>相同，但是在实践中通常只会看到<code>class &lt;&lt; self</code>，任何时候，对象方法只需要打开的是<code>self</code>。</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3> singleton_class 方法</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>如果要直接引用对象的单例类，可以使用<code>singleton_class</code>方法，这个方法可以减少对<code>class &lt;&lt; object</code>的反复使用。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>下面展示了如何使用该方法来得到对象的单例类的祖先列表</p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">string = "A String"
puts string.singleton_class.ancestors</pre>
<!-- /wp:preformatted -->

<!-- wp:separator {"className":"is-style-wide"} -->
<hr class="wp-block-separator is-style-wide"/>
<!-- /wp:separator -->

<!-- wp:block {"ref":178} /-->]]></content:encoded>
		<excerpt:encoded><![CDATA["单例"一词在Ruby中有第二个不同的含义：单例模式，描述一个类只能有一个实例。Ruby标准库中包含对单例模式的实现，通过require "singleton"就可以使用。单例类并没有直接与单例模式相关联，"单例"这个词有着更多的重载的意思。]]></excerpt:encoded>
		<wp:post_id>985</wp:post_id>
		<wp:post_date><![CDATA[2020-10-09 08:53:34]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2020-10-09 00:53:34]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[ruby-%e5%8d%95%e4%be%8b%e7%b1%bb%e5%92%8c%e5%8d%95%e4%be%8b%e6%a8%a1%e5%bc%8f]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="ruby"><![CDATA[Ruby]]></category>
		<category domain="post_tag" nicename="ruby"><![CDATA[Ruby]]></category>
		<category domain="post_tag" nicename="%e5%8d%95%e4%be%8b%e7%b1%bb"><![CDATA[单例类]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_content_score]]></wp:meta_key>
		<wp:meta_value><![CDATA[90]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_primary_category]]></wp:meta_key>
		<wp:meta_value><![CDATA[3]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_focuskw]]></wp:meta_key>
		<wp:meta_value><![CDATA[单例类和单例模块]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_linkdex]]></wp:meta_key>
		<wp:meta_value><![CDATA[23]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_thumbnail_id]]></wp:meta_key>
		<wp:meta_value><![CDATA[1378]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>Ruby - 基础匿名函数 Proc</title>
		<link>https://blog.varsion.cn/?p=1006</link>
		<pubDate>Tue, 13 Oct 2020 12:37:19 +0000</pubDate>
		<dc:creator><![CDATA[Varsion]]></dc:creator>
		<guid isPermaLink="false">https://blog.varsion.cn/?p=1006</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p>最简单的来说，可调用对象的概念表现为：通过接受消息 call 的对象与某些代码关联，并执行这些关联代码以获得预期的结果。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Ruby中最主要的可调用对象是 Proc 对象、lambda 表达式、方法对象。Proc 对象是自包含的代码序列，可以创建、存储、作为参数传递，还可以使用 call 方法执行。</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>Proc 对象</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>使用 Proc.new 创建 Proc 实例。通过实例化 Proc 类并包含代码块，创建 Proc 对象：</p>
<!-- /wp:paragraph -->

<!-- wp:codemirror-blocks/code-block {"mode":"ruby","mime":"text/x-ruby"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre>pr = Proc.new { puts &quot;Proc's Block&quot; }

pr.call
# Proc's Block</pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:paragraph -->
<p>当一个代码块被应用到对 Proc.new 的调用中后，变为了 Proc 对象的主体，调用该对象的时候，这个代码块就会被执行。</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>Proc 和 代码块的区别</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>创建 Proc 对象是，总要提供一个代码块，但不是没个代码块都可以作为 Proc 的主要成分。</p>
<!-- /wp:paragraph -->

<!-- wp:codemirror-blocks/code-block {"mode":"ruby","mime":"text/x-ruby"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre>[1,2,3].each { |x| puts x * 10 }</pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:paragraph -->
<p>涉及一个代码块但是并没有创建 proc。事情要比之前的复杂一些，这样的语法可以捕获一个代码块，并将其对象化成为proc：</p>
<!-- /wp:paragraph -->

<!-- wp:codemirror-blocks/code-block {"mode":"ruby","mime":"text/x-ruby"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre>def call_a_proc(&amp;block)
  block.call
end

call_a_proc { puts &quot;proc's block&quot; }</pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:paragraph -->
<p>通过使用相似的特殊语法，proc 能够代替在方法调用时的代码块：</p>
<!-- /wp:paragraph -->

<!-- wp:codemirror-blocks/code-block {"mode":"ruby","mime":"text/x-ruby"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre>p = Proc.new { |x| puts x.upcase }
%w{ David Black }.each(&amp;p)
# DAVID BLACK</pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:paragraph -->
<p>在很大程度上，代码块和 proc 的关系实质上是语法与对象的问题。</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3><strong>语法（代码块）和对象（proc）</strong></h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>一个重要的且常见的误解是认为 Ruby 的代码块不是对象。</p>
<!-- /wp:paragraph -->

<!-- wp:codemirror-blocks/code-block {"mode":"ruby","mime":"text/x-ruby"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre>[1,2,3].each { |x| puts x * 10 }</pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:paragraph -->
<p>这是一个微不足道的例子，其中包含一个接受者、点运算符、方法名和代码块：</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>接受者是一个对象，而代码块不是，当然，代码块页是方法调用语法的一部分。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>因为代码块和 proc 的交互操作，代码块的语法相比参数列表的情况复杂一些，Proc的实例是对象，而代码块要包含任何逻辑都需要创建 proc。这就是 Proc.new 要携带代码块的原因：在它被调用更多时候，如何找到 proc 应该执行哪些逻辑的方式。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>又一个重要的含义是，代码块是句法构造，而不是方法参数。为方法提供参数的问题在于代码块是否独立出现，就像一个参数列表是独立出现还是缺失的。当提供了一个代码块，并不是将代码块作为参数传递给方法，他只是代码块本身而已。现在从另外的角度，近距离的看一下转换机制，它允许代码块作为 proc 被捕获，同时也允许 proc 暂时作为代码块的替身。</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>代码块与 proc 相互转换</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>代码块和 proc 相互转换非常容易，因为代码块存在的目的就是被执行，而 proc 是对象，他的任务就是执行之前定义好的代码块。</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>捕获代码块作为 proc</h3>
<!-- /wp:heading -->

<!-- wp:codemirror-blocks/code-block {"mode":"ruby","mime":"text/x-ruby"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre>def capture_block(&amp;block)
  block.call
end
capture_block { puts &quot;Inside the block&quot; }</pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:paragraph -->
<p>该方法会捕获自己的代码块作为 proc 对象然后调用该对象，这是对 Proc.new  隐式调用的一种情况，与使用代码块相同，通过它创建的 proc 绑定到了参数 block 上。</p>
<!-- /wp:paragraph -->

<!-- wp:image {"id":1441,"sizeSlug":"large"} -->
<figure class="wp-block-image size-large"><img src="http://img.varsion.cn/blog-img/2020/10/image-1.png" alt="" class="wp-image-1441"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>语法元素（代码块）是创建一个对象的基础，从代码中创建 proc 的这个“影子”步骤也可以解释为对特殊的基于 &amp; 语法的需求。方法调用可以同时包含参数列表和代码块。如果没有特殊的标记 &amp; ，Ruby没有办法得知用户想要停止绑定参数到常规参数上，并将代码块通过转换变成 proc 并保存这个结果。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>&amp; 标记也会出现在执行另一个转换操作时：使用 Proc 对象代替代码块。</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>对代码块使用 proc</h3>
<!-- /wp:heading -->

<!-- wp:codemirror-blocks/code-block {"mode":"ruby","mime":"text/x-ruby"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre>p = Proc.new { puts &quot;This proc&quot; }
capture_block(&amp;p);
# This proc</pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:paragraph -->
<p>使用 proc 作为代码块的关键在于可以真正的使用它代替代码块：将 proc 作为参数发送给正在调用的方法。如同在方法定义中使用 &amp; 字符标记参数指明这个参数吧代码块转化为 proc 一样，也可以使用 &amp; 表明 在方法调用是 proc 应该要完成的代码块任务。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>因为使用 &amp; 标记的 proc 正在作为代码块使用，因此不能再将代码块发送到同一个方法调用中（会导致 “ both block arg and actual block given" 错误</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Ruby 不能决定哪一个实体（即 proc 和代码块）可以作为代码块，因为只能使用一个。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>如同Ruby运算符，在 &amp;p 中 &amp; 是对方法的包装：从名称上来说，是 to_proc 方法。在 Proc 对象上调用 to_proc 则会返回 Proc 对象本身，相当于在字符串上调用 to_s 或在整数上调用 to_i。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>在 capture_block(&amp;p)中的 &amp; 可以完成两件事：触发了对 p 的 to_proc 方法的调用，然后告诉Ruby将 Proc 对象的结果作为代码块的替身。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>最后，因为 to_proc 是一个放，可以把它用在更为通过的方式中。</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>to_proc 方法概述</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>理论上，可以在任何类中或者任何对象中定义 to_proc 方法，然后这些受影响的对象就可以运用 &amp; 标记的技术。</p>
<!-- /wp:paragraph -->

<!-- wp:codemirror-blocks/code-block {"mode":"ruby","mime":"text/x-ruby"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre>class Person
  attr_accessor :name
  def self.to_proc
    Proc.new { |persom| person.name }
  end
end
d = Person.new
d.name = &quot;David&quot;
m = Person.new
m.name = &quot;Varsion&quot;
puts [d,m].map(&amp;Person)</pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:paragraph -->
<p>这段代码中，存在一个包含两个 Person 对象的数组，并对数组执行了 map 操作，这个 proc 被指定为参数列表中更多 &amp;Person。当然 Person 不是一个 proc，它是一个类。为了使其可行，Ruby 请求 Person 转变为一个 proc ，这样就会隐式的调用 Person 的 to_proc 方法。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>to_proc会产生一个简单的 Proc 对象，它携带一个参数然后在这个参数的基础上调用 name 方法。Person对象本身拥有 name 特性，然后用于测试这段代码而创建的 Person 对象有自己的名称，对 Person 对象数组映射 ([d,m]) ，其所有意义是为了收集这些对象的 name 特性，并将整个结果数组打印输出。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>这个过程复杂，而且涉及松散。毕竟任何携带代码块的放都可以使用 &amp;Person ，如果涉及一个非 Person 且没有 name 方法的对象，这回有点奇怪。但是在这个例子中，to_proc 可以作为一个强大的转换钩子。</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>简洁的 Symbol#to_proc</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>内置方法 Symbol # to_proc 在如下情况中使用：</p>
<!-- /wp:paragraph -->

<!-- wp:codemirror-blocks/code-block {"mode":"ruby","mime":"text/x-ruby"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre>%w { red yellow blue }.map(&amp;:capitalize)
# [&quot;RED&quot;,&quot;YELLOW&quot;,&quot;BLUE&quot;]</pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:paragraph -->
<p>:capitalize 被解释为一次发送到数组中的每个元素的消息，因此上述代码的作用含义和下面这段代码相等：</p>
<!-- /wp:paragraph -->

<!-- wp:codemirror-blocks/code-block {"mode":"ruby","mime":"text/x-ruby"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre>%w { red yellow blue }.map{ |str| str.capitalize}</pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:paragraph -->
<p>但是正如代码展示的，第一段代码会更为整洁。&amp;:capitalize 或者相似的构造，很清晰的解释了他的原理：符号 :capitalize 和 to_proc 的标识符 &amp;。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Symbol # to_proc 还可以更好的用于不实用圆括号的情况</p>
<!-- /wp:paragraph -->

<!-- wp:codemirror-blocks/code-block {"mode":"ruby","mime":"text/x-ruby"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre>%w { red yellow blue }.map &amp;:capitalize</pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:heading {"level":3} -->
<h3>实现 Symbol # to_proc</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>再研究一下 to_proc 的例子，它等同于</p>
<!-- /wp:paragraph -->

<!-- wp:codemirror-blocks/code-block {"mode":"ruby","mime":"text/x-ruby"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre>%w { red yellow blue }.map{ |str| str.capitalize}</pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:paragraph -->
<p>同时也等同于</p>
<!-- /wp:paragraph -->

<!-- wp:codemirror-blocks/code-block {"mode":"ruby","mime":"text/x-ruby"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre>%w { red yellow blue }.map{ |str| str.send(:capitalize)}</pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:paragraph -->
<p>通常来说，不用为他编写什么，因为如果能用常规的点运算符的语法调用，就不必费力的去使用 send 。但是基于 send 编写的版本可以指明使用 Symbol # to_proc 的实现方式。在本例代码块中的任务是为了发送符号 :capitalize 给数组的每个元素。这就意味着，通过 :capitalize#to_proc 创建的 Proc 一定会将 :capitalize 作为参数发送给它自己。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>可以提出对这个 Symbol # to_proc 的简单实现：</p>
<!-- /wp:paragraph -->

<!-- wp:codemirror-blocks/code-block {"mode":"ruby","mime":"text/x-ruby"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre>class Symbol 
  def to_proc
    Proc.new( |obj| send(self)
  end
end</pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:paragraph -->
<p>这个方法会返回一个 Proc 对象，该对象带有一个参数并且会发送 self （它是以后应用中任何符号）参数给自己。</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>proc 作为闭包使用 </h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>当代码块作为到调用对象的主体时，有关变量作用域的问题会变得有趣起来</p>
<!-- /wp:paragraph -->

<!-- wp:codemirror-blocks/code-block {"mode":"ruby","mime":"text/x-ruby"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre>def multipy_by(m)
  Proc.new { |x| puts x*m }
end
mult = multipy_by(10)
mult.call(12) # 120</pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:paragraph -->
<p>这个例子中，multipy_by 返回了一个 proc 这样就可以使用任何参数调用它，但是被乘数还是需要作为参数传递给 multipy_by 。变量 m 无论它是什么值，都会包含到代码中，并传递给 Proc.new，并因此作为乘数，在每次调用 multipy_by 后由 Proc 返回。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Proc 对象在不同的作用域中稍有不同，在为了调用 Proc.new 而构建代码块时，已经创建的局部变量仍然在其作用域中（使用任何代码块都一样）。并且，不管在何时何地调用它，这些变量都会保留在 proc 的作用域中。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Proc 对象会保存其上下文，包括上下文变量的赋值操作。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>携带上下文的那个代码片段称为一个闭包。创建一个闭包如同打包一个箱子：无论在那里打开箱子，他所包含的东西与打包时一致。当打开一个闭包时，它包含当内容都是创建时所包含的。闭包非常重要，因为他们能够保存一个程序的部分运行状态。在方法返回时，离开作用域的变量可能会包含一些有用的信息。</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>Proc 的形式参数和实际参数</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>下面是 Proc 的实例化过程，并携带一个有参数的代码块：</p>
<!-- /wp:paragraph -->

<!-- wp:codemirror-blocks/code-block {"mode":"ruby","mime":"text/x-ruby"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre>pr = Proc.new { |x| puts &quot;Called whit #{x}&quot; }
pr.call(100)</pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:paragraph -->
<p>proc  与方法的不同在于参数处理的方式，因为他们并不关心参数的树立那个是否正确，如果调用多于一个参数，那么单一的参数会被绑定到第一个参数，其他参数将被丢弃。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>当然，也可以使用一些方法来“吸收”参数和其他所有的参数列表的工具。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>唯一重要的一点是，在参数处理上 proc 要比方法少一些麻烦。</p>
<!-- /wp:paragraph -->

<!-- wp:separator {"className":"is-style-wide"} -->
<hr class="wp-block-separator is-style-wide"/>
<!-- /wp:separator -->

<!-- wp:block {"ref":178} /-->]]></content:encoded>
		<excerpt:encoded><![CDATA[最简单的来说，可调用对象的概念表现为：通过接受消息 call 的对象与某些代码关联，并执行这些关联代码以获得预期的结果。]]></excerpt:encoded>
		<wp:post_id>1006</wp:post_id>
		<wp:post_date><![CDATA[2020-10-13 20:37:19]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2020-10-13 12:37:19]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[ruby-%e5%9f%ba%e7%a1%80%e5%8c%bf%e5%90%8d%e5%87%bd%e6%95%b0-proc]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="proc"><![CDATA[Proc]]></category>
		<category domain="category" nicename="ruby"><![CDATA[Ruby]]></category>
		<category domain="post_tag" nicename="ruby"><![CDATA[Ruby]]></category>
		<category domain="post_tag" nicename="%e5%8c%bf%e5%90%8d%e5%87%bd%e6%95%b0"><![CDATA[匿名函数]]></category>
		<category domain="post_tag" nicename="%e5%8f%af%e8%b0%83%e7%94%a8%e5%92%8c%e5%8f%af%e8%bf%90%e8%a1%8c%e5%af%b9%e8%b1%a1"><![CDATA[可调用和可运行对象]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_primary_category]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_content_score]]></wp:meta_key>
		<wp:meta_value><![CDATA[90]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_thumbnail_id]]></wp:meta_key>
		<wp:meta_value><![CDATA[1379]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>Ruby - 将方法作为对象使用</title>
		<link>https://blog.varsion.cn/?p=1528</link>
		<pubDate>Wed, 14 Oct 2020 07:34:09 +0000</pubDate>
		<dc:creator><![CDATA[Varsion]]></dc:creator>
		<guid isPermaLink="false">https://blog.varsion.cn/?p=1528</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:heading -->
<h2>lambda</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>和 Proc.new 一样，lambda 方法也会返回一个 Proc 对象：</p>
<!-- /wp:paragraph -->

<!-- wp:codemirror-blocks/code-block {"mode":"ruby","mime":"text/x-ruby"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre>lam = lambda { puts &quot;A lambda&quot; }
lam.call
# A lambda</pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:paragraph -->
<p>应当注意的是，lambda 创建的 Proc 对象和 Proc.new 创建的有一些不同，这是 Proc 类 独有的一个 lambda 风格：</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>lambda 需要一个明确的创建过程，不论在何处隐式的创建 Proc 对象，都是常规的 proc 而不是 lambda 。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>lambda 和 proc 的另外一个不同是对待 return 返回关键字的方式。lambda 中的return 会触发整个 lambda 主体立即退出 lambda 所在的代码上下文。proc 中的 return 会从 proc 被执行所在的方法中返回。</p>
<!-- /wp:paragraph -->

<!-- wp:codemirror-blocks/code-block {"mode":"ruby","mime":"text/x-ruby"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre>def Test_re
  lam = lambda { return }
  lam.call
  puts &quot;hello&quot;
  p = Proc.new { return }
  p.call
  puts &quot;Qus?&quot;
end
Test_re
# hello</pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:paragraph -->
<p>这个代码片段只会输出 hello 而不会输出第二条打印消息。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>值得注意的是，proc 内部的 return 触发了闭合方法的返回，当没有位于方法内部调用包含 return 的 proc 时，会触发一个严重的错误。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>最后，最为重要的是，lambda 不能在调用的时候使用错误的参数数量，并不能像 proc 一样。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>在实践中，Ruby最常调用的不是 proc 或者 lambda，而是方法。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>在我看了，方法调用看作是一个层级里的传递过程：发送消息给对象，然后对象执行所匹配的命名了的方法。</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>将方法作为对象使用</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>方法自己并不能作为对象，触发对他们进行一些处理，如果要将他们作为对象使用，就要涉及 <em>对象化 objectify</em>。</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>捕获对象方法</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>通过 method 方法，并将方法名作为参数传递给它（以字符串或者符号的形式），就可以得到 Method 对象</p>
<!-- /wp:paragraph -->

<!-- wp:codemirror-blocks/code-block {"mode":"ruby","mime":"text/x-ruby"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre>class C
  def talk
    puts &quot;Hello&quot;
  end
end
c = C.new
meth = c.method(:talk)</pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:paragraph -->
<p>这样就拥有了一个 Method 对象，具体来说是一个绑定的 Method 对象：不是抽象层的 talk 方法，而是具体的 talk 方法绑定到了对象 c 上，如果发送 call 消息给 meth，它会知道要通过 c 扮演 self 角色来调用自己</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>也可以将方法从对象上解除绑定，然后绑定到其他对象上，需要另一个对象与原始对象同类或者为其子类。</p>
<!-- /wp:paragraph -->

<!-- wp:codemirror-blocks/code-block {"mode":"ruby","mime":"text/x-ruby"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre>class D &lt; C
end
d = D.new
unbound = meth.unbind
unbound.bind(d).call</pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:paragraph -->
<p>如果要直接得到一个未绑定的方法对象，而不在已绑定的方法上调用 ubbind 方法，可以通过 instance_method 从类中得到更多，而不使用类实例</p>
<!-- /wp:paragraph -->

<!-- wp:codemirror-blocks/code-block {"mode":"ruby","mime":"text/x-ruby"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre>unbound = C.instance_method(:talk)</pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:paragraph -->
<p>可以说，在有了这个未绑定的方法之后，就能够使用 bind 方法将它绑定到 C 或者 C的子类的任意实例上。</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>方法对象的基本原理</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>假如已经得到某个类体系，并在体系中重新定义了某个方法</p>
<!-- /wp:paragraph -->

<!-- wp:codemirror-blocks/code-block {"mode":"ruby","mime":"text/x-ruby"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre>class A
  def a_meth
    puts &quot;def in A&quot;
  end
end
class B &lt; A
  def a_meth
    puts &quot;def in B&quot;
  end
end
class C &lt; B
end

c = C.new
c.a_meth</pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:paragraph -->
<p>需要寻求一种方式，通过执行类中的方法版本，让最低一层的类来响应上两个类级别的类方法。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>默认情况下，最低一层的实例是不能达到这个要求的，因为他会遍历方法查找路径，所以会执行第一次匹配的方法：</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code># 输出为
def in B</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>但是可以强制使用解绑操作和绑定操作来解决这个问题</p>
<!-- /wp:paragraph -->

<!-- wp:codemirror-blocks/code-block {"mode":"ruby","mime":"text/x-ruby"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre>A.instancd_method(:a_meth).bind(c).call
# def in A</pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:paragraph -->
<p>可以直接将该方法保存到 C 类的某个方法中，然后直接在 c 上调用该方法。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>这个例子中传达了一个矛盾的状态：如果需要控制对象去响应已经重定义过的方法，那么就应该重新审查自己的代码，而不管已经创建的类或者模块体系。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>同时，方法是可调用对象，可以将他们从实例对象上分离出去（解绑）</p>
<!-- /wp:paragraph -->

<!-- wp:separator {"className":"is-style-wide"} -->
<hr class="wp-block-separator is-style-wide"/>
<!-- /wp:separator -->

<!-- wp:block {"ref":178} /-->]]></content:encoded>
		<excerpt:encoded><![CDATA[值得注意的是，proc 内部的 return 触发了闭合方法的返回，当没有位于方法内部调用包含 return 的 proc 时，会触发一个严重的错误。]]></excerpt:encoded>
		<wp:post_id>1528</wp:post_id>
		<wp:post_date><![CDATA[2020-10-14 15:34:09]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2020-10-14 07:34:09]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[ruby-%e5%b0%86%e6%96%b9%e6%b3%95%e4%bd%9c%e4%b8%ba%e5%af%b9%e8%b1%a1%e4%bd%bf%e7%94%a8]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="ruby"><![CDATA[Ruby]]></category>
		<category domain="post_tag" nicename="ruby"><![CDATA[Ruby]]></category>
		<category domain="post_tag" nicename="%e5%8f%af%e8%b0%83%e7%94%a8%e5%92%8c%e5%8f%af%e8%bf%90%e8%a1%8c%e5%af%b9%e8%b1%a1"><![CDATA[可调用和可运行对象]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_thumbnail_id]]></wp:meta_key>
		<wp:meta_value><![CDATA[1377]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>Ruby - 对象消息拦截</title>
		<link>https://blog.varsion.cn/?p=1557</link>
		<pubDate>Sat, 17 Oct 2020 03:17:15 +0000</pubDate>
		<dc:creator><![CDATA[Varsion]]></dc:creator>
		<guid isPermaLink="false">https://blog.varsion.cn/?p=1557</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p>当发消息给对象的时候，对象会在方法查找路径上找到与消息同名的方法执行，如果找不到这样的方法，就会引发 NoMethodError 异常，除非为该对象提供了一个 method_missing 方法。</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>使用 method_missing 实现委托</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>可以将 method_missing 作为对象行为自动拓展的一种方式。例如，一个对象，他从某种方面上来说是一个容器，但是也会有一些其他特性。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>或许是一个药箱，作为药物的集合，有另外的一些属性需要单独的存储和处理，既包含了药物，又包含了这些药物的元数据。</p>
<!-- /wp:paragraph -->

<!-- wp:codemirror-blocks/code-block {"mode":"ruby","mime":"text/x-ruby"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre> class DrugBox
   attr_accessor :drug_name,:drug_date
   def initialize
     @drugs = []
   end
   def method_missing(m,*args,&amp;block)
     @drugs.send(m,*args,&amp;block)
   end
 end</pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:paragraph -->
<p>现在可以在药箱中执行操作了：</p>
<!-- /wp:paragraph -->

<!-- wp:codemirror-blocks/code-block {"mode":"ruby","mime":"text/x-ruby"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre>drug = DrugBox.new
drug &lt;&lt; drug_for_clod
drug &lt;&lt; drug_for_stomach
other = drug.select { |drugs| drug.main_ingredient == &quot;other&quot; }</pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:paragraph -->
<p>虽然实例中并没有 &lt;&lt;  和 select 方法，因此这些消息会因为 method_missing 被传递到 @drug 数组中。仍然可以在 DrugBox 中直接定义任何方法，甚至可以直接覆盖数组方法，不过 method_missing 免去了定义一道并行处理有序集合方法的麻烦。</p>
<!-- /wp:paragraph -->

<!-- wp:quote -->
<blockquote class="wp-block-quote"><p><strong>Ruby 的方法委托技术</strong></p><p>在 method_missing 的例子中，将（不能识别的）消息的处理委托给了数组 @drugs 。Ruby中有许多将一个对象的获得委托给另外对象的机制。</p></blockquote>
<!-- /wp:quote -->

<!-- wp:heading {"level":3} -->
<h3>源头 BasicObject # method_missing</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>在 BasicObject 中的 method_missing，是定义在类体系树中非常顶层的几个方法之一。由于所有的方法最终都是来源于 该基类，故而所有对象都拥有 method_missing 方法。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>有两个方式可以覆盖默认的 method_missing 方法。一是可以打开 BasicObject 类，然后再次定义 method_missing 方法；第二种方法更为通用，在最顶层定义 method_missing 方法，然后将它作为 Object 私有的实例方法装入。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>如果使用第二种方法，除了 BasicObject 的真正实例之外的所有对象都会找到这个新版本的方法。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>但是，如果定义了自己的 method_missing 方法，就失去了对变量的智能识别而智能识别方法了。</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>method_missing、respond_to?、和respond_to_missing?</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>需要知道的是 method_missing 和 respond_to? 并不等同，可以参考下面的例子</p>
<!-- /wp:paragraph -->

<!-- wp:codemirror-blocks/code-block {"mode":"ruby","mime":"text/x-ruby"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre>class Persom
  attr_accessor :name,:age

  def initialize(name,age)
    @name,@age = name , age
  end

  private def method_missing(m, *args,&amp;block)
    if /set_(.*)/.match(m) # 匹配方法
      self.send(&quot;#{$1}=&quot;,*args)
    else
      super 
    end
  end
end</pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:paragraph -->
<p>因此 Person 对象拥有了 set_age 方法，但是该对象并不能响应他：</p>
<!-- /wp:paragraph -->

<!-- wp:codemirror-blocks/code-block {"mode":"ruby","mime":"text/x-ruby"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre>p = Person.new(&quot;Dvaid&quot;, 22)
p.set_age(20)
puts p.age
puts p.respond_to?(:set_age)</pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:image {"align":"center","id":1578,"sizeSlug":"large","className":"is-style-default"} -->
<div class="wp-block-image is-style-default"><figure class="aligncenter size-large"><img src="http://img.varsion.cn/blog-img/2020/10/image-2.png" alt="" class="wp-image-1578"/></figure></div>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>有一种方法是可以通过定义 respond_to_missing? 方法，可以让 method_missing 和 respond_to? 产生一样的效果。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>下面是要添加到 Person 类中的定义</p>
<!-- /wp:paragraph -->

<!-- wp:codemirror-blocks/code-block {"mode":"ruby","mime":"text/x-ruby"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre>  def respond_to_missing?(m,include_private = false )
    /set_/.match(m) || super 
  end</pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:paragraph -->
<p>现在，新的Person对象可以响应该方法了：</p>
<!-- /wp:paragraph -->

<!-- wp:image {"align":"center","id":1583,"sizeSlug":"large"} -->
<div class="wp-block-image"><figure class="aligncenter size-large"><img src="http://img.varsion.cn/blog-img/2020/10/image-4.png" alt="" class="wp-image-1583"/></figure></div>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>通过使用 respond_to? 的第二个参数，可以控制查询是否要包括私有方法。第二个参数将会被传递到 respond_to_missing? 方法中。如例子中所示，他默认为 false。</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>捕获 include 和 prepend 操作</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>如果想要捕获这些事件，即当他们发生时触发回调，那么可以定义特殊的方法 included 和 prepended。这两个方法都以包含或前置时的类或模块名作为唯一参数。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>现在详细看一下 include 同时要理解一下 prepended 的运行方式与它相同。可以同时快速的测试一下 include。</p>
<!-- /wp:paragraph -->

<!-- wp:codemirror-blocks/code-block {"mode":"ruby","mime":"text/x-ruby"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre>module M
  def self.included(c)
    puts &quot;I have been&quot;
  end
end

class C
  include M  # I have been
end</pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:paragraph -->
<p>当 M 被包含到 C 中，可以看到 M.included 的执行结果。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>就像这个例子中一样，一个模块拦截自己被包含的事件是发生在什么情况下呢。常见的一种讨论是围绕着实例方法和类方法的不同展开的。当一个模块到类中，就确保了定义在模块中的实例方法将会变成类的实例可用的实例方法，但类对象不受影响。接下来，就会有问题产生了：</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>如果想通过在混合模块并添加实例方法对同时，添加类方法应该要怎么做呢。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>由于 included 方法的存在，所以可以捕获 include 操作，然后利用这个机会添加类方法到正在包含的类中。</p>
<!-- /wp:paragraph -->

<!-- wp:codemirror-blocks/code-block {"mode":"ruby","mime":"text/x-ruby"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre>module M
  def self.included(cl)
    def cl.a_class_method
      puts &quot;Now there is has new class method&quot;
    end
  end

  def an_inst_method
    puts &quot;This module is instance method&quot;
  end
end

class C
  include M
end

c = C.new
c.an_inst_method
c.a_class_method</pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:paragraph -->
<p>当类 C 包含模块 M 的时候，有两件事发生。第一，实例方法 an_inst_method 会出现在类的实例的查找路径中。第二，由于 M 的 included 的回调方法，类方法 a_class_method 被定义到了类对象 C 中。</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>拦截 extend</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>使用模块拓展独立对象，是在Ruby中利用对象灵活性和可定制属性的可用技术中最强大的一种。它也是受益于运行时的钩子：使用 Module # extended 方法，可以简历一个回调方法，只要对象执行其所包含的模块的 extend 操作，就可以触发回调执行：</p>
<!-- /wp:paragraph -->

<!-- wp:codemirror-blocks/code-block {"mode":"ruby","mime":"text/x-ruby"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre>module M
  def self.extended(obj)
    puts &quot;Module #{self} is being used by #{obj}&quot;
  end
  def an_inst_method
    puts &quot;This module supplise this instance method&quot;
  end
end

m_obj = Object.new
m_obj.extend(M)
m_obj.an_inst_method
# 输出
# Module M is being used by #&lt;Object:0x00007fd6a3071508&gt;
# This module supplise this instance method</pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:heading {"level":4} -->
<h4>使用 included 和 extended 时单例类的行为</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>实际上，通过 extend 使用模块拓展对象与通过 include 包含模块对于对象的单例类来说都是一样的。无论使用那种方式，结局都是模块会被添加到对象的方法查找路径中，且刚好就在查找链中对象的单例类之后。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>但是这两个操作会触发不同的回调方法，即 extended 和 included 。</p>
<!-- /wp:paragraph -->

<!-- wp:codemirror-blocks/code-block {"mode":"ruby","mime":"text/x-ruby"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre>module M
  def self.included(c)
    puts &quot;#{self} included by#{c}&quot;
  end
  def slef.extended(obj)
    puts &quot;#{self} extended by#{obj}&quot;
  end
end

obj = Object.new
puts &quot;Include M in object's singleton class:&quot;
class &lt;&lt; obj
  include M
end

puts
obj = Object.new
puts &quot;Extending object with M:&quot;
obj.extend(M)</pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:paragraph -->
<p>这两个回调都定义在模块 M 中：included 和 extended。每个回调都会根据方法内的行为打印输出。以刚刚创建的通用对象开始，在对象的单例类中包含模块 M ，然后重复过程，新建另外一个对象后直接使用M拓展该对象：</p>
<!-- /wp:paragraph -->

<!-- wp:image {"align":"center","id":1598,"sizeSlug":"large"} -->
<div class="wp-block-image"><figure class="aligncenter size-large"><img src="http://img.varsion.cn/blog-img/2020/10/image-6.png" alt="" class="wp-image-1598"/></figure></div>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>非常特殊的是，包含操作会触发 included 回调，而拓展操作会触发 extended，尽管在这个特殊的情况下两个操作的结果一样：模块 M 中的方法会被添加到讨论中的对象的方法查找路径。</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>Class # inherited 拦截继承事件</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>可以通过为类定义 inherited 方法来与类继承事件挂钩。如果在指定类中定义了该方法，在继承该类的时候，inherited 会使用新类名作为调用的参数。</p>
<!-- /wp:paragraph -->

<!-- wp:codemirror-blocks/code-block {"mode":"ruby","mime":"text/x-ruby"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre>class C
  def self.inherited(subclass)
    puts &quot;#{self} just got subclassby #{subclass}&quot;
  end
end


class D &lt; C
end

# C just got subclassby D</pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:paragraph -->
<p>D在继承C类的时候自动触发了 inherited 的调用，inherited 是一个类方法，因此只要类定义过它，他的子类在被继承的时候也会自动调用他。然后一次想体系的下级递进。</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4>inherited 回调方法的局限</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>当D继承C时，C是D的超类；但是除此之外，C的单例类也是D的单例类的超类。那就是D调用C的类方法的方式，但是这里并不会触发回调。</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>Module # const_missing</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>该方法是一个常见的回调方法，在给定的模块和方法中，只要引用不可识别的常量，该方法就会被调用：</p>
<!-- /wp:paragraph -->

<!-- wp:codemirror-blocks/code-block {"mode":"ruby","mime":"text/x-ruby"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre>class C
  def self.const_missing(const)
    puts &quot;#{const} is undefined-setting&quot;
    const_set(const,1)
  end
end

puts C::A
puts C::A</pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:image {"align":"center","id":1609,"sizeSlug":"large"} -->
<div class="wp-block-image"><figure class="aligncenter size-large"><img src="http://img.varsion.cn/blog-img/2020/10/image-8.png" alt="" class="wp-image-1609"/></figure></div>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>得益于回调方法，当 C::A 的时候，他被自动定义，这里关注的是 puts 打印的常量值，puts 不必知道这个常量是否之前被定义过，第二次调用的时候，该常量已经被定义了。</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>method_added 和 singleton_method_added</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>如果把 method_added 作为类方法定义在任意的类和模块中，它能够在定义任意的实例方法时被调用。</p>
<!-- /wp:paragraph -->

<!-- wp:codemirror-blocks/code-block {"mode":"ruby","mime":"text/x-ruby"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre>class C
  def self.method_added(m)
    puts &quot;Method #{m} was just defined&quot;
    # 定义回调方法
  end
  def a_new_method
	# 定义实例方法时触发它
  end
end
# Method a_new_method was just defined</pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:paragraph -->
<p>singleton_method_added 和 method_added 所做的事情相同，不过针对的是单例方法。同时，一个奇怪的现象，他触发的是他自己本身：</p>
<!-- /wp:paragraph -->

<!-- wp:codemirror-blocks/code-block {"mode":"ruby","mime":"text/x-ruby"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre>class C
  def self.singleton_method_added(m)
    puts &quot;Method #{m} was just defined &quot;
  end
end
# Method singleton_method_added was just defined </pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:paragraph -->
<p>在大多数情况下，应该将 singleton_method_added 用在对象上而不是类对象上：</p>
<!-- /wp:paragraph -->

<!-- wp:codemirror-blocks/code-block {"mode":"ruby","mime":"text/x-ruby"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre>obj = Object.new
def obj.singleton_method_added(m)
  puts &quot;Singleton method #{m} was defined&quot;
end
def obj.a_new_method
end</pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:paragraph -->
<p>将基于类和基于对象的方式放到一起，可以通过定义对象的单例类相关的放，达到特定对象的效果：</p>
<!-- /wp:paragraph -->

<!-- wp:codemirror-blocks/code-block {"mode":"ruby","mime":"text/x-ruby"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre>obj = Object.new
class &lt;&lt; obj
  def singleton_method_added(m)
     puts &quot;Singleton method #{m} was defined&quot;
  end
  def a_new_method
  end
end</pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:paragraph -->
<p>这个代码的输出和之前的完全相同，最终，绕了一个圈之后，可以将 singleton_method_added 定义为普通类的实例方法，在这种方式中，类的每个实例都可以在创建单例方法的时候触发该回调。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>回调方法的定义掌控着每个该类的实例。在这些定义的单例方法都会因此触发回调。</p>
<!-- /wp:paragraph -->

<!-- wp:separator {"className":"is-style-wide"} -->
<hr class="wp-block-separator is-style-wide"/>
<!-- /wp:separator -->

<!-- wp:block {"ref":178} /-->]]></content:encoded>
		<excerpt:encoded><![CDATA[当发消息给对象的时候，对象会在方法查找路径上找到与消息同名的方法执行，如果找不到这样的方法，就会引发 NoMethodError 异常，除非为该对象提供了一个 method_missing 方法。]]></excerpt:encoded>
		<wp:post_id>1557</wp:post_id>
		<wp:post_date><![CDATA[2020-10-17 11:17:15]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2020-10-17 03:17:15]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[ruby-%e5%af%b9%e8%b1%a1%e6%b6%88%e6%81%af%e6%8b%a6%e6%88%aa]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="ruby"><![CDATA[Ruby]]></category>
		<category domain="post_tag" nicename="ruby"><![CDATA[Ruby]]></category>
		<category domain="post_tag" nicename="%e5%9b%9e%e8%b0%83%e5%92%8c%e9%92%a9%e5%ad%90"><![CDATA[回调和钩子]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_thumbnail_id]]></wp:meta_key>
		<wp:meta_value><![CDATA[1378]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>Rails Session</title>
		<link>https://blog.varsion.cn/?p=1655</link>
		<pubDate>Wed, 11 Nov 2020 02:17:30 +0000</pubDate>
		<dc:creator><![CDATA[Varsion]]></dc:creator>
		<guid isPermaLink="false">https://blog.varsion.cn/?p=1655</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:heading {"level":3} -->
<h3>CookieStore - Session默认的存储方式</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Rails 的 Session 是默认存储在 CookieStore 中的，这是一个安全的做法，CookieStore 会基于 secure_key_base 对 Session 的内容进行加密，并将最终的加密以 Base64 的结果返回作为 Cookie。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>CookieStore 是 Rails哲学提倡的最佳实践中的一个，不需要依赖服务器端的持久化数据库（Redis / Memcache / MySQL）即可实现。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>当我们的 Rails App 运行时，有一个名为_appname_session 的 Cookie 会一直在我们的项目中：</p>
<!-- /wp:paragraph -->

<!-- wp:image {"id":1659,"linkDestination":"media"} -->
<figure class="wp-block-image"><a href="http://img.varsion.cn/blog-img/2020/11/image-3.png"><img src="http://img.varsion.cn/blog-img/2020/11/image-3.png" alt="" class="wp-image-1659"/></a></figure>
<!-- /wp:image -->

<!-- wp:heading {"level":4} -->
<h4>CookieStore的优缺点</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>优点：</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul><li>使用简单，无需额外的后端存储，开箱即用；</li><li>相对与其他存储方式，读写很快，只需解密，无 IO 请求；</li><li>因为 Session 加密存储在用户浏览器，所以不会因为后端存储丢失而导致 Session 失效；</li><li>我们依然可以通过改变 secure_key_base 的方式来使之前的 Session 失效；</li></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>缺点：</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul><li>浏览器 Cookie 限制，加密过后的内容不能超过 4K，所以我们不能在 Session 里面放过多内容；</li><li>如果你的静态资源没有独立域名的话，静态页面的请求 Header 也会多余带这个 Session 的值；</li><li>Session 存储过大内容到了客户端，会导致用户访问服务错误，且难以被发现；</li><li>如果那种验证的 code 存在 Session 里面，会有重现攻击（Replay attacks）风险</li></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>一些提示：</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul><li>flash 也是存在Session里的</li><li>有关用户信息，只需要将 user_id 存于 Session即可，不要将整个 user 对象放进去。</li></ul>
<!-- /wp:list -->

<!-- wp:heading {"level":3} -->
<h3>用户Session</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>正常的持久化登陆流程采用了Session流程：</p>
<!-- /wp:paragraph -->

<!-- wp:codemirror-blocks/code-block {"mode":"ruby","mime":"text/x-ruby","theme":"ttcn"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre>module Concerns
	module UserSession
		def self.included base
			base.class_eval do
				helper_method :logged_in?
				helper_method :current_user
			end
		end
		
		def signin_user user
			session[:user_id] = user.id
		end
		
		def logout_user
			session[:user_id] = nil
		end
		
		def logged_in?
			!!session[:user_id]
		end
		
		def current_user
			if logged_in?
				@current_user ||= User.find(session[:user_id])
				# @current_user = @current_user || User.find(session[:user_id])
			else
				nil
			end
		end
	end
end</pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:paragraph -->
<p>通过对Session的读写和销毁实现用户登陆逻辑。</p>
<!-- /wp:paragraph -->

<!-- wp:separator {"className":"is-style-wide"} -->
<hr class="wp-block-separator is-style-wide"/>
<!-- /wp:separator -->

<!-- wp:paragraph -->
<p>文章参考了：<a rel="noreferrer noopener" href="https://ruby-china.org/topics/39083" target="_blank">Rails 默认 Session 的存储方式：CookieStore</a></p>
<!-- /wp:paragraph -->

<!-- wp:block {"ref":178} /-->]]></content:encoded>
		<excerpt:encoded><![CDATA[Rails 的 Session 是默认存储在 CookieStore 中的，这是一个安全的做法，CookieStore 会基于 secure_key_base 对 Session 的内容进行加密，并将最终的加密以 Base64 的结果返回作为 Cookie。]]></excerpt:encoded>
		<wp:post_id>1655</wp:post_id>
		<wp:post_date><![CDATA[2020-11-11 10:17:30]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2020-11-11 02:17:30]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[rails-session]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="rails"><![CDATA[Rails]]></category>
		<category domain="category" nicename="ruby-on-rails"><![CDATA[Ruby on Rails]]></category>
		<category domain="post_tag" nicename="session"><![CDATA[Session]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_thumbnail_id]]></wp:meta_key>
		<wp:meta_value><![CDATA[1379]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>Rails 模型关联关系</title>
		<link>https://blog.varsion.cn/?p=1677</link>
		<pubDate>Sun, 15 Nov 2020 09:30:39 +0000</pubDate>
		<dc:creator><![CDATA[Varsion]]></dc:creator>
		<guid isPermaLink="false">https://blog.varsion.cn/?p=1677</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p>Rails 中的 <strong>Active Record</strong> 拥有很多强大的功能，主要功能包括：表示模型之间的关系、通过相关联的模型表示继承的层次结构、数据验证等...</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>关联类型</h2>
<!-- /wp:heading -->

<!-- wp:heading {"level":3} -->
<h3>belong_to</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>belong_to 关联会在两个模型之间创建一对一关系，声明所在的模型实例属于另一个模型实例，比如有博客和用户两个模型，并且一篇博客的作者只能是一个用户，就需要在博客的模型中声明。</p>
<!-- /wp:paragraph -->

<!-- wp:codemirror-blocks/code-block {"mode":"ruby","mime":"text/x-ruby"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre>class Blog &lt; ApplicationRecord
# ...
	belongs_to :user
# ...
end</pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:paragraph -->
<p>在 belong_to 关联声明中必须使用单数形式。如果在上面的代码中使用复数形式定义 user 关联，应用会报错，这是因为 Rails 自动使用关联名推导类名，推导出的类名也就变成了复数。</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>has_one</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>has_one 关联也是建立了两个模型之间的一对一关系，但是语意和结果同 belongs_to 不一样。这种关联表示模型的实例包含或拥有另一个模型的实例，例如一条用户登陆信息只能对应者一个用户：</p>
<!-- /wp:paragraph -->

<!-- wp:codemirror-blocks/code-block {"mode":"ruby","mime":"text/x-ruby"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre>class Account &lt; ApplicationRecord
# ...
	has_one :user
# ...
end</pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:paragraph -->
<p>同时根据使用需求，可能还需要为 user 的某列创建唯一性索引或外键约束</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>has_many</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>has_many 关联建立两个模型之间的一对多关系。在 belongs_to 关联的另一端使用该关联。has_many 关联表示模型的实例有零个或多个另一模型的实例。</p>
<!-- /wp:paragraph -->

<!-- wp:codemirror-blocks/code-block {"mode":"ruby","mime":"text/x-ruby"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre> class User &lt; ApplicationRecord
   # ...
   has_many :blogs
   # ...
 end</pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:heading {"level":3} -->
<h3>has_many :through</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>has_many :through 关联场用于建立两个模型之间的多对多关联。这种关联表示一个模型的实例可以借由第三个模型，拥有零个或多个另一个模型的实例。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>例如，一篇博客可以设置多个标签：</p>
<!-- /wp:paragraph -->

<!-- wp:codemirror-blocks/code-block {"mode":"ruby","mime":"text/x-ruby"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre>class Blog &lt; ApplicationRecord
	has_many :blogs_tags,class_name: &quot;BlogsTags&quot;
	has_many :tags,through: :blogs_tags
end
###
class Tag &lt; ApplicationRecord
	has_many :blogs_tags, class_name: &quot;BlogsTags&quot;
	has_many :blogs,through: :blogs_tags
end
###
class BlogsTags &lt; ApplicationRecord
	belongs_to :blog
	belongs_to :tag
end</pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:image {"align":"center","id":1702,"sizeSlug":"large","linkDestination":"media"} -->
<div class="wp-block-image"><figure class="aligncenter size-large"><a href="http://img.varsion.cn/blog-img/2020/11/image-5.png"><img src="http://img.varsion.cn/blog-img/2020/11/image-5.png" alt="" class="wp-image-1702"/></a></figure></div>
<!-- /wp:image -->

<!-- wp:heading {"level":3} -->
<h3>has_one :through</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>has_one :throught 关联建立两个模型之间的一对一关系。这种关联表示一个模型通过第三个模型拥有另一模型的实例。例如，每个商家都有一个账户，每个账户都有一个账户历史：</p>
<!-- /wp:paragraph -->

<!-- wp:codemirror-blocks/code-block {"mode":"ruby","mime":"text/x-ruby"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre>class Supplier &lt; ApplicationRecord
  has_one :account
  has_one :account_history, through: :account
end
 
class Account &lt; ApplicationRecord
  belongs_to :supplier
  has_one :account_history
end
 
class AccountHistory &lt; ApplicationRecord
  belongs_to :account
end</pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:image {"align":"center","id":1708,"sizeSlug":"large","linkDestination":"media"} -->
<div class="wp-block-image"><figure class="aligncenter size-large"><a href="http://img.varsion.cn/blog-img/2020/11/image-8.png"><img src="http://img.varsion.cn/blog-img/2020/11/image-8.png" alt="" class="wp-image-1708"/></a></figure></div>
<!-- /wp:image -->

<!-- wp:heading {"level":3} -->
<h3>has_and_belongs_to_many</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>has_and_belongs_to_many 关联直接建立两个模型之间的多对多关系，不借由第三个模型。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>例如，应用中有装配体和零件两个模型，每个装配体有多个零件，每个零件又可用于多个装配体，这时可以按照下面的方式定义模型：</p>
<!-- /wp:paragraph -->

<!-- wp:codemirror-blocks/code-block {"mode":"ruby","mime":"text/x-ruby"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre>class Assembly &lt; ApplicationRecord
  has_and_belongs_to_many :parts
end
 
class Part &lt; ApplicationRecord
  has_and_belongs_to_many :assemblies
end</pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:image {"align":"center","id":1712,"sizeSlug":"large"} -->
<div class="wp-block-image"><figure class="aligncenter size-large"><img src="http://img.varsion.cn/blog-img/2020/11/image-9.png" alt="" class="wp-image-1712"/></figure></div>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>原理上讲，has_and_belongs_to_many 并不是不借由第三个模型，而是，创建了第三张默认的表来对相应的字段链接进行绑定从而达到多对多关联的效果</p>
<!-- /wp:paragraph -->

<!-- wp:separator {"className":"is-style-wide"} -->
<hr class="wp-block-separator is-style-wide"/>
<!-- /wp:separator -->

<!-- wp:block {"ref":178} /-->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1677</wp:post_id>
		<wp:post_date><![CDATA[2020-11-15 17:30:39]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2020-11-15 09:30:39]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[rails-%e6%a8%a1%e5%9e%8b%e5%85%b3%e8%81%94%e5%85%b3%e7%b3%bb]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="active-record"><![CDATA[Active Record]]></category>
		<category domain="category" nicename="ruby-on-rails"><![CDATA[Ruby on Rails]]></category>
		<category domain="post_tag" nicename="%e6%a8%a1%e5%9e%8b"><![CDATA[模型]]></category>
		<category domain="post_tag" nicename="%e6%a8%a1%e5%9e%8b%e5%85%b3%e8%81%94"><![CDATA[模型关联]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_thumbnail_id]]></wp:meta_key>
		<wp:meta_value><![CDATA[1377]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>SaaS多租户架构考虑</title>
		<link>https://blog.varsion.cn/?p=1719</link>
		<pubDate>Fri, 20 Nov 2020 06:21:07 +0000</pubDate>
		<dc:creator><![CDATA[Varsion]]></dc:creator>
		<guid isPermaLink="false">https://blog.varsion.cn/?p=1719</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:pullquote {"className":"is-style-default"} -->
<figure class="wp-block-pullquote is-style-default"><blockquote><p>TaTsk Pad - 协同任务看板</p><cite>最近萌生的一个想法，TaTsk Pad，目前考虑的需求及功能，是一个基于SaaS架构的多租户平台，相关的开发过程也会在本篇文章中持续更新的。<br>项目将采用 Ruby on Rails(rails 6)进行开发，同时也有考虑后期通过 Flutter 或者 Electron 开发跨平台应用。</cite></blockquote></figure>
<!-- /wp:pullquote -->

<!-- wp:social-links -->
<ul class="wp-block-social-links"><!-- wp:social-link {"url":"","service":"wordpress"} /-->

<!-- wp:social-link {"service":"facebook"} /-->

<!-- wp:social-link {"service":"twitter"} /-->

<!-- wp:social-link {"service":"instagram"} /-->

<!-- wp:social-link {"service":"linkedin"} /-->

<!-- wp:social-link {"service":"youtube"} /-->

<!-- wp:social-link {"service":"github"} /-->

<!-- wp:social-link {"url":"https://github.com/Varsion/TaTskPad","service":"github"} /--></ul>
<!-- /wp:social-links -->

<!-- wp:heading -->
<h2>角色权限访问控制</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>角色权限设计考虑到 SaaS多租户模式：</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul><li>一个用户有可能同时处于多个组织。</li><li>单个组织中的用户涉及到 ‘入职’ 和 ‘离职’ 等业务逻辑。</li><li>。。。</li></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>访问控制是针对越权使用资源的防御措施，目的是为了限制访问主体（如用户等） 对访问客体（如数据库资源等）的访问权限。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>SaaS生产环境中的访问控制策略一般有三种: </p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul><li>自主访问控制（DAC）</li><li>强制访问控制（MAC）</li><li>基于角色的访问控制（RBAC）</li></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>基于角色的访问控制是目前公认的解决大型企业的统一资源访问控制的有效方法。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>RBAC认为权限授权实际上是 Who 、 What 、 How 的问题。在RBAC模型中，Who 、 What 、 How 构成了访问权限三元组，也就是“ Who 对 What(Which) 进行 How 的操作 ”，也就是“ 主体 ”对“ 客体 ”的操作，其中Who——是权限的拥有者或主体（如：User、Role），what——是资源或对象（Resource、Class)。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>主要分为：基本模型RBAC0（Core&nbsp;RBAC）、角色分层模型RBAC1（Hierarchal&nbsp;RBAC）、角色限制模型RBAC2（Constraint&nbsp;RBAC）和统一模型RBAC3（Combines&nbsp;RBAC）。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p></p>
<!-- /wp:paragraph -->]]></content:encoded>
		<excerpt:encoded><![CDATA[最近萌生的一个项目想法，团队任务看板 - TaTsk Pad，目前考虑的需求及功能，是一个基于SaaS架构的多租户平台，相关的开发过程也会在本篇文章中持续更新的。
项目将采用 RAILS 6 进行开发，目前是自己一个人在开发，包揽前后端。]]></excerpt:encoded>
		<wp:post_id>1719</wp:post_id>
		<wp:post_date><![CDATA[2020-11-20 14:21:07]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2020-11-20 06:21:07]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[tatsk-pad-%e5%bc%80%e5%8f%91%e6%89%8b%e8%ae%b0]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="rails-saas"><![CDATA[Rails SaaS]]></category>
		<category domain="category" nicename="ruby-on-rails"><![CDATA[Ruby on Rails]]></category>
		<category domain="category" nicename="saas%e6%9e%b6%e6%9e%84%e3%80%81%e5%bc%80%e5%8f%91"><![CDATA[SaaS架构、开发]]></category>
		<category domain="post_tag" nicename="tatskpad"><![CDATA[TaTskPad]]></category>
		<category domain="post_tag" nicename="%e5%bc%80%e5%8f%91%e6%89%8b%e6%9c%ad"><![CDATA[开发手札]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_thumbnail_id]]></wp:meta_key>
		<wp:meta_value><![CDATA[1725]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>使用Ripper解析Ruby代码</title>
		<link>https://blog.varsion.cn/?p=1738</link>
		<pubDate>Thu, 17 Dec 2020 10:27:08 +0000</pubDate>
		<dc:creator><![CDATA[Varsion]]></dc:creator>
		<guid isPermaLink="false">https://blog.varsion.cn/?p=1738</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p>下述示例代码展示了如何使用 Ripper 解析 Ruby 脚本：</p>
<!-- /wp:paragraph -->

<!-- wp:codemirror-blocks/code-block {"mode":"ruby","mime":"text/x-ruby","theme":"default"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre>require &quot;ripper&quot;
require &quot;pp&quot;

code = &lt;&lt;STR
10.times do |n|
	puts n
end
STR

puts code
pp Ripper.sexp(code)</pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:paragraph -->
<p>可以通过 Ripper.sexp 方法显示 Ruby 解析代码过程中的相关信息，运行该代码可以得到该结果：</p>
<!-- /wp:paragraph -->

<!-- wp:image {"align":"center","id":1739,"sizeSlug":"large"} -->
<div class="wp-block-image"><figure class="aligncenter size-large"><img src="http://img.varsion.cn/blog-img/2020/12/image.png" alt="" class="wp-image-1739"/></figure></div>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>这段输出结果是 Ruby 代码的一种文本表示，在 Ruby 解析代码时，随着语法规则的不断匹配，代码文件中的词条会被转变为一种复杂的内部数据结构：抽象语法树（AST）。被用来记录 Ruby 代码的结构和语法的意义 。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>取最后 block 里的代码部分，也就是 puts n 语句：</p>
<!-- /wp:paragraph -->

<!-- wp:image {"align":"center","id":1745,"sizeSlug":"large"} -->
<div class="wp-block-image"><figure class="aligncenter size-large"><img src="http://img.varsion.cn/blog-img/2020/12/image-3.png" alt="" class="wp-image-1745"/></figure></div>
<!-- /wp:image -->

<!-- wp:image {"align":"center","id":1746,"sizeSlug":"large"} -->
<div class="wp-block-image"><figure class="aligncenter size-large"><img src="http://img.varsion.cn/blog-img/2020/12/image-4.png" alt="" class="wp-image-1746"/></figure></div>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>当使用 Ripper 显示词条信息的时候，源码文件的行和列是以数字类型显示的。例如 [2,1] 表示 Ripper 是在源码的第二行第一列中找到了 puts 调用。也可以看到 Ripper 把 AST 中的每个节点都输出为一个数组，比如：</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>&#91;:@ident, "puts", &#91;2, 1]]</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>对于 puts n 语句，Ruby 现在对其含义已经有了详细的 "描述"（AST），而不是一些模糊的词条流。可以看到函数调用（command）及随后的标识符节点，标明了是哪个函数被调用。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Ruby 使用了 args_add_block 节点，因为可以给一个命令 （command），也就是函数调用，传递块 （block），这个 args_add_block 节点也依然会被保存在 AST 中。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>最后，展示了整个 Ruby 代码示例的 AST</p>
<!-- /wp:paragraph -->

<!-- wp:image {"id":1750,"sizeSlug":"large"} -->
<figure class="wp-block-image size-large"><img src="http://img.varsion.cn/blog-img/2020/12/image-6.png" alt="" class="wp-image-1750"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>上图中的 method add block 是指总在调用一个需要块参数的方法 10.times do 树节点 call 显然是代表实际的方法调用 10.times。<strong>Ruby 把对代码的理解以节点的方式依次保存在了 AST 中。</strong></p>
<!-- /wp:paragraph -->

<!-- wp:separator {"className":"is-style-wide"} -->
<hr class="wp-block-separator is-style-wide"/>
<!-- /wp:separator -->

<!-- wp:block {"ref":178} /-->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1738</wp:post_id>
		<wp:post_date><![CDATA[2020-12-17 18:27:08]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2020-12-17 10:27:08]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e4%bd%bf%e7%94%a8ripper%e8%a7%a3%e6%9e%90ruby%e4%bb%a3%e7%a0%81]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="ruby"><![CDATA[Ruby]]></category>
		<category domain="post_tag" nicename="ruby"><![CDATA[Ruby]]></category>
		<category domain="post_tag" nicename="ruby%e5%8e%9f%e7%90%86%e5%89%96%e6%9e%90"><![CDATA[Ruby原理剖析]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_thumbnail_id]]></wp:meta_key>
		<wp:meta_value><![CDATA[1378]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>在Rails6 中集成前端UI框架</title>
		<link>https://blog.varsion.cn/?p=1754</link>
		<pubDate>Sat, 19 Dec 2020 11:48:42 +0000</pubDate>
		<dc:creator><![CDATA[Varsion]]></dc:creator>
		<guid isPermaLink="false">https://blog.varsion.cn/?p=1754</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p>最近使用 Rails6 进行开发的时候，页面仍然是在不停的用 bootstrap 造轮子，所以就在想可不可以将一些前端UI框架集成到 Rails中，例如： <a rel="noreferrer noopener" href="http://amazeui.shopxo.net/" target="_blank">AmazeUI</a>、<a rel="noreferrer noopener" href="https://www.layui.com/" target="_blank">LayUI</a>等等...</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>因为近些版本Rails都在使用 Webpack 进行静态资源打包，所以一些地方改起来就非常的复杂，也在考虑是用 包管理工具集成管理 还是 将UI框架直接杂糅进Rails 做成 Gem 之类的。</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>使用 Yarn 集成 AmazeUI</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>为了效果演示，我创建了一个静态页面演示控制器：</p>
<!-- /wp:paragraph -->

<!-- wp:image {"align":"center","id":1755,"sizeSlug":"large"} -->
<div class="wp-block-image"><figure class="aligncenter size-large"><img src="http://img.varsion.cn/blog-img/2020/12/image-7.png" alt="" class="wp-image-1755"/></figure></div>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>然后将AmazeUI的演示页面设为主页面查看效果。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>通过yarn添加 amazeui 的资源文件</p>
<!-- /wp:paragraph -->

<!-- wp:image {"align":"center","id":1760,"sizeSlug":"large"} -->
<div class="wp-block-image"><figure class="aligncenter size-large"><img src="http://img.varsion.cn/blog-img/2020/12/image-10.png" alt="" class="wp-image-1760"/></figure></div>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>然后记得将 app/assets/stylesheets/application.css 的文件类型 改为 .scss，即改成 app/assets/stylesheets/application.scss。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>将刚刚导入的 AmazeUI 引入到页面中：</p>
<!-- /wp:paragraph -->

<!-- wp:codemirror-blocks/code-block {"languageLabel":"file","fileName":"app/assets/stylesheets/application.scss","mode":"ruby","mime":"text/x-ruby","theme":"default"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre>@import &quot;amazeui/dist/css/amazeui&quot;;
</pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:paragraph -->
<p>添加这行代码即可引入 AmazeUI 的CSS样式，那么 AmazeUI 的JS组件应该如何引入呢？</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>同时，如果使用 AmazeUI 的JS组件的话 有些地方需要依赖到 jQuery ：</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>通过 yarn 安装 jQuery</p>
<!-- /wp:paragraph -->

<!-- wp:image {"align":"center","id":1767,"sizeSlug":"large"} -->
<div class="wp-block-image"><figure class="aligncenter size-large"><img src="http://img.varsion.cn/blog-img/2020/12/image-12.png" alt="" class="wp-image-1767"/></figure></div>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>然后需要在 config/webpack/environment.js 里添加以下代码，才可以引入  jQuery：</p>
<!-- /wp:paragraph -->

<!-- wp:codemirror-blocks/code-block {"languageLabel":"file","fileName":"config/webpack/environment.js","mode":"ruby","mime":"text/x-ruby","theme":"default"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre>const webpack = require('webpack')

environment.plugins.prepend('Provide',
  new webpack.ProvidePlugin({
    $: 'jquery/src/jquery',
    jQuery: 'jquery/src/jquery'
  })
)
</pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:paragraph -->
<p>然后接下来的一个问题是 Fontawesome 未找到。在 FireFox 浏览器中给了详细的报错：</p>
<!-- /wp:paragraph -->

<!-- wp:image {"align":"center","id":1774,"sizeSlug":"large"} -->
<div class="wp-block-image"><figure class="aligncenter size-large"><img src="http://img.varsion.cn/blog-img/2020/12/image-17.png" alt="" class="wp-image-1774"/></figure></div>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>查了很多资料总结之后，发觉这些应该是引入 CSS 的时候，没有将 CSS 连带的图标/字体包 一起引入，而且在页面路径下寻找这些的时候，直接去网站根目录下寻找了，</p>
<!-- /wp:paragraph -->

<!-- wp:image {"align":"center","id":1779,"sizeSlug":"large"} -->
<div class="wp-block-image"><figure class="aligncenter size-large"><img src="http://img.varsion.cn/blog-img/2020/12/image-22.png" alt="" class="wp-image-1779"/></figure></div>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>找了很久的解决办法，是将本地资源引用切换成网络资源，可以解决问题，但是初次加载页面会很慢（实际使用的时候，可能要在服务器端做个资源映射吧，明明资源就在哪里，就是引用不到，很烦。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>修改 node_modules/amazeui/dist/css/amazeui.css 文件中的部分。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>也只是简单的把文件的url替换了，是在 AmazeUI 的 <a rel="noreferrer noopener" href="https://github.com/amazeui/amazeui/issues/277" target="_blank">issue</a> 里找到的 CDN 加速网站，的确是搜了好久都没有这几个文件的 CDN资源。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>或者，可以将 fonts 资源文件夹 放到 public 文件夹中，也可以解决。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>感觉 Rails6 或者 webpack 在一些静态资源的引用上还不是很舒服（可能是我写垃圾页面代码写多了的缘故</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>然后可以启动服务器，可以看到根路由下的页面的样式，已经是 AmazeUI 的样式了。</p>
<!-- /wp:paragraph -->

<!-- wp:image {"id":1773,"sizeSlug":"large"} -->
<figure class="wp-block-image size-large"><img src="http://img.varsion.cn/blog-img/2020/12/image-16-1024x537.png" alt="" class="wp-image-1773"/></figure>
<!-- /wp:image -->

<!-- wp:separator {"className":"is-style-wide"} -->
<hr class="wp-block-separator is-style-wide"/>
<!-- /wp:separator -->

<!-- wp:block {"ref":178} /-->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1754</wp:post_id>
		<wp:post_date><![CDATA[2020-12-19 19:48:42]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2020-12-19 11:48:42]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e5%9c%a8rails6-%e4%b8%ad%e9%9b%86%e6%88%90%e5%89%8d%e7%ab%afui%e6%a1%86%e6%9e%b6]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="rails"><![CDATA[Rails]]></category>
		<category domain="post_tag" nicename="rails6"><![CDATA[Rails6]]></category>
		<category domain="category" nicename="ruby"><![CDATA[Ruby]]></category>
		<category domain="category" nicename="ruby-on-rails"><![CDATA[Ruby on Rails]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_thumbnail_id]]></wp:meta_key>
		<wp:meta_value><![CDATA[1379]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>用户权限认证系统</title>
		<link>https://blog.varsion.cn/?p=1786</link>
		<pubDate>Wed, 30 Dec 2020 07:13:06 +0000</pubDate>
		<dc:creator><![CDATA[Varsion]]></dc:creator>
		<guid isPermaLink="false">https://blog.varsion.cn/?p=1786</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:verse -->
<pre class="wp-block-verse">在查找了很多有关SaaS架构的资料并完成了项目架构以及初步的数据库设计之后，就。。（开始了长时间的摸鱼</pre>
<!-- /wp:verse -->

<!-- wp:paragraph -->
<p>Rails 已经有一个完善的用户认证系统 <a rel="noreferrer noopener" href="https://github.com/heartcombo/devise" target="_blank">Devise gem</a> ，考虑到其过于庞大，以及自己想尝试着完整一个类似的完善功能，就自己在一步一步的完成。</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>安全的用户认证</h2>
<!-- /wp:heading -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">has_secure_password</pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<p>这是 Rails 为用户验证提供的一个很好的内置方法，提供了一个完善的用户密码验证方式</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul><li> 使用更安全的密码 依赖于 数据库 password_digest 字段</li><li>依赖于 bcrypt gem</li><li>获得一组虚拟属性 password 和 password_confirmation 创建用户对象时会检查该属性是否匹配</li><li>获得 authenticate 方法 用于校验用户密码</li></ul>
<!-- /wp:list -->

<!-- wp:codemirror-blocks/code-block {"mode":"ruby","mime":"text/x-ruby"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre>class User &lt; ApplicationRecord
  ### 
  has_secure_password
  ###
end</pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:heading -->
<h2>用户邮箱激活</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Rails 的 Action Mailer 系统 同其他框架的邮件系统有一些差别，异常的方便，同时可以依靠 Rails Scaffold 从而快速的生成一系列邮件应用。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>邮箱激活验证码：</p>
<!-- /wp:paragraph -->

<!-- wp:codemirror-blocks/code-block {"mode":"ruby","mime":"text/x-ruby"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre>class User &lt; ApplicationRecord
	before_create :create_token_digest
 ####
  	class &lt;&lt; self
  		# 生成一个用于账号验证的随机令牌
  		def new_token
  			SecureRandom.urlsafe_base64
  		end
  		# 返回指定字符串的哈希摘要
	    def digest string
	      cost = ActiveModel::SecurePassword.min_cost ? BCrypt::Engine::MIN_COST : BCrypt::Engine.cost
	      BCrypt::Password.create(string, cost: cost)
	    end
  	end
 ####
  	private
  	  	def create_token_digest
		  	self.activation_token = User.new_token
		  	self.activation_disest = User.digest(activation_token)
	  	end
end</pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:paragraph -->
<p> 依赖于 Rails Active Record 的回调，在数据库对象创建之前（before_create）注意是创建之前，而不是保存之前（before_save）如果是保存之前的话，可能会涉及到用户更新信息时也会调用该回调。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>在数据库对象创建并保存成功之后，将该对象丢给邮件系统，从而将账户激活信息传递给用户。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>用户在邮箱中，点击相应链接从而激活账户。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>对于 邮件验证码 的激活，是采用了额外的资源路由组，从而完成了激活。</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>从用户到组织</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>在用户和组织之间，设计了一个 “会话关系（session）”，一个会话将一个用户连接到了一个组织。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>因为并没有限制一个用户只能加入一个组织，就是说一个用户同时可以是零个或者多个组织的员工。</p>
<!-- /wp:paragraph -->

<!-- wp:image {"align":"center","id":1809,"sizeSlug":"large"} -->
<div class="wp-block-image"><figure class="aligncenter size-large"><img src="http://img.varsion.cn/blog-img/2020/12/image-24.png" alt="" class="wp-image-1809"/></figure></div>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>在这种情况下，将用户和组织的关系以会话的形式进行管理。可以有效的使一个用户在多个组织之间跳转。是一个行之有效的办法。</p>
<!-- /wp:paragraph -->

<!-- wp:separator {"className":"is-style-wide"} -->
<hr class="wp-block-separator is-style-wide"/>
<!-- /wp:separator -->

<!-- wp:block {"ref":178} /-->]]></content:encoded>
		<excerpt:encoded><![CDATA["has_secure_password",这是 Rails 为用户验证提供的一个很好的内置方法，提供了一个完善的用户密码验证方式]]></excerpt:encoded>
		<wp:post_id>1786</wp:post_id>
		<wp:post_date><![CDATA[2020-12-30 15:13:06]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2020-12-30 07:13:06]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[%e7%94%a8%e6%88%b7%e6%9d%83%e9%99%90%e8%ae%a4%e8%af%81%e7%b3%bb%e7%bb%9f]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="ruby-on-rails"><![CDATA[Ruby on Rails]]></category>
		<category domain="category" nicename="saas%e6%9e%b6%e6%9e%84%e3%80%81%e5%bc%80%e5%8f%91"><![CDATA[SaaS架构、开发]]></category>
		<category domain="post_tag" nicename="tatskpad"><![CDATA[TaTskPad]]></category>
		<category domain="post_tag" nicename="%e5%bc%80%e5%8f%91%e6%89%8b%e6%9c%ad"><![CDATA[开发手札]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_thumbnail_id]]></wp:meta_key>
		<wp:meta_value><![CDATA[1725]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>Rails attr_accessor 和 callback</title>
		<link>https://blog.varsion.cn/?p=1812</link>
		<pubDate>Mon, 04 Jan 2021 01:58:10 +0000</pubDate>
		<dc:creator><![CDATA[Varsion]]></dc:creator>
		<guid isPermaLink="false">https://blog.varsion.cn/?p=1812</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p>开发的时候遇到的一个愚蠢的、耗费了超多时间的错误</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>在一条数据创建时，需要额外生成一些无法在表单提交中填入的数据，就比如说：</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>现在一个组织注册，需要自动生成该组织的邀请码，组织管理员可以通过将该邀请码发送给其他用户从而邀请其他用户加入自己的组织</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>看，很简单的一个业务，仅仅需要一个 before_create 即可完成的一个数据回调，然后按照自己的理解，将改字段添加了 attr_accessor </p>
<!-- /wp:paragraph -->

<!-- wp:image {"align":"center","id":1814,"sizeSlug":"large"} -->
<div class="wp-block-image"><figure class="aligncenter size-large"><img src="http://img.varsion.cn/blog-img/2021/01/image-1.png" alt="" class="wp-image-1814"/></figure></div>
<!-- /wp:image -->

<!-- wp:image {"align":"center","id":1816,"sizeSlug":"large"} -->
<div class="wp-block-image"><figure class="aligncenter size-large"><img src="http://img.varsion.cn/blog-img/2021/01/image-3.png" alt="" class="wp-image-1816"/></figure></div>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>然后，无止境的 bug 就涌出来了，数据可以正常创建，但就是这个回调始终无法运行，甚至去找了好多相关的帖子，都没有对这种情况的描述，直到刚刚，抱着尝试的心态将其注释掉，好的，完美运行。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>然后，现在的疑问是 attr_accessor 和 callback 之间有什么关联影响嘛？</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2>有关attr_accessor</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>attr_accessor 可以将类中的一个属性暴漏在外，可以直接通过其属性名对他的值进行操作。相当于为这个属性分配了getter 和 setter 方法。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>我在一篇博客中看到了这样的描述（<a href="https://rubyinrails.com/2014/03/17/what-is-attr_accessor-in-rails/" target="_blank" rel="noreferrer noopener">What is attr_accessor in Rails?</a></p>
<!-- /wp:paragraph -->

<!-- wp:image {"align":"center","id":1820,"sizeSlug":"large"} -->
<div class="wp-block-image"><figure class="aligncenter size-large"><img src="http://img.varsion.cn/blog-img/2021/01/image-5.png" alt="" class="wp-image-1820"/></figure></div>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>即，如果我把这个属性设置为 attr_accessor 就默认不把其添加到数据库中，而仅仅是将其作为一个类属性或者对象属性进行操作使用。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>而和 callback 的关系，也自然无法将其存到数据库中了。</p>
<!-- /wp:paragraph -->

<!-- wp:separator {"className":"is-style-wide"} -->
<hr class="wp-block-separator is-style-wide"/>
<!-- /wp:separator -->

<!-- wp:block {"ref":178} /-->]]></content:encoded>
		<excerpt:encoded><![CDATA[即，如果我把这个属性设置为 Attr_accessor 就默认不把其添加到数据库中，而仅仅是将其作为一个类属性或者对象属性进行操作使用。]]></excerpt:encoded>
		<wp:post_id>1812</wp:post_id>
		<wp:post_date><![CDATA[2021-01-04 09:58:10]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2021-01-04 01:58:10]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[rails-attr_accessor-%e5%92%8c-callback]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="active-record"><![CDATA[Active Record]]></category>
		<category domain="post_tag" nicename="rails"><![CDATA[Rails]]></category>
		<category domain="category" nicename="ruby"><![CDATA[Ruby]]></category>
		<category domain="post_tag" nicename="ruby"><![CDATA[Ruby]]></category>
		<category domain="category" nicename="ruby-on-rails"><![CDATA[Ruby on Rails]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_thumbnail_id]]></wp:meta_key>
		<wp:meta_value><![CDATA[1378]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>浅析Ruby对象</title>
		<link>https://blog.varsion.cn/?p=1824</link>
		<pubDate>Wed, 06 Jan 2021 01:11:03 +0000</pubDate>
		<dc:creator><![CDATA[Varsion]]></dc:creator>
		<guid isPermaLink="false">https://blog.varsion.cn/?p=1824</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:verse -->
<pre class="wp-block-verse">每个 Ruby 对象都是类指针和示例变量数组的组合</pre>
<!-- /wp:verse -->

<!-- wp:paragraph -->
<p>Ruby将每个自定义对象都保存在了名为 RObject 的 C 结构体中，下图展示了该结构体的样子：</p>
<!-- /wp:paragraph -->

<!-- wp:image {"align":"center","id":1830,"sizeSlug":"large"} -->
<div class="wp-block-image"><figure class="aligncenter size-large"><img src="http://img.varsion.cn/blog-img/2021/01/image-7.png" alt="" class="wp-image-1830"/></figure></div>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>顶部的 VALUE 是 RObject 的指针，RObject 结构体包含了 RBasic 结构体和自定义对象特有的信息，一组叫做 flags 的布尔值，用来存储各种内部专用的值，还有一个叫做 <strong>klass</strong> 的<strong>类指针</strong></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>类指针标明对象是哪个类的实例。在 RObject 中，Ruby 保存着每个对象都包含的实例变量数组，numiv是实例变量的数目，而 ivptr 是实例变量的值数组的指针。</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>有关 klass 和 ivptr</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>声明了一个简单的 Ruby 类：</p>
<!-- /wp:paragraph -->

<!-- wp:codemirror-blocks/code-block {"mode":"ruby","mime":"text/x-ruby"} -->
<div class="wp-block-codemirror-blocks-code-block code-block"><pre>class User
  attr_accessor :first_name,:last_name
end</pre></div>
<!-- /wp:codemirror-blocks/code-block -->

<!-- wp:paragraph -->
<p>Ruby 需要在 RObject 中保存类指针，因为每个对象都需要记录创建它的类。当类创建实例对象时，Ruby 内部会在 RObject 中保存指向该类的指针。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>当然，同一个类的不同实例对象 (RObject) 的 klass 的值都会指向其类的结构体 (RClass)。</p>
<!-- /wp:paragraph -->

<!-- wp:image {"align":"center","id":1834,"sizeSlug":"large"} -->
<div class="wp-block-image"><figure class="aligncenter size-large"><img src="http://img.varsion.cn/blog-img/2021/01/image-8.png" alt="" class="wp-image-1834"/></figure></div>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>通过类名 #&lt;User 显示了 li 对象的类指针值，后面的16进制字符串实际是该对象的 VALUE 指针。</p>
<!-- /wp:paragraph -->

<!-- wp:image {"align":"center","id":1838,"sizeSlug":"large"} -->
<div class="wp-block-image"><figure class="aligncenter size-large"><img src="http://img.varsion.cn/blog-img/2021/01/image-11.png" alt="" class="wp-image-1838"/></figure></div>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>Ruby 使用实例变量数组来记录保存在对象中的值。</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>有关基本类型对象</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>在内部，Ruby 使用了和 RObject 不一样的结构体来保存每个基本数据类型的值，例如 RString、RArray、RRegexp...</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>这些不同的结构体都包含了同样的 RBasic 结构体。</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>有关简单立即值</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>为了优化性能，Ruby 保存小值证书、符合和其他一些简单立即值时并没有使用任何结构体，只是将它们放到 VALUE 内：</p>
<!-- /wp:paragraph -->

<!-- wp:image {"align":"center","id":1846,"sizeSlug":"large"} -->
<div class="wp-block-image"><figure class="aligncenter size-large"><img src="http://img.varsion.cn/blog-img/2021/01/image-13.png" alt="" class="wp-image-1846"/></figure></div>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>这里的 VALUE 并不是指针，而是立即值本身，对这些简单的数据来说，并不存在类指针。Ruby 使用保存在 VALUE 中的前几个比特的一串比特标记来记忆这些值的类。例如，全部小值整数都有 FIXNUM_FLAG 位标记。</p>
<!-- /wp:paragraph -->

<!-- wp:image {"align":"center","id":1849,"sizeSlug":"large"} -->
<div class="wp-block-image"><figure class="aligncenter size-large"><img src="http://img.varsion.cn/blog-img/2021/01/image-15.png" alt="" class="wp-image-1849"/></figure></div>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>一旦 FIXNUM_FLAG 被设置，Ruby 就知道这个 VALUE 是一个小值整数，是 Fixnum 类的实例，而不是指向结构体的指针。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>同样的，位标记也会标示 VALUE 是否为符号型，诸如 nil、true、false 这些值也有各自的标记</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>同时基本类对象也拥有实例变量，可以通过 instance_variables 方法，将一些基本数据类型的值插入其实例变量数组。</p>
<!-- /wp:paragraph -->

<!-- wp:image {"id":1854,"sizeSlug":"large"} -->
<figure class="wp-block-image size-large"><img src="http://img.varsion.cn/blog-img/2021/01/image-16.png" alt="" class="wp-image-1854"/><figcaption>在字符串对象中保存实例变量</figcaption></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>在内部，Ruby 使用了一点 Hack 手法来为基本类型对象保存实例变量——因为这些对象内部并没有使用 RObject 结构体。当在基本类型对象中保存实例变量时，Ruby 会把它保存在名为 generic_iv_tbl 的特殊散列中。</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>该散列维护这人基本类型对象和另外一些散列的<strong>指针映射</strong>，而那些散列包含了基本类型对象的所有实例变量。</p>
<!-- /wp:paragraph -->

<!-- wp:image {"id":1857,"sizeSlug":"large"} -->
<figure class="wp-block-image size-large"><img src="http://img.varsion.cn/blog-img/2021/01/image-17.png" alt="" class="wp-image-1857"/><figcaption>generic_iv_tbl 为基本类型对象保存了实例变量</figcaption></figure>
<!-- /wp:image -->

<!-- wp:separator {"className":"is-style-wide"} -->
<hr class="wp-block-separator is-style-wide"/>
<!-- /wp:separator -->

<!-- wp:block {"ref":178} /-->]]></content:encoded>
		<excerpt:encoded><![CDATA[每个 Ruby 对象都是类指针和示例变量数组的组合]]></excerpt:encoded>
		<wp:post_id>1824</wp:post_id>
		<wp:post_date><![CDATA[2021-01-06 09:11:03]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2021-01-06 01:11:03]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[ruby-%e7%9a%84-%e5%af%b9%e8%b1%a1]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="ruby"><![CDATA[Ruby]]></category>
		<category domain="post_tag" nicename="ruby"><![CDATA[Ruby]]></category>
		<category domain="post_tag" nicename="ruby%e5%8e%9f%e7%90%86%e5%89%96%e6%9e%90"><![CDATA[Ruby原理剖析]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_thumbnail_id]]></wp:meta_key>
		<wp:meta_value><![CDATA[1377]]></wp:meta_value>
		</wp:postmeta>
							</item>
				</channel>
</rss>
	