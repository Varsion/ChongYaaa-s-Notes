---
title: 跳表(Skip List)
tags:
  - Ruby
  - 数据结构
  - 算法
  - 跳表
id: '452'
categories:
  - - 数据结构与算法
date: 2020-08-12 21:57:24
---

### 如何理解"跳表"

对于一个单链表来讲，即便链表中存储的数据是有序的，如果要想在其中查找某个数据，也只能从头到尾遍历链表。这样查找效率就会很低，时间复杂度会很高，是 `O(n)`。

![](https://static001.geekbang.org/resource/image/e1/6d/e18303fcedc068e5a168de04df956f6d.jpg)

原始链表

每两个结点提取一个结点到上一级，我们把抽出来的那一级叫做索引或索引层。图中的 down 表示 down 指针，指向下一级结点。

![](https://static001.geekbang.org/resource/image/14/8e/14753c824a5ee4a976ea799727adc78e.jpg)

索引

如果现在要查找某个结点，比如 16。可以先在索引层遍历，当遍历到索引层中值为 13 的结点时，发现下一个结点是 17，那要查找的结点 16 肯定就在这两个结点之间。然后通过索引层结点的 down 指针，下降到原始链表这一层，继续遍历。这个时候，只需要再遍历 2 个结点，就可以找到值等于 16 的这个结点了。这样，原来如果要查找 16，需要遍历 10 个结点，现在只需要遍历 7 个结点。

![](https://static001.geekbang.org/resource/image/49/65/492206afe5e2fef9f683c7cff83afa65.jpg)

![](https://static001.geekbang.org/resource/image/46/a9/46d283cd82c987153b3fe0c76dfba8a9.jpg)

多级跳表

这种链表加多级索引的结构，就是跳表。

### 跳表查询的效率

假设，每两个结点抽出一个结点作为上一级索引的结点，那第一级索引的结点个数大约就是 n/2，第二级索引的结点个数大约就是 n/4，第三级索引的结点个数大约就是 n/8，依次类推，也就是说，第 k 级索引的结点个数是第 k-1 级索引的结点个数的 1/2，那第 k级索引结点的个数就是 `n/(2k)`。

假设索引有 h 级，最高级的索引有 2 个结点。通过上面的公式，我们可以得到 `n/(2h)=2`，从而求得 `h=log2n-1`。如果包含原始链表这一层，整个跳表的高度就是 `log₂n`。我们在跳表中查询某个数据的时候，如果每一层都要遍历 m 个结点，那在跳表中查询一个数据的时间复杂度就是 `O(m*logn)`。

### 跳表的空间占用

比起单纯的单链表，跳表需要存储多级索引，要消耗更多的存储空间。

假设原始链表大小为 n，那第一级索引大约有 n/2 个结点，第二级索引大约有 n/4 个结点，以此类推，每上升一级就减少一半，直到剩下 2 个结点:

![](https://static001.geekbang.org/resource/image/10/55/100e9d6e5abeaae542cf7841be3f8255.jpg)

这几级索引的结点总和就是 `n/2+n/4+n/8…+8+4+2=n-2`。所以，跳表的空间复杂度是 O(n)。也就是说，如果将包含 n 个结点的单链表构造成跳表，我们需要额外再用接近 n 个结点的存储空间。

**降低索引占用的内存空间**

前面都是每两个结点抽一个结点到上级索引,所以，可以每三个结点或五个结点，抽一个结点到上级索引。

![](https://static001.geekbang.org/resource/image/0b/f7/0b0680ecf500f9349fc142e1a9eb73f7.jpg)

通过等比数列求和公式，总的索引结点大约就是 `n/3+n/9+n/27+…+9+3+1=n/2`。尽管空间复杂度还是 `O(n)`，但比上面的每两个结点抽一个结点的索引构建方法，要减少了一半的索引结点存储空间。

### 高效的动态插入和删除

跳表这个动态数据结构，不仅支持查找操作，还支持动态的插入、删除操作，而且插入、删除操作的时间复杂度也是 `O(logn)`。

对于纯粹的单链表，需要遍历每个结点，来找到插入的位置。

但是，对于跳表来说，查找某个结点的时间复杂度是 `O(logn)`，所以这里查找某个数据应该插入的位置，方法也是类似的，时间复杂度也是 `O(logn)`。

![](https://static001.geekbang.org/resource/image/65/6c/65379f0651bc3a7cfd13ab8694c4d26c.jpg)

### 跳表索引的动态更新

当我们不停地往跳表中插入数据时，如果我们不更新索引，就有可能出现某 2 个索引结点之间数据非常多的情况。极端情况下，跳表还会退化成单链表。

作为一种动态数据结构，需要某种手段来维护索引与原始链表大小之间的平衡，也就是说，如果链表中结点多了，索引结点就相应地增加一些，避免复杂度退化，以及查找、插入、删除操作性能下降。

通过一个随机函数，来决定将这个结点插入到哪几级索引中，比如随机函数生成了值 K，那就将这个结点添加到第一级到第 K 级这 K 级索引中。

![](https://static001.geekbang.org/resource/image/a8/a7/a861445d0b53fc842f38919365b004a7.jpg)

随机函数的选择很有讲究，从概率上来讲，能够保证跳表的索引大小和数据大小平衡性，不至于性能过度退化。

* * *