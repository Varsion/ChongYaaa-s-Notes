---
title: Ruby - 枚举器
tags:
  - Ruby
  - 枚举器
id: '959'
categories:
  - - Ruby
abbrlink: 63d9b99f
date: 2020-10-07 10:48:18
---

### 使用枚举器保护对象

思考使用一个数组作为参数的方法

```
def get_array(array)
```

如果传递一个数组对象给这个方法，这个方法就可以修改该数组对象

```
array << "new element"
```

如果想要保护这个数组对象不被改变，可以选择复制改数组，并传递他的替代品，即，使用枚举器迭代

```
def get_array(array.to_enum)
```

枚举器很乐意去迭代数组，但是他不会接受被改变。（尝试对枚举器使用`<<` 会引起致命错误

枚举器可以作为集合类型对象对一种网关（gateway）：允许迭代和测试元素对操作，但是不允许破坏性操作。

因为，枚举器本身就是对象，是有状态的。

### 细粒度迭代

枚举器可以维护状态，可以持续追踪自身迷局的过程，许多方法都可以直接获取到这些信息

```
name = %w { M L }
e = name.to_enum
puts e.next
puts e.next 
e.rewind
puts e.next
```

这些代码会输出 `M L M` ，枚举起允许使用者以慢镜头的方式移动，因此，在枚举过程中，可以随意的暂停或者重启。

这一点明确了枚举器和迭代器的差异性。**枚举器是一个对象，因此他可以保存状态，会记住枚举过程中的位置。迭代器是一个方法，调用它的过程是原子性的，整个调用的过程发生，然后结束。**

由于代码块的使用，Ruby的方法调用确实有了很多很有用的复杂特性：方法可以回调代码块。这样可能会影响方法的返回结果，但他仍旧是一个方法。迭代器没有状态，而枚举器是一个可枚举的对象

### 添加可枚举性

枚举器可以将可枚举性添加到不具有该特性的对象中。这就很像是一个关于连线的问题：如果将一个枚举器的`each`方法与任何迭代器关联，就是一使用枚举器在拥有该迭代器的对象上执行可枚举操作，不管该对象自身是否是可枚举的。

将枚举器与`String # bytes`关联，就可以有效的添加可枚举性到没有这个特性的对象中，而`String`不必混合`Enumable`模块。

枚举器将自己附加到特殊对象的特殊方法上，然后juicing该方法作为基础方法如`each`来使用，这样该方就可以作为整个可枚举工具集的其中一个工具来使用。

* * *