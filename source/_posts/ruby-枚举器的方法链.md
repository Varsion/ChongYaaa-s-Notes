---
title: Ruby - 枚举器的方法链
tags:
  - Ruby
  - 方法链
  - 枚举器
id: '971'
categories:
  - - Ruby
date: 2020-10-07 16:03:00
---

方法链是Ruby中最常见的技术，常见的原因从某种程度上来讲，是因为它非常简单，仅仅将几个方法同时使用就可以达到某种目的：

```
namse = %w{ David Case Ccsaa} 
puts names.select{ n n[0] < 'M' }.map(&:upcase).join(", ")
```

数据的处理是从左到右的，就想传送带一样，同时，大部分的处理简单明了。

方法链通常会在链之间为链接创建新对象。在前面的代码中，`names`是一个字符串数组，Ruby最终会创建两个或者更多的数组，其中一个是`select`的输出，另一个是map的输出以及一个从`join`返回的字符串。

枚举器并没有解决所有方法链的问题，但他们的确在一些情况下缓减了创建中间对象的问题。

### 节约使用中间对象

许多从`Enumerable`模块中带来的方法在没有代码块的时候，可以返回一个枚举器。在多数情况下，没有必要将枚举器直接链接到另一个方法。例如：`name.each.inject`可以写成`name.inject`。相似的，`name.map.select`并没有比`name.select`多任何功能出来。`map`枚举器并不知道关于映射多功能，因此它智能传递值到原始数组到下一个链接。

#### **枚举器的字面表示**

运行枚举器以及把他们作为无代码块的迭代器调用后并自动返回，可以以此来正确的阅读枚举器的代码。

```
string = "An arbitrary string"
string.each_byte.map{ b b+1 }
```

思考上述代码，这段的逻辑可能没有什么用途，但这看起来就像`string.each_byte`会返回一个数组。`map`的出现作为下一个操作，虽然没有形成数组的证据，但，明确地调用了左侧的集合。

事实上，`string.each_byte`方法返回的是一个枚举器。关键在于枚举器就是一个集合类型的对象。它是一个与数组或者散列很像的可枚举对象。

### `with_index`检索可枚举对象

枚举器的`with_index`可以添加数字索引作为第二个代码块的参数，该参数可以用于任何枚举过程：

```
('a'..'z').map.with_index{ letter,i {letter,i]}
# 输出 : [ ["a",0],["b",1],...]
```

* * *